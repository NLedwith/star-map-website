/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bigdecimal.js/lib/bigdecimal.js":
/*!******************************************************!*\
  !*** ./node_modules/bigdecimal.js/lib/bigdecimal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


/*
  Copyright (c) 2021 Serkan Ã–zel. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions andg
  limitations under the License.
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MC = exports.Big = exports.BigDecimal = exports.MathContext = exports.RoundingMode = void 0;
/**
 * Specifies a `rounding policy` for numerical operations capable
 * of discarding precision. Each rounding mode indicates how the least
 * significant returned digit of a rounded result is to be calculated.
 * If fewer digits are returned than the digits needed to represent
 * the exact numerical result, the discarded digits will be referred
 * to as the `discarded fraction` regardless the digits'
 * contribution to the value of the number.  In other words,
 * considered as a numerical value, the discarded fraction could have
 * an absolute value greater than one.
 *
 * Each rounding mode description includes a table listing how
 * different two-digit decimal values would round to a one digit
 * decimal value under the rounding mode in question. The result
 * column in the tables could be gotten by creating a
 * `BigDecimal` number with the specified value, forming a
 * {@link MathContext} object with the proper settings
 * (`precision` set to `1`, and the `roundingMode` set to the rounding
 * mode in question), and calling {@link BigDecimal.round | round} on
 * this number with the proper `MathContext`.  A summary table showing the results
 * of these rounding operations for all rounding modes appears below.
 *
 * | Input | UP | DOWN | CEILING | FLOOR | HALF_UP | HALF_DOWN | HALF_EVEN | UNNECESSARY |
 * | --- | --- | --- | --- | --- | --- | --- | --- | --- |
 * | 5.5 | 6 | 5 | 6 | 5 | 6 | 5 | 6 | RangeError |
 * | 2.5 | 3 | 2 | 3 | 2 | 3 | 2 | 2 | RangeError |
 * | 1.6 | 2 | 1 | 2 | 1 | 2 | 2 | 2 | RangeError |
 * | 1.1 | 2 | 1 | 2 | 1 | 1 | 1 | 1 | RangeError |
 * | 1.0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
 * | -1.0 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |
 * | -1.1 | -2 | -1 | -1 | -2 | -1 | -1 | -1 | RangeError |
 * | -1.6 | -2 | -1 | -1 | -2 | -2 | -2 | -2 | RangeError |
 * | -2.5 | -3 | -2 | -2 | -3 | -3 | -2 | -2 | RangeError |
 * | -5.5 | -6 | -5 | -5 | -6 | -6 | -5 | -6 | RangeError |
 *
 */
var RoundingMode;
(function (RoundingMode) {
    /**
     * Rounding mode to round away from zero.  Always increments the
     * digit prior to a non-zero discarded fraction.  Note that this
     * rounding mode never decreases the magnitude of the calculated
     * value.
     */
    RoundingMode[RoundingMode["UP"] = 0] = "UP";
    /**
     * Rounding mode to round towards zero.  Never increments the digit
     * prior to a discarded fraction (i.e., truncates).  Note that this
     * rounding mode never increases the magnitude of the calculated value.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTowardZero".
     */
    RoundingMode[RoundingMode["DOWN"] = 1] = "DOWN";
    /**
     * Rounding mode to round towards positive infinity.  If the
     * result is positive, behaves as for `RoundingMode.UP`;
     * if negative, behaves as for `RoundingMode.DOWN`.  Note
     * that this rounding mode never decreases the calculated value.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTowardPositive".
     */
    RoundingMode[RoundingMode["CEILING"] = 2] = "CEILING";
    /**
     * Rounding mode to round towards negative infinity.  If the
     * result is positive, behave as for `RoundingMode.DOWN`;
     * if negative, behave as for `RoundingMode.UP`.  Note that
     * this rounding mode never increases the calculated value.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTowardNegative".
     */
    RoundingMode[RoundingMode["FLOOR"] = 3] = "FLOOR";
    /**
     * Rounding mode to round towards "nearest neighbor"
     * unless both neighbors are equidistant, in which case round up.
     * Behaves as for `RoundingMode.UP` if the discarded
     * fraction is &ge; 0.5; otherwise, behaves as for
     * `RoundingMode.DOWN`.  Note that this is the rounding
     * mode commonly taught at school.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTiesToAway".
     */
    RoundingMode[RoundingMode["HALF_UP"] = 4] = "HALF_UP";
    /**
     * Rounding mode to round towards "nearest neighbor"
     * unless both neighbors are equidistant, in which case round
     * down.  Behaves as for `RoundingMode.UP` if the discarded
     * fraction is &gt; 0.5; otherwise, behaves as for
     * `RoundingMode.DOWN`.
     */
    RoundingMode[RoundingMode["HALF_DOWN"] = 5] = "HALF_DOWN";
    /**
     * Rounding mode to round towards the "nearest neighbor"
     * unless both neighbors are equidistant, in which case, round
     * towards the even neighbor.  Behaves as for
     * `RoundingMode.HALF_UP` if the digit to the left of the
     * discarded fraction is odd; behaves as for
     * `RoundingMode.HALF_DOWN` if it's even.  Note that this
     * is the rounding mode that statistically minimizes cumulative
     * error when applied repeatedly over a sequence of calculations.
     * It is sometimes known as "Banker's rounding," and is
     * chiefly used in the USA.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTiesToEven".
     */
    RoundingMode[RoundingMode["HALF_EVEN"] = 6] = "HALF_EVEN";
    /**
     * Rounding mode to assert that the requested operation has an exact
     * result, hence no rounding is necessary.  If this rounding mode is
     * specified on an operation that yields an inexact result, an
     * `RangeError` is thrown.
     */
    RoundingMode[RoundingMode["UNNECESSARY"] = 7] = "UNNECESSARY";
})(RoundingMode || (exports.RoundingMode = RoundingMode = {}));
/**
 * Immutable objects which encapsulate the context settings which
 * describe certain rules for numerical operators, such as those
 * implemented by the {@link BigDecimal} class.
 *
 * The base-independent settings are:
 *
 * * precision: the number of digits to be used for an operation; results are
 * rounded to this precision
 * * roundingMode: a {@link RoundingMode} object which specifies the algorithm to be
 * used for rounding.
 *
 * Sample Usage:
 * ```javascript
 * const { Big, MC, RoundingMode } = require('bigdecimal.js');
 *
 * const x = Big('1');
 * const y = Big('3');
 *
 * const res1 = x.divideWithMathContext(y, new MC(3));
 * console.log(res1.toString()); // 0.333
 *
 * // You can also use without `new` operator
 * const res2 = x.divideWithMathContext(y, MC(3, RoundingMode.UP));
 * console.log(res2.toString()); // 0.334
 *
 * try {
 *     x.divide(y);
 *     // throws since full precision is requested but it is not possible
 * } catch (e) {
 *     console.log(e); // RangeError: Non-terminating decimal expansion; no exact representable decimal result.
 * }
 * ```
 */
class MathContext {
    constructor(precision, roundingMode = MathContext.DEFAULT_ROUNDINGMODE) {
        if (precision < 0) {
            throw new RangeError('MathContext precision cannot be less than 0');
        }
        else if (!RoundingMode[roundingMode]) {
            throw new TypeError(`RoundingMode is invalid: ${roundingMode}`);
        }
        this.precision = precision;
        this.roundingMode = roundingMode;
    }
}
exports.MathContext = MathContext;
/** @internal */
MathContext.DEFAULT_ROUNDINGMODE = RoundingMode.HALF_UP;
/**
 * A `MathContext` object whose settings have the values
 * required for unlimited precision arithmetic.
 * The values of the settings are: `precision=0 roundingMode=HALF_UP`
 */
MathContext.UNLIMITED = new MathContext(0, RoundingMode.HALF_UP);
/**
 * A `MathContext` object with a precision setting
 * matching the precision of the IEEE 754-2019 decimal32 format, 7 digits, and a
 * rounding mode of {@link RoundingMode.HALF_EVEN |  HALF_EVEN}.
 * Note the exponent range of decimal32 is **not** used for
 * rounding.
 */
MathContext.DECIMAL32 = new MathContext(7, RoundingMode.HALF_EVEN);
/**
 * A `MathContext` object with a precision setting
 * matching the precision of the IEEE 754-2019 decimal64 format, 16 digits, and a
 * rounding mode of {@link RoundingMode.HALF_EVEN | HALF_EVEN}.
 * Note the exponent range of decimal64 is **not** used for
 * rounding.
 */
MathContext.DECIMAL64 = new MathContext(16, RoundingMode.HALF_EVEN);
/**
 * A `MathContext` object with a precision setting
 * matching the precision of the IEEE 754-2019 decimal128 format, 34 digits, and a
 * rounding mode of {@link RoundingMode.HALF_EVEN | HALF_EVEN}.
 * Note the exponent range of decimal64 is **not** used for
 * rounding.
 */
MathContext.DECIMAL128 = new MathContext(34, RoundingMode.HALF_EVEN);
/**
 * [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) based BigDecimal
 * implementation. This class is ported from java.math.BigDecimal. The following documentation is adapted from openjdk/jdk
 * repository.
 *
 * Immutable, arbitrary-precision signed decimal numbers.  A
 * `BigDecimal` consists of an arbitrary precision number
 * {@link unscaledValue | unscaled value} and a {@link scale | scale}.
 * If zero or positive, the scale is the number of digits to the right of the decimal
 * point. If negative, the unscaled value of the number is multiplied
 * by ten to the power of the negation of the scale.  The value of the
 * number represented by the `BigDecimal` is therefore
 * <code>(unscaledValue &times; 10<sup>-scale</sup>)</code>.
 *
 * The `BigDecimal` class provides operations for
 * arithmetic, scale manipulation, rounding, comparison, hashing, and
 * format conversion.  The {@link toString} method provides a
 * canonical representation of a `BigDecimal`.
 *
 * The `BigDecimal` class gives its user complete control
 * over rounding behavior.  If no rounding mode is specified and the
 * exact result cannot be represented, a `RangeError`
 * is thrown; otherwise, calculations can be carried out to a chosen
 * precision and rounding mode by supplying an appropriate {@link
 * MathContext} object to the operation.  In either case, eight
 * <em>rounding modes</em> are provided for the control of rounding.
 *
 * When a `MathContext` object is supplied with a precision
 * setting of 0 (for example, {@link MathContext.UNLIMITED}),
 * arithmetic operations are exact, as are the arithmetic methods
 * which take no `MathContext` object. As a corollary of
 * computing the exact result, the rounding mode setting of a `
 * MathContext` object with a precision setting of 0 is not used and
 * thus irrelevant.  In the case of divide, the exact quotient could
 * have an infinitely long decimal expansion; for example, 1 divided
 * by 3.  If the quotient has a non-terminating decimal expansion and
 * the operation is specified to return an exact result, a RangeError
 * is thrown.  Otherwise, the exact result of the
 * division is returned, as done for other operations.
 *
 * When the precision setting is not 0, the rules of `BigDecimal`
 * arithmetic are broadly compatible with selected modes
 * of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI
 * X3.274-1996/AM 1-2000 (section 7.4).  Unlike those standards,
 * `BigDecimal` includes many rounding modes.  Any conflicts
 * between these ANSI standards and the `BigDecimal`
 * specification are resolved in favor of `BigDecimal`.
 *
 * Since the same numerical value can have different
 * representations (with different scales), the rules of arithmetic
 * and rounding must specify both the numerical result and the scale
 * used in the result's representation.
 *
 * The different representations of the same numerical value are
 * called members of the same <i>cohort</i>. The {@link
 * compareTo |  natural order} of `BigDecimal`
 * considers members of the same cohort to be equal to each other. In
 * contrast, the {@link equals | equals} method requires both the
 * numerical value and representation to be the same for equality to
 * hold. The results of methods like {@link scale} and {@link
 * unscaledValue} will differ for numerically equal values with
 * different representations.
 *
 * In general the rounding modes and precision setting determine
 * how operations return results with a limited number of digits when
 * the exact result has more digits (perhaps infinitely many in the
 * case of division and square root) than the number of digits returned.
 *
 * First, the total number of digits to return is specified by the
 * `MathContext`'s `precision` setting; this determines
 * the result's <i>precision</i>.  The digit count starts from the
 * leftmost nonzero digit of the exact result.  The rounding mode
 * determines how any discarded trailing digits affect the returned
 * result.
 *
 * For all arithmetic operators, the operation is carried out as
 * though an exact intermediate result were first calculated and then
 * rounded to the number of digits specified by the precision setting
 * (if necessary), using the selected rounding mode.  If the exact
 * result is not returned, some digit positions of the exact result
 * are discarded.  When rounding increases the magnitude of the
 * returned result, it is possible for a new digit position to be
 * created by a carry propagating to a leading "9" digit.
 * For example, rounding the value 999.9 to three digits rounding up
 * would be numerically equal to one thousand, represented as
 * 100&times;10<sup>1</sup>.  In such cases, the new "1" is
 * the leading digit position of the returned result.
 *
 * For methods and constructors with a `MathContext`
 * parameter, if the result is inexact but the rounding mode is {@link
 * RoundingMode.UNNECESSARY | UNNECESSARY}, a RangeError will be thrown.
 *
 * Besides a logical exact result, each arithmetic operation has a
 * preferred scale for representing a result.  The preferred
 * scale for each operation is listed in the table below.
 *
 * <table class="striped" style="text-align:left">
 * <caption>Preferred Scales for Results of Arithmetic Operations
 * </caption>
 * <thead>
 * <tr><th scope="col">Operation</th><th scope="col">Preferred Scale of Result</th></tr>
 * </thead>
 * <tbody>
 * <tr><th scope="row">Add</th><td>max(addend.scale(), augend.scale())</td>
 * <tr><th scope="row">Subtract</th><td>max(minuend.scale(), subtrahend.scale())</td>
 * <tr><th scope="row">Multiply</th><td>multiplier.scale() + multiplicand.scale()</td>
 * <tr><th scope="row">Divide</th><td>dividend.scale() - divisor.scale()</td>
 * <tr><th scope="row">Square root</th><td>radicand.scale()/2</td>
 * </tbody>
 * </table>
 *
 * These scales are the ones used by the methods which return exact
 * arithmetic results; except that an exact divide may have to use a
 * larger scale since the exact result may have more digits.  For
 * example, `1/32` is `0.03125`.
 *
 * Before rounding, the scale of the logical exact intermediate
 * result is the preferred scale for that operation. If the exact
 * numerical result cannot be represented in `precision`
 * digits, rounding selects the set of digits to return and the scale
 * of the result is reduced from the scale of the intermediate result
 * to the least scale which can represent the `precision`
 * digits actually returned.  If the exact result can be represented
 * with at most `precision` digits, the representation
 * of the result with the scale closest to the preferred scale is
 * returned.  In particular, an exactly representable quotient may be
 * represented in fewer than `precision` digits by removing
 * trailing zeros and decreasing the scale.  For example, rounding to
 * three digits using the {@link RoundingMode.FLOOR | floor}
 * rounding mode, <br>
 *
 * `19/100 = 0.19   // number=19,  scale=2` <br>
 *
 * but<br>
 *
 * `21/110 = 0.190  // number=190, scale=3` <br>
 *
 * Note that for add, subtract, and multiply, the reduction in
 * scale will equal the number of digit positions of the exact result
 * which are discarded. If the rounding causes a carry propagation to
 * create a new high-order digit position, an additional digit of the
 * result is discarded than when no new digit position is created.
 *
 * Other methods may have slightly different rounding semantics.
 * For example, the result of the `pow` method using the
 * {@link pow | specified algorithm} can
 * occasionally differ from the rounded mathematical result by more
 * than one unit in the last place, one <i>{@link ulp}</i>.
 *
 * Two types of operations are provided for manipulating the scale
 * of a `BigDecimal`: scaling/rounding operations and decimal
 * point motion operations.  Scaling/rounding operations ({@link
 * setScale} and {@link round}) return a
 * `BigDecimal` whose value is approximately (or exactly) equal
 * to that of the operand, but whose scale or precision is the
 * specified value; that is, they increase or decrease the precision
 * of the stored number with minimal effect on its value.  Decimal
 * point motion operations ({@link movePointLeft} and
 * {@link movePointRight}) return a
 * `BigDecimal` created from the operand by moving the decimal
 * point a specified distance in the specified direction.
 *
 * As a number, the set of values for the scale is large,
 * but bounded. If the scale of a result would exceed the range of a
 * safe number, either by overflow or underflow, the operation may
 * throw a RangerError.
 *
 * For the sake of brevity and clarity, pseudo-code is used
 * throughout the descriptions of `BigDecimal` methods.  The
 * pseudo-code expression `(i + j)` is shorthand for "a
 * `BigDecimal` whose value is that of the `BigDecimal`
 * `i` added to that of the `BigDecimal`
 * `j`." The pseudo-code expression `(i == j)` is
 * shorthand for "`true` if and only if the
 * `BigDecimal` `i` represents the same value as the
 * `BigDecimal` `j`." Other pseudo-code expressions
 * are interpreted similarly.  Square brackets are used to represent
 * the particular `BigInt` and scale pair defining a
 * `BigDecimal` value; for example [19, 2] is the
 * `BigDecimal` numerically equal to 0.19 having a scale of 2.
 *
 * <h2>Relation to IEEE 754 Decimal Arithmetic</h2>
 *
 * Starting with its 2008 revision, the <cite>IEEE 754 Standard for
 * Floating-point Arithmetic</cite> has covered decimal formats and
 * operations. While there are broad similarities in the decimal
 * arithmetic defined by IEEE 754 and by this class, there are notable
 * differences as well. The fundamental similarity shared by
 * `BigDecimal` and IEEE 754 decimal arithmetic is the conceptual
 * operation of computing the mathematical infinitely precise real
 * number value of an operation and then mapping that real number to a
 * representable decimal floating-point value under a <em>rounding
 * policy</em>. The rounding policy is called a {@link
 * RoundingMode | rounding mode} for `BigDecimal` and called a
 * rounding-direction attribute in IEEE 754-2019. When the exact value
 * is not representable, the rounding policy determines which of the
 * two representable decimal values bracketing the exact value is
 * selected as the computed result. The notion of a <em>preferred
 * scale/preferred exponent</em> is also shared by both systems.
 *
 * For differences, IEEE 754 includes several kinds of values not
 * modeled by `BigDecimal` including negative zero, signed
 * infinities, and NaN (not-a-number). IEEE 754 defines formats, which
 * are parameterized by base (binary or decimal), number of digits of
 * precision, and exponent range. A format determines the set of
 * representable values. Most operations accept as input one or more
 * values of a given format and produce a result in the same format.
 * A `BigDecimal`'s {@link scale} is equivalent to
 * negating an IEEE 754 value's exponent. `BigDecimal` values do
 * not have a format in the same sense; all values have the same
 * possible range of scale/exponent and the {@link
 * unscaledValue | unscaled value} has arbitrary precision. Instead,
 * for the `BigDecimal` operations taking a `MathContext`
 * parameter, if the `MathContext` has a nonzero precision, the
 * set of possible representable values for the result is determined
 * by the precision of the `MathContext` argument. For example
 * in `BigDecimal`, if a nonzero three-digit number and a
 * nonzero four-digit number are multiplied together in the context of
 * a `MathContext` object having a precision of three, the
 * result will have three digits (assuming no overflow or underflow,
 * etc.).
 *
 * The rounding policies implemented by `BigDecimal`
 * operations indicated by {@link RoundingMode | rounding modes}
 * are a proper superset of the IEEE 754 rounding-direction
 * attributes.
 *
 * `BigDecimal` arithmetic will most resemble IEEE 754
 * decimal arithmetic if a `MathContext` corresponding to an
 * IEEE 754 decimal format, such as {@link MathContext.DECIMAL64 |
 * decimal64} or {@link MathContext.DECIMAL128 | decimal128} is
 * used to round all starting values and intermediate operations. The
 * numerical values computed can differ if the exponent range of the
 * IEEE 754 format being approximated is exceeded since a
 * `MathContext` does not constrain the scale of `BigDecimal`
 * results. Operations that would generate a NaN or exact infinity,
 * such as dividing by zero, throw a RangeError in
 * `BigDecimal` arithmetic.
 *
 */
class BigDecimal {
    /** @internal */
    static adjustScale(scl, exp) {
        const adjustedScale = scl - exp;
        if (adjustedScale > BigDecimal.MAX_INT_VALUE || adjustedScale < BigDecimal.MIN_INT_VALUE)
            throw new RangeError('Scale out of range.');
        scl = adjustedScale;
        return scl;
    }
    /** @internal */
    constructor(bigIntValue, intCompact, scale, precision) {
        this.intVal = bigIntValue;
        this._scale = scale;
        this._precision = precision;
        this.intCompact = intCompact;
    }
    /**
     * Translates a character array representation of a
     * `BigDecimal` into a `BigDecimal`.
     *
     * @param input input string
     * @param offset first character in the string to inspect.
     * @param len number of characters to consider.
     * @param scale scale value
     * @param mc the context to use.
     * @throws RangeError if `input` is not a valid
     * representation of a `BigDecimal` or the defined subarray
     * is not wholly within `input`.
     * @internal
     */
    static fromString(input, offset, len, scale, mc = MathContext.UNLIMITED) {
        // This is the primary string to BigDecimal constructor
        // Use locals for all fields values until completion
        let prec = 0; // record precision value
        let scl = scale || 0; // record scale value
        let rs = 0; // the compact value in long
        let rb = null; // the inflated value in BigInt
        // use array bounds checking to handle too-long, len == 0,
        // bad offset, etc.
        // handle the sign
        let isneg = false; // assume positive
        if (input[offset] === '-') {
            isneg = true; // leading minus means negative
            offset++;
            len--;
        }
        else if (input[offset] === '+') { // leading + allowed
            offset++;
            len--;
        }
        // should now be at numeric part of the significand
        let dot = false; // true when there is a '.'
        let exp = 0; // exponent
        let c; // current character
        const isCompact = len <= this.MAX_COMPACT_DIGITS;
        // integer significand array & idx is the index to it. The array
        // is ONLY used when we can't use a compact representation.
        let idx = 0;
        if (isCompact) {
            // First compact case, we need not to preserve the character
            // and we can just compute the value in place.
            for (; len > 0; offset++, len--) {
                c = input[offset];
                if ((c === '0')) { // have zero
                    if (prec === 0)
                        prec = 1;
                    else if (rs !== 0) {
                        rs *= 10;
                        ++prec;
                    } // else digit is a redundant leading zero
                    if (dot)
                        ++scl;
                }
                else if ((c >= '1' && c <= '9')) { // have digit
                    const digit = +c;
                    if (prec !== 1 || rs !== 0)
                        ++prec; // prec unchanged if preceded by 0s
                    rs = rs * 10 + digit;
                    if (dot)
                        ++scl;
                }
                else if (c === '.') { // have dot
                    if (dot) // two dots
                        throw new RangeError('Character array contains more than one decimal point.');
                    dot = true;
                }
                else if ((c === 'e') || (c === 'E')) {
                    exp = BigDecimal.parseExp(input, offset, len);
                    // Next test is required for backwards compatibility
                    if (exp > BigDecimal.MAX_INT_VALUE || exp < BigDecimal.MIN_INT_VALUE) // overflow
                        throw new RangeError('Exponent overflow.');
                    break; // [saves a test]
                }
                else {
                    throw new RangeError('Character ' + c
                        + ' is neither a decimal digit number, decimal point, nor'
                        + ' "e" notation exponential mark.');
                }
            }
            if (prec === 0) // no digits found
                throw new RangeError('No digits found.');
            // Adjust scale if exp is not zero.
            if (exp !== 0) { // had significant exponent
                scl = BigDecimal.adjustScale(scl, exp);
            }
            rs = isneg ? -rs : rs;
            const mcp = mc.precision;
            let drop = prec - mcp; // prec has range [1, MAX_INT], mcp has range [0, MAX_INT];
            // therefore, this subtract cannot overflow
            if (mcp > 0 && drop > 0) { // do rounding
                while (drop > 0) {
                    scl = BigDecimal.checkScaleNonZero(scl - drop);
                    rs = BigDecimal.divideAndRound(rs, BigDecimal.TEN_POWERS_TABLE[drop], mc.roundingMode);
                    prec = BigDecimal.integerDigitLength(rs);
                    drop = prec - mcp;
                }
            }
        }
        else {
            const coeff = [];
            for (; len > 0; offset++, len--) {
                c = input[offset];
                // have digit
                if (c >= '0' && c <= '9') {
                    // First compact case, we need not to preserve the character
                    // and we can just compute the value in place.
                    if (c === '0') {
                        if (prec === 0) {
                            coeff[idx] = c;
                            prec = 1;
                        }
                        else if (idx !== 0) {
                            coeff[idx++] = c;
                            prec++;
                        } // else c must be a redundant leading zero
                    }
                    else {
                        if (prec !== 1 || idx !== 0)
                            prec++; // prec unchanged if preceded by 0s
                        coeff[idx++] = c;
                    }
                    if (dot)
                        scl++;
                    continue;
                }
                // have dot
                if (c === '.') {
                    if (dot) { // two dots
                        throw new RangeError('String contains more than one decimal point.');
                    }
                    dot = true;
                    continue;
                }
                // exponent expected
                if ((c !== 'e') && (c !== 'E')) {
                    throw new RangeError('String is missing "e" notation exponential mark.');
                }
                exp = BigDecimal.parseExp(input, offset, len);
                // Next test is required for backwards compatibility
                if (exp > BigDecimal.MAX_INT_VALUE || exp < BigDecimal.MIN_INT_VALUE) // overflow
                    throw new RangeError('Exponent overflow.');
                break; // [saves a test]
            }
            // here when no characters left
            if (prec === 0) { // no digits found
                throw new RangeError('No digits found.');
            }
            // Adjust scale if exp is not zero.
            if (exp !== 0) { // had significant exponent
                scl = BigDecimal.adjustScale(scl, exp);
            }
            const stringValue = coeff.join('');
            // Remove leading zeros from precision (digits count)
            if (isneg)
                rb = BigInt('-' + stringValue);
            else
                rb = BigInt(stringValue);
            rs = BigDecimal.compactValFor(rb);
            const mcp = mc.precision;
            if (mcp > 0 && (prec > mcp)) {
                if (rs === BigDecimal.INFLATED) {
                    let drop = prec - mcp;
                    while (drop > 0) {
                        scl = BigDecimal.checkScaleNonZero(scl - drop);
                        rb = BigDecimal.divideAndRoundByTenPow(rb, drop, mc.roundingMode);
                        rs = BigDecimal.compactValFor(rb);
                        if (rs !== BigDecimal.INFLATED) {
                            prec = BigDecimal.integerDigitLength(rs);
                            break;
                        }
                        prec = BigDecimal.bigDigitLength(rb);
                        drop = prec - mcp;
                    }
                }
                if (rs !== BigDecimal.INFLATED) {
                    let drop = prec - mcp;
                    while (drop > 0) {
                        scl = BigDecimal.checkScaleNonZero(scl - drop);
                        rs = BigDecimal.divideAndRound(rs, BigDecimal.TEN_POWERS_TABLE[drop], mc.roundingMode);
                        prec = BigDecimal.integerDigitLength(rs);
                        drop = prec - mcp;
                    }
                    rb = null;
                }
            }
        }
        return new BigDecimal(rb, rs, scl, prec);
    }
    /** @internal */
    static fromBigInt(value, scale, mc) {
        if (scale === undefined) {
            if (mc === undefined) {
                return BigDecimal.fromBigInt3(value);
            }
            else {
                return BigDecimal.fromBigInt2(value, 0, mc);
            }
        }
        else {
            if (mc === undefined) {
                return BigDecimal.fromBigInt4(value, scale);
            }
            else {
                return BigDecimal.fromBigInt2(value, scale, mc);
            }
        }
    }
    /**
     * Translates a `BigInt` unscaled value and a number
     * scale into a `BigDecimal`, with rounding
     * according to the context settings.  The value of the
     * `BigDecimal` is <code>(unscaledVal &times;
     * 10<sup>-scale</sup>)</code>, rounded according to the
     * `precision` and rounding mode settings.
     *
     * @param intVal unscaled value of the `BigDecimal`.
     * @param scale       scale of the `BigDecimal`.
     * @param mc          the context to use.
     * @internal
     */
    static fromBigInt2(intVal, scale, mc) {
        let unscaledVal = intVal;
        let compactVal = BigDecimal.compactValFor(unscaledVal);
        const mcp = mc.precision;
        let prec = 0;
        if (mcp > 0) { // do rounding
            const mode = mc.roundingMode;
            if (compactVal === BigDecimal.INFLATED) {
                prec = BigDecimal.bigDigitLength(unscaledVal);
                let drop = prec - mcp;
                while (drop > 0) {
                    scale = BigDecimal.checkScaleNonZero(scale - drop);
                    unscaledVal = BigDecimal.divideAndRoundByTenPow(unscaledVal, drop, mode);
                    compactVal = BigDecimal.compactValFor(unscaledVal);
                    if (compactVal !== BigDecimal.INFLATED) {
                        break;
                    }
                    prec = BigDecimal.bigDigitLength(unscaledVal);
                    drop = prec - mcp;
                }
            }
            if (compactVal !== BigDecimal.INFLATED) {
                prec = BigDecimal.integerDigitLength(compactVal);
                let drop = prec - mcp; // drop can't be more than 15
                while (drop > 0) {
                    scale = BigDecimal.checkScaleNonZero(scale - drop);
                    compactVal = BigDecimal.divideAndRound(compactVal, BigDecimal.TEN_POWERS_TABLE[drop], mode);
                    prec = BigDecimal.integerDigitLength(compactVal);
                    drop = prec - mcp;
                }
                unscaledVal = null;
            }
        }
        return new BigDecimal(unscaledVal, compactVal, scale, prec);
    }
    /**
     * Translates a `BigInteger` into a `BigDecimal`.
     * The scale of the `BigDecimal` is zero.
     *
     * @param intVal `BigInt` value to be converted to
     *            `BigDecimal`.
     * @internal
     */
    static fromBigInt3(intVal) {
        const intCompact = BigDecimal.compactValFor(intVal);
        return new BigDecimal(intVal, intCompact, 0, 0);
    }
    /**
     * Translates a `BigInt` unscaled value and a number
     * scale into a `BigDecimal`.  The value of
     * the `BigDecimal` is
     * <code>(unscaledVal &times; 10<sup>-scale</sup>)</code>.
     *
     * @param intVal unscaled value of the `BigDecimal`.
     * @param scale       scale of the `BigDecimal`.
     * @internal
     */
    static fromBigInt4(intVal, scale) {
        // Negative scales are now allowed
        const intCompact = BigDecimal.compactValFor(intVal);
        return new BigDecimal(intVal, intCompact, scale, 0);
    }
    /** @internal */
    static fromBigInt5(intVal, scale, prec) {
        const intCompact = BigDecimal.compactValFor(intVal);
        if (intCompact === 0) {
            return BigDecimal.zeroValueOf(scale);
        }
        else if (scale === 0 && intCompact >= 0 && intCompact < BigDecimal.ZERO_THROUGH_TEN.length) {
            return BigDecimal.ZERO_THROUGH_TEN[intCompact];
        }
        return new BigDecimal(intVal, intCompact, scale, prec);
    }
    /**
     * Translates a `double` into a `BigDecimal`, using
     * the `double`'s canonical string representation provided
     * by the String constructor.
     *
     * @param double `double` to convert to a `BigDecimal`.
     * @param mc math context to use
     * @return a `BigDecimal` whose value is equal to or approximately
     * equal to the value of `double`.
     * @throws RangeError if `double` is not a valid `BigDecimal`
     * @internal
     */
    static fromDouble(double, mc) {
        const strValue = String(double);
        return BigDecimal.fromString(strValue, 0, strValue.length, 0, mc);
    }
    /**
     * Construct a new BigDecimal from a number with given scale and precision
     * @param value integer value
     * @param scale scale value
     * @param mc math context value
     * @internal
     */
    static fromInteger(value, scale, mc) {
        if (mc !== undefined) {
            return BigDecimal.fromNumber5(value, mc);
        }
        else {
            if (scale !== undefined) {
                return BigDecimal.fromInteger3(value, scale);
            }
            else {
                return BigDecimal.fromInteger4(value);
            }
        }
    }
    /** @internal */
    static fromInteger2(value, scale, prec) {
        if (scale === 0 && value >= 0 && value < BigDecimal.ZERO_THROUGH_TEN.length) {
            return BigDecimal.ZERO_THROUGH_TEN[value];
        }
        else if (value === 0) {
            return BigDecimal.zeroValueOf(scale);
        }
        return new BigDecimal(value === BigDecimal.INFLATED ? BigDecimal.INFLATED_BIGINT : null, value, scale, prec);
    }
    /**
     * Translates a `number` unscaled value and a `number`
     * scale into a `BigDecimal`.
     *
     * @param value unscaled value of the `BigDecimal`.
     * @param scale       scale of the `BigDecimal`.
     * @return a `BigDecimal` whose value is
     * <code>(unscaledVal &times; 10<sup>-scale</sup>)</code>.
     * @internal
     */
    static fromInteger3(value, scale) {
        if (scale === 0) {
            return BigDecimal.fromInteger4(value);
        }
        else if (value === 0) {
            return BigDecimal.zeroValueOf(scale);
        }
        return new BigDecimal(value === BigDecimal.INFLATED ? BigDecimal.INFLATED_BIGINT : null, value, scale, 0);
    }
    /**
     * Translates an integer value into a `BigDecimal`
     * with a scale of zero.
     *
     * @param value value of the `BigDecimal`.
     * @return a `BigDecimal` whose value is `value`.
     * @internal
     */
    static fromInteger4(value) {
        if (this.ZERO_THROUGH_TEN[value]) {
            return this.ZERO_THROUGH_TEN[value];
        }
        else if (value !== BigDecimal.INFLATED) {
            return new BigDecimal(null, value, 0, 0);
        }
        else {
            return new BigDecimal(this.INFLATED_BIGINT, value, 0, 0);
        }
    }
    /**
     * Translates an integer into a `BigDecimal`, with
     * rounding according to the context settings.  The scale of the
     * `BigDecimal`, before any rounding, is zero.
     *
     * @param value number value to be converted to `BigDecimal`.
     * @param mc  the context to use.
     * @internal
     */
    static fromNumber5(value, mc) {
        const mcp = mc.precision;
        const mode = mc.roundingMode;
        let prec = 0;
        let scl = 0;
        let rb = (value === BigDecimal.INFLATED) ? BigDecimal.INFLATED_BIGINT : null;
        if (mcp > 0) { // do rounding
            if (value === BigDecimal.INFLATED) {
                prec = 16; // number max digits + 1
                let drop = prec - mcp;
                while (drop > 0) {
                    scl = BigDecimal.checkScaleNonZero(scl - drop);
                    rb = BigDecimal.divideAndRoundByTenPow(rb, drop, mode);
                    value = BigDecimal.compactValFor(rb);
                    if (value !== BigDecimal.INFLATED) {
                        break;
                    }
                    prec = BigDecimal.bigDigitLength(rb);
                    drop = prec - mcp;
                }
            }
            if (value !== BigDecimal.INFLATED) {
                prec = BigDecimal.integerDigitLength(value);
                let drop = prec - mcp;
                while (drop > 0) {
                    scl = BigDecimal.checkScaleNonZero(scl - drop);
                    value = BigDecimal.divideAndRound(value, BigDecimal.TEN_POWERS_TABLE[drop], mc.roundingMode);
                    prec = BigDecimal.integerDigitLength(value);
                    drop = prec - mcp;
                }
                rb = null;
            }
        }
        return new BigDecimal(rb, value, scl, prec);
    }
    /**
     * Returns number of digits in a integer
     * @param value integer value
     * @internal
     */
    static integerDigitLength(value) {
        let length = 0;
        let n = Math.abs(value);
        do {
            n /= 10;
            length++;
        } while (n >= 1);
        return length;
    }
    /**
     * parse exponent
     * @internal
     */
    static parseExp(input, offset, len) {
        let exp = 0;
        offset++;
        let c = input[offset];
        len--;
        const negexp = (c === '-');
        // optional sign
        if (negexp || c === '+') {
            offset++;
            c = input[offset];
            len--;
        }
        if (len <= 0) { // no exponent digits
            throw new RangeError('No exponent digits');
        }
        // skip leading zeros in the exponent
        while (len > 10 && c === '0') {
            offset++;
            c = input[offset];
            len--;
        }
        if (len > 10) { // too many nonzero exponent digits
            throw new RangeError('Too many nonzero exponent digits');
        }
        // c now holds first digit of exponent
        for (;; len--) {
            let v;
            if (c >= '0' && c <= '9') {
                v = +c;
            }
            else {
                // not a digit
                throw new RangeError('Not a digit.');
            }
            exp = exp * 10 + v;
            if (len === 1)
                break; // that was final character
            offset++;
            c = input[offset];
        }
        if (negexp) // apply sign
            exp = -exp;
        return exp;
    }
    /** @internal */
    static fromValue(value, scale, mc) {
        if (typeof value === 'number') {
            if (value > Number.MAX_VALUE || value < -Number.MAX_VALUE) {
                throw new RangeError('Number must be in the range [-Number.MAX_VALUE, Number.MAX_VALUE]');
            }
            if (scale !== undefined && mc !== undefined) {
                throw new RangeError('When constructing from a number, you cannot give both scale and MathContext.');
            }
            if (!Number.isInteger(value)) {
                if (scale !== undefined) {
                    throw new RangeError('You should not give scale when number is a double');
                }
                return BigDecimal.fromDouble(value, mc);
            }
            if (!(value > Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER)) {
                // Unsafe range, build from string
                value = String(value);
                return BigDecimal.fromString(value, 0, value.length, scale, mc);
            }
            return BigDecimal.fromInteger(value, scale, mc);
        }
        if (typeof value === 'bigint') {
            return BigDecimal.fromBigInt(value, scale, mc);
        }
        if (value instanceof BigDecimal) {
            return new BigDecimal(value.intVal, value.intCompact, value.scale(), value._precision);
        }
        if (scale !== undefined) {
            throw new RangeError('You should give scale only with BigInts or integers');
        }
        value = String(value);
        return BigDecimal.fromString(value, 0, value.length, 0, mc);
    }
    /**
     * Converts a value to BigDecimal if it is not already.
     * @param value
     * @internal
     */
    static convertToBigDecimal(value) {
        if (value instanceof BigDecimal)
            return value;
        return BigDecimal.fromValue(value);
    }
    /** @internal */
    static add1(fst, scale1, snd, scale2) {
        let rscale = scale1;
        const sdiff = rscale - scale2;
        if (sdiff !== 0) {
            if (sdiff < 0) {
                const raise = this.checkScale3(fst, -sdiff);
                rscale = scale2;
                fst = BigDecimal.bigMultiplyPowerTen3(fst, raise);
            }
            else {
                const raise = this.checkScale3(snd, sdiff);
                snd = BigDecimal.bigMultiplyPowerTen3(snd, raise);
            }
        }
        const sum = fst.valueOf() + snd.valueOf();
        const sameSignum = (fst === BigDecimal.zeroBigInt && snd === BigDecimal.zeroBigInt) ||
            (fst > BigDecimal.zeroBigInt && snd > BigDecimal.zeroBigInt) ||
            (fst < BigDecimal.zeroBigInt && snd < BigDecimal.zeroBigInt);
        return sameSignum ? new BigDecimal(sum, BigDecimal.INFLATED, rscale, 0) : BigDecimal.fromBigInt5(sum, rscale, 0);
    }
    /** @internal */
    static add2(xs, scale1, snd, scale2) {
        let rscale = scale1;
        const sdiff = rscale - scale2;
        const sameSigns = (snd === BigDecimal.zeroBigInt && xs === 0) ||
            (snd > BigDecimal.zeroBigInt && xs > 0) ||
            (snd < BigDecimal.zeroBigInt && xs < 0);
        let sum;
        if (sdiff < 0) {
            const raise = this.checkScale2(xs, -sdiff);
            rscale = scale2;
            const scaledX = BigDecimal.integerMultiplyPowerTen(xs, raise);
            if (scaledX === BigDecimal.INFLATED) {
                sum = snd.valueOf() + BigDecimal.bigMultiplyPowerTen2(xs, raise).valueOf();
            }
            else {
                sum = snd.valueOf() + BigInt(scaledX).valueOf();
            }
        }
        else { // if (sdiff > 0) {
            const raise = this.checkScale3(snd, sdiff);
            snd = BigDecimal.bigMultiplyPowerTen3(snd, raise);
            sum = snd.valueOf() + BigInt(xs);
        }
        return (sameSigns) ?
            new BigDecimal(sum, BigDecimal.INFLATED, rscale, 0) : BigDecimal.fromBigInt5(sum, rscale, 0);
    }
    /** @internal */
    static add3(xs, scale1, ys, scale2) {
        const sdiff = scale1 - scale2;
        if (sdiff === 0) {
            return BigDecimal.add4(xs, ys, scale1);
        }
        else if (sdiff < 0) {
            const raise = this.checkScale2(xs, -sdiff);
            const scaledX = BigDecimal.integerMultiplyPowerTen(xs, raise);
            if (scaledX !== BigDecimal.INFLATED) {
                return BigDecimal.add4(scaledX, ys, scale2);
            }
            else {
                const bigsum = BigDecimal.bigMultiplyPowerTen2(xs, raise).valueOf() + BigInt(ys).valueOf();
                return ((xs ^ ys) >= 0) ?
                    new BigDecimal(bigsum, BigDecimal.INFLATED, scale2, 0) : BigDecimal.fromBigInt5(bigsum, scale2, 0);
            }
        }
        else {
            const raise = this.checkScale2(ys, sdiff);
            const scaledY = BigDecimal.integerMultiplyPowerTen(ys, raise);
            if (scaledY !== BigDecimal.INFLATED) {
                return BigDecimal.add4(xs, scaledY, scale1);
            }
            else {
                const bigsum = BigDecimal.bigMultiplyPowerTen2(ys, raise).valueOf() + BigInt(xs).valueOf();
                return ((xs ^ ys) >= 0) ?
                    new BigDecimal(bigsum, BigDecimal.INFLATED, scale1, 0) : BigDecimal.fromBigInt5(bigsum, scale1, 0);
            }
        }
    }
    /** @internal */
    static add4(xs, ys, scale) {
        const sum = BigDecimal.add5(xs, ys);
        if (sum !== BigDecimal.INFLATED)
            return BigDecimal.fromInteger3(sum, scale);
        return BigDecimal.fromBigInt5(BigInt(xs) + BigInt(ys), scale, 0);
    }
    /**
     * returns INFLATED if overflows
     * @internal
     */
    static add5(xs, ys) {
        const sum = xs + ys;
        if (sum >= Number.MAX_SAFE_INTEGER)
            return BigDecimal.INFLATED;
        return sum;
    }
    /**
     * Compute val * 10 ^ n; return this product if it is
     * representable as a long, INFLATED otherwise.
     * @internal
     */
    static integerMultiplyPowerTen(val, n) {
        if (val === 0 || n <= 0)
            return val;
        const tab = BigDecimal.TEN_POWERS_TABLE;
        const bounds = BigDecimal.THRESHOLDS_TABLE;
        if (n < tab.length && n < bounds.length) {
            const tenpower = tab[n];
            if (val === 1)
                return tenpower;
            if (Math.abs(val) <= bounds[n])
                return val * tenpower;
        }
        return BigDecimal.INFLATED;
    }
    /**
     * Returns the signum function of this `BigDecimal`.
     *
     * @return -1, 0, or 1 as the value of this `BigDecimal`
     *         is negative, zero, or positive.
     */
    signum() {
        const intCompactSignum = this.intCompact > 0 ? 1 : (this.intCompact < 0 ? -1 : 0);
        const intValSignum = BigDecimal.bigIntSignum(this.intVal);
        return this.intCompact !== BigDecimal.INFLATED ? intCompactSignum : intValSignum;
    }
    /**
     * Returns unscaled value of this `BigDecimal` as `BigInt`
     * @internal
     */
    inflated() {
        return this.intVal === null ? BigInt(this.intCompact) : this.intVal;
    }
    /**
     * Returns the compact value for given `BigInt`, or
     * INFLATED if too big. Relies on internal representation of
     * `BigInt`.
     * @internal
     */
    static compactValFor(value) {
        if (value.valueOf() > Number.MAX_SAFE_INTEGER || value.valueOf() < Number.MIN_SAFE_INTEGER) {
            return BigDecimal.INFLATED;
        }
        return Number(value);
    }
    /** @internal */
    checkScale(val) {
        if (val > BigDecimal.MAX_INT_VALUE || val < BigDecimal.MIN_INT_VALUE) {
            val = val > BigDecimal.MAX_INT_VALUE ? BigDecimal.MAX_INT_VALUE : BigDecimal.MIN_INT_VALUE;
            if (this.intCompact !== 0 && (this.intVal === null || BigDecimal.bigIntSignum(this.intVal) !== 0))
                throw new RangeError(val > 0 ? 'Scale too high' : 'Scale too less');
        }
        return val;
    }
    /** @internal */
    static checkScale2(intCompact, val) {
        if (val > BigDecimal.MAX_INT_VALUE || val < BigDecimal.MIN_INT_VALUE) {
            val = (val > BigDecimal.MAX_INT_VALUE) ? BigDecimal.MAX_INT_VALUE : BigDecimal.MIN_INT_VALUE;
            if (intCompact !== 0) {
                throw new RangeError(val > 0 ? 'Scale too high' : 'Scale too less');
            }
        }
        return val;
    }
    /** @internal */
    static checkScale3(intVal, val) {
        if (val > BigDecimal.MAX_INT_VALUE || val < BigDecimal.MIN_INT_VALUE) {
            val = (val > BigDecimal.MAX_INT_VALUE) ? BigDecimal.MAX_INT_VALUE : BigDecimal.MIN_INT_VALUE;
            if (intVal !== BigDecimal.zeroBigInt) {
                throw new RangeError(val > 0 ? 'Scale too high' : 'Scale too less');
            }
        }
        return val;
    }
    /**
     * the same as checkScale where value!=0
     * @internal
     */
    static checkScaleNonZero(val) {
        if (val > BigDecimal.MAX_INT_VALUE || val < BigDecimal.MIN_INT_VALUE) {
            throw new RangeError(val > 0 ? 'Scale too high' : 'Scale too less');
        }
        return val;
    }
    /**
     * Divides `BigInt` value by ten power.
     * @internal
     */
    static divideAndRoundByTenPow(intVal, tenPow, roundingMode) {
        if (tenPow < BigDecimal.TEN_POWERS_TABLE.length)
            intVal = BigDecimal.divideAndRound5(intVal, BigDecimal.TEN_POWERS_TABLE[tenPow], roundingMode);
        else
            intVal = BigDecimal.divideAndRound6(intVal, BigInt(10) ** BigInt(tenPow), roundingMode);
        return intVal;
    }
    /**
     * Divides `number by `number and do rounding based on the
     * passed in roundingMode.
     * @internal
     */
    static divideAndRound(ldividend, ldivisor, roundingMode) {
        const q = Math.trunc(ldividend / ldivisor);
        if (roundingMode === RoundingMode.DOWN)
            return q;
        const r = ldividend % ldivisor;
        const qsign = ((ldividend < 0) === (ldivisor < 0)) ? 1 : -1;
        if (r !== 0) {
            const increment = BigDecimal.needIncrement(ldivisor, roundingMode, qsign, q, r);
            return increment ? q + qsign : q;
        }
        else {
            return q;
        }
    }
    /**
     * Compute this * 10 ^ n.
     * Needed mainly to allow special casing to trap zero value
     * @internal
     */
    bigMultiplyPowerTen(n) {
        if (n <= 0)
            return this.inflated();
        if (this.intCompact !== BigDecimal.INFLATED)
            return BigInt(10) ** BigInt(n) * BigInt(this.intCompact);
        else
            return this.intVal.valueOf() * BigInt(10) ** BigInt(n);
    }
    /** @internal */
    static bigMultiplyPowerTen2(value, n) {
        if (n <= 0)
            return BigInt(value);
        return BigInt(10) ** BigInt(n) * BigInt(value);
    }
    /** @internal */
    static bigMultiplyPowerTen3(value, n) {
        if (n <= 0)
            return value;
        if (n < BigDecimal.TEN_POWERS_TABLE.length) {
            return value.valueOf() * BigInt(BigDecimal.TEN_POWERS_TABLE[n]);
        }
        return BigInt(10) ** BigInt(n) * value.valueOf();
    }
    /** @internal */
    static zeroValueOf(scale) {
        if (scale >= 0 && scale < BigDecimal.ZERO_SCALED_BY.length)
            return BigDecimal.ZERO_SCALED_BY[scale];
        else
            return new BigDecimal(BigDecimal.zeroBigInt, 0, scale, 1);
    }
    precision() {
        let result = this._precision;
        if (result === 0) {
            const s = this.intCompact;
            if (s !== BigDecimal.INFLATED)
                result = BigDecimal.integerDigitLength(s);
            else
                result = BigDecimal.bigDigitLength(this.intVal);
            this._precision = result;
        }
        return result;
    }
    /**
     * Returns a `BigDecimal` rounded according to the MathContext
     * settings;
     * If rounding is needed a new `BigDecimal` is created and returned.
     *
     * @param val the value to be rounded
     * @param mc  the context to use.
     * @return a `BigDecimal` rounded according to the MathContext
     * settings.  May return `value`, if no rounding needed.
     * @throws RangeError if the rounding mode is
     *                             `RoundingMode.UNNECESSARY` and the
     *                             result is inexact.
     * @internal
     */
    static doRound(val, mc) {
        const mcp = mc.precision;
        let wasDivided = false;
        if (mcp > 0) {
            let intVal = val.intVal;
            let compactVal = val.intCompact;
            let scale = val._scale;
            let prec = val.precision();
            const mode = mc.roundingMode;
            let drop;
            if (compactVal === BigDecimal.INFLATED) {
                drop = prec - mcp;
                while (drop > 0) {
                    scale = BigDecimal.checkScaleNonZero(scale - drop);
                    intVal = BigDecimal.divideAndRoundByTenPow(intVal, drop, mode);
                    wasDivided = true;
                    compactVal = BigDecimal.compactValFor(intVal);
                    if (compactVal !== BigDecimal.INFLATED) {
                        prec = BigDecimal.integerDigitLength(compactVal);
                        break;
                    }
                    prec = BigDecimal.bigDigitLength(intVal);
                    drop = prec - mcp;
                }
            }
            if (compactVal !== BigDecimal.INFLATED) {
                drop = prec - mcp; // drop can't be more than 15
                while (drop > 0) {
                    scale = BigDecimal.checkScaleNonZero(scale - drop);
                    compactVal = BigDecimal.divideAndRound(compactVal, BigDecimal.TEN_POWERS_TABLE[drop], mc.roundingMode);
                    wasDivided = true;
                    prec = BigDecimal.integerDigitLength(compactVal);
                    drop = prec - mcp;
                    intVal = null;
                }
            }
            return wasDivided ? new BigDecimal(intVal, compactVal, scale, prec) : val;
        }
        return val;
    }
    /**
     * Returns length of a bigint
     * @internal
     */
    static bigDigitLength(b) {
        if (b < BigDecimal.zeroBigInt)
            b = b.valueOf() * BigDecimal.minusOneBigInt;
        return b.toString().length;
    }
    /**
     * Returns a `BigDecimal` created from `BigInt` value with
     * given scale rounded according to the MathContext settings
     * @internal
     */
    static doRound2(intVal, scale, mc) {
        const mcp = mc.precision;
        let prec = 0;
        if (mcp > 0) {
            let compactVal = BigDecimal.compactValFor(intVal);
            const mode = mc.roundingMode;
            let drop;
            if (compactVal === BigDecimal.INFLATED) {
                prec = BigDecimal.bigDigitLength(intVal);
                drop = prec - mcp;
                while (drop > 0) {
                    scale = BigDecimal.checkScaleNonZero(scale - drop);
                    intVal = BigDecimal.divideAndRoundByTenPow(intVal, drop, mode);
                    compactVal = BigDecimal.compactValFor(intVal);
                    if (compactVal !== BigDecimal.INFLATED) {
                        break;
                    }
                    prec = BigDecimal.bigDigitLength(intVal);
                    drop = prec - mcp;
                }
            }
            if (compactVal !== BigDecimal.INFLATED) {
                prec = BigDecimal.integerDigitLength(compactVal);
                drop = prec - mcp; // drop can't be more than 18
                while (drop > 0) {
                    scale = BigDecimal.checkScaleNonZero(scale - drop);
                    compactVal = BigDecimal.divideAndRound(compactVal, BigDecimal.TEN_POWERS_TABLE[drop], mc.roundingMode);
                    prec = BigDecimal.integerDigitLength(compactVal);
                    drop = prec - mcp;
                }
                return BigDecimal.fromInteger2(compactVal, scale, prec);
            }
        }
        return new BigDecimal(intVal, BigDecimal.INFLATED, scale, prec);
    }
    /**
     * Returns a `BigDecimal` created from `number` value with
     * given scale rounded according to the MathContext settings
     * @internal
     */
    static doRound3(compactVal, scale, mc) {
        const mcp = mc.precision;
        if (mcp > 0 && mcp < 16) {
            let prec = BigDecimal.integerDigitLength(compactVal);
            let drop = prec - mcp; // drop can't be more than 15
            while (drop > 0) {
                scale = BigDecimal.checkScaleNonZero(scale - drop);
                compactVal = BigDecimal.divideAndRound(compactVal, BigDecimal.TEN_POWERS_TABLE[drop], mc.roundingMode);
                prec = BigDecimal.integerDigitLength(compactVal);
                drop = prec - mcp;
            }
            return BigDecimal.fromInteger2(compactVal, scale, prec);
        }
        return BigDecimal.fromInteger3(compactVal, scale);
    }
    /** @internal */
    static stripZerosToMatchScale(intVal, intCompact, scale, preferredScale) {
        if (intCompact !== BigDecimal.INFLATED) {
            return BigDecimal.createAndStripZerosToMatchScale(intCompact, scale, preferredScale);
        }
        else {
            return BigDecimal.createAndStripZerosToMatchScale2(intVal === null ? BigDecimal.INFLATED_BIGINT : intVal.valueOf(), scale, preferredScale);
        }
    }
    /**
     * Remove insignificant trailing zeros from this
     * value until the preferred scale is reached or no
     * more zeros can be removed. If the preferred scale is less than
     * BigDecimal.MIN_INT_VALUE, all the trailing zeros will be removed.
     *
     * @return new `BigDecimal` with a scale possibly reduced
     * to be closed to the preferred scale.
     * @throws RangeError if scale overflows.
     * @internal
     */
    static createAndStripZerosToMatchScale(compactVal, scale, preferredScale) {
        while (Math.abs(compactVal) >= 10 && scale > preferredScale) {
            if ((compactVal & 1) !== 0)
                break;
            const r = compactVal % 10;
            if (r !== 0)
                break;
            compactVal /= 10;
            scale = this.checkScale2(compactVal, scale - 1);
        }
        return BigDecimal.fromInteger3(compactVal, scale);
    }
    /**
     * Remove insignificant trailing zeros from this
     * bigint value until the preferred scale is reached or no
     * more zeros can be removed. If the preferred scale is less than
     * BigDecimal.MIN_INT_VALUE, all the trailing zeros will be removed.
     *
     * @return new `BigDecimal` with a scale possibly reduced
     * to be closed to the preferred scale.
     * @throws RangeError if scale overflows.
     * @internal
     */
    static createAndStripZerosToMatchScale2(intVal, scale, preferredScale) {
        let qr;
        while (BigDecimal.bigIntCompareMagnitude(intVal, BigInt(10)) >= 0 && scale > preferredScale) {
            if (intVal.valueOf() % BigDecimal.twoBigInt === BigDecimal.oneBigInt)
                break;
            qr = [intVal.valueOf() / BigInt(10), intVal.valueOf() % BigInt(10)];
            if (BigDecimal.bigIntSignum(qr[1]) !== 0)
                break;
            intVal = qr[0];
            scale = this.checkScale3(intVal, scale - 1);
        }
        return BigDecimal.fromBigInt5(intVal, scale, 0);
    }
    /**
     * Match the scales of two `BigDecimal`s to align their
     * least significant digits.
     *
     * If the scales of val[0] and val[1] differ, rescale
     * (non-destructively) the lower-scaled `BigDecimal` so
     * they match.  That is, the lower-scaled reference will be
     * replaced by a reference to a new object with the same scale as
     * the other `BigDecimal`.
     *
     * @param val array of two elements referring to the two
     *            `BigDecimal`s to be aligned.
     * @internal
     */
    static matchScale(val) {
        if (val[0]._scale < val[1]._scale) {
            val[0] = val[0].setScale(val[1]._scale, RoundingMode.UNNECESSARY);
        }
        else if (val[1]._scale < val[0]._scale) {
            val[1] = val[1].setScale(val[0]._scale, RoundingMode.UNNECESSARY);
        }
    }
    /**
     * Returns an array of length two, the sum of whose entries is
     * equal to the rounded sum of the `BigDecimal` arguments.
     *
     * If the digit positions of the arguments have a sufficient
     * gap between them, the value smaller in magnitude can be
     * condensed into a "sticky bit" and the end result will
     * round the same way <em>if</em> the precision of the final
     * result does not include the high order digit of the small
     * magnitude operand.
     *
     * Note that while strictly speaking this is an optimization,
     * it makes a much wider range of additions practical.
     *
     * This corresponds to a pre-shift operation in a fixed
     * precision floating-point adder; this method is complicated by
     * variable precision of the result as determined by the
     * MathContext.  A more nuanced operation could implement a
     * "right shift" on the smaller magnitude operand so
     * that the number of digits of the smaller operand could be
     * reduced even though the significands partially overlapped.
     * @internal
     */
    preAlign(augend, padding, mc) {
        let big;
        let small;
        if (padding < 0) {
            big = this;
            small = augend;
        }
        else {
            big = augend;
            small = this;
        }
        const estResultUlpScale = big._scale - big.precision() + mc.precision;
        const smallHighDigitPos = small._scale - small.precision() + 1;
        if (smallHighDigitPos > big._scale + 2 &&
            smallHighDigitPos > estResultUlpScale + 2) {
            small = BigDecimal.fromInteger3(small.signum(), this.checkScale(Math.max(big._scale, estResultUlpScale) + 3));
        }
        return [big, small];
    }
    /**
     * Returns a `BigDecimal` whose value is `(-this)`,
     * with rounding according to the context settings.
     *
     * @param mc the context to use.
     * @return `-this`, rounded as necessary.
     */
    negate(mc) {
        let result = this.intCompact === BigDecimal.INFLATED ?
            new BigDecimal(BigDecimal.minusOneBigInt * this.intVal.valueOf(), BigDecimal.INFLATED, this._scale, this._precision) :
            BigDecimal.fromInteger2(-this.intCompact, this._scale, this._precision);
        if (mc) {
            result = result.plus(mc);
        }
        return result;
    }
    /**
     * Returns a `BigDecimal` whose value is `(this + augend)`,
     * with rounding according to the context settings.
     *
     * If either number is zero and the precision setting is nonzero then
     * the other number, rounded if necessary, is used as the result.
     *
     * @param augend value to be added to this `BigDecimal`. This value will
     * be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return `this + augend`, rounded as necessary.
     */
    add(augend, mc) {
        augend = BigDecimal.convertToBigDecimal(augend);
        if (!mc || (mc && mc.precision === 0)) {
            if (this.intCompact !== BigDecimal.INFLATED) {
                if (augend.intCompact !== BigDecimal.INFLATED) {
                    return BigDecimal.add3(this.intCompact, this._scale, augend.intCompact, augend._scale);
                }
                else {
                    return BigDecimal.add2(this.intCompact, this._scale, augend.intVal, augend._scale);
                }
            }
            else {
                if (augend.intCompact !== BigDecimal.INFLATED) {
                    return BigDecimal.add2(augend.intCompact, augend._scale, this.intVal, this._scale);
                }
                else {
                    return BigDecimal.add1(this.intVal, this._scale, augend.intVal, augend._scale);
                }
            }
        }
        // If either number is zero then the other number, rounded and
        // scaled if necessary, is used as the result.
        let lhs = this;
        const lhsIsZero = lhs.signum() === 0;
        const augendIsZero = augend.signum() === 0;
        if (lhsIsZero || augendIsZero) {
            const preferredScale = Math.max(lhs._scale, augend._scale);
            if (lhsIsZero && augendIsZero)
                return BigDecimal.zeroValueOf(preferredScale);
            const result = lhsIsZero ? BigDecimal.doRound(augend, mc) : BigDecimal.doRound(lhs, mc);
            if (result._scale === preferredScale)
                return result;
            else if (result._scale > preferredScale) {
                return BigDecimal.stripZerosToMatchScale(result.intVal, result.intCompact, result._scale, preferredScale);
            }
            else { // result.scale < preferredScale
                const precisionDiff = mc.precision - result.precision();
                const scaleDiff = preferredScale - result._scale;
                if (precisionDiff >= scaleDiff)
                    return result.setScale(preferredScale); // can achieve target scale
                else
                    return result.setScale(result._scale + precisionDiff);
            }
        }
        const padding = lhs._scale - augend._scale;
        if (padding !== 0) { // scales differ; alignment needed
            const arg = this.preAlign(augend, padding, mc);
            BigDecimal.matchScale(arg);
            lhs = arg[0];
            augend = arg[1];
        }
        return BigDecimal.doRound2(lhs.inflated().valueOf() + augend.inflated().valueOf(), lhs._scale, mc);
    }
    /**
     * Returns a `BigDecimal` whose value is `(this - subtrahend)`,
     * with rounding according to the context settings.
     *
     * If `subtrahend` is zero then this, rounded if necessary, is used as the
     * result.  If this is zero then the result is `subtrahend.negate(mc)`.
     *
     * @param subtrahend value to be subtracted from this `BigDecimal`. This value
     * will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return `this - subtrahend`, rounded as necessary.
     */
    subtract(subtrahend, mc) {
        subtrahend = BigDecimal.convertToBigDecimal(subtrahend);
        if (!mc || (mc && mc.precision === 0)) {
            if (this.intCompact !== BigDecimal.INFLATED) {
                if ((subtrahend.intCompact !== BigDecimal.INFLATED)) {
                    return BigDecimal.add3(this.intCompact, this._scale, -subtrahend.intCompact, subtrahend._scale);
                }
                else {
                    return BigDecimal.add2(this.intCompact, this._scale, BigDecimal.minusOneBigInt * subtrahend.intVal.valueOf(), subtrahend._scale);
                }
            }
            else {
                if ((subtrahend.intCompact !== BigDecimal.INFLATED)) {
                    // Pair of subtrahend values given before pair of
                    // values from this BigDecimal to avoid need for
                    // method overloading on the specialized add method
                    return BigDecimal.add2(-subtrahend.intCompact, subtrahend._scale, this.intVal, this._scale);
                }
                else {
                    return BigDecimal.add1(this.intVal, this._scale, BigDecimal.minusOneBigInt * subtrahend.intVal.valueOf(), subtrahend._scale);
                }
            }
        }
        // share the special rounding code in add()
        return this.add(subtrahend.negate(), mc);
    }
    /**
     * Returns a `BigDecimal` whose value is <code>(this &times;
     * multiplicand)</code>, with rounding according to the context settings.
     *
     * @param multiplicand value to be multiplied by this `BigDecimal`. This
     * value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return `this * multiplicand`, rounded as necessary.
     */
    multiply(multiplicand, mc) {
        multiplicand = BigDecimal.convertToBigDecimal(multiplicand);
        if (!mc || (mc && mc.precision === 0)) {
            const productScale = this.checkScale(this._scale + multiplicand._scale);
            if (this.intCompact !== BigDecimal.INFLATED) {
                if ((multiplicand.intCompact !== BigDecimal.INFLATED)) {
                    return BigDecimal.multiply2(this.intCompact, multiplicand.intCompact, productScale);
                }
                else {
                    return BigDecimal.multiply3(this.intCompact, multiplicand.intVal, productScale);
                }
            }
            else {
                if ((multiplicand.intCompact !== BigDecimal.INFLATED)) {
                    return BigDecimal.multiply3(multiplicand.intCompact, this.intVal, productScale);
                }
                else {
                    return BigDecimal.multiply4(this.intVal, multiplicand.intVal, productScale);
                }
            }
        }
        const productScale = this.checkScale(this._scale + multiplicand._scale);
        if (this.intCompact !== BigDecimal.INFLATED) {
            if ((multiplicand.intCompact !== BigDecimal.INFLATED)) {
                return BigDecimal.multiplyAndRound1(this.intCompact, multiplicand.intCompact, productScale, mc);
            }
            else {
                return BigDecimal.multiplyAndRound2(this.intCompact, multiplicand.intVal, productScale, mc);
            }
        }
        else {
            if ((multiplicand.intCompact !== BigDecimal.INFLATED)) {
                return BigDecimal.multiplyAndRound2(multiplicand.intCompact, this.intVal, productScale, mc);
            }
            else {
                return BigDecimal.multiplyAndRound3(this.intVal, multiplicand.intVal, productScale, mc);
            }
        }
    }
    /**
     * Returns a `BigDecimal` whose value is `(this / divisor)`,
     * and whose scale is as specified.  If rounding must
     * be performed to generate a result with the specified scale, the
     * specified rounding mode is applied.
     *
     * @param divisor value by which this `BigDecimal` is to be divided.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param scale scale of the `BigDecimal` quotient to be returned.
     * @param roundingMode rounding mode to apply.
     * @return `this / divisor`
     * @throws RangeError
     * * If `divisor` is zero
     * * If `roundingMode==RoundingMode.UNNECESSARY` and the specified scale is insufficient to represent the result
     *   of the division exactly.
     * * If scale is given but rounding mode is not given.
     */
    divide(divisor, scale, roundingMode) {
        divisor = BigDecimal.convertToBigDecimal(divisor);
        /*
         * Handle zero cases first.
         */
        if (divisor.signum() === 0) {
            if (this.signum() === 0)
                throw new RangeError('Division undefined');
            throw new RangeError('Division by zero');
        }
        if (roundingMode === undefined) {
            if (scale !== undefined) {
                throw new RangeError('Rounding mode is necessary if scale is given.');
            }
            else {
                return this.divide6(divisor);
            }
        }
        else {
            if (scale === undefined) {
                scale = this._scale;
            }
            if (roundingMode < RoundingMode.UP || roundingMode > RoundingMode.UNNECESSARY)
                throw new RangeError('Invalid rounding mode');
            if (this.intCompact !== BigDecimal.INFLATED) {
                if ((divisor.intCompact !== BigDecimal.INFLATED)) {
                    return BigDecimal.divide7(this.intCompact, this._scale, divisor.intCompact, divisor._scale, scale, roundingMode);
                }
                else {
                    return BigDecimal.divide8(this.intCompact, this._scale, divisor.intVal, divisor._scale, scale, roundingMode);
                }
            }
            else {
                if ((divisor.intCompact !== BigDecimal.INFLATED)) {
                    return BigDecimal.divide9(this.intVal, this._scale, divisor.intCompact, divisor._scale, scale, roundingMode);
                }
                else {
                    return BigDecimal.divide10(this.intVal, this._scale, divisor.intVal, divisor._scale, scale, roundingMode);
                }
            }
        }
    }
    /** @internal */
    static saturateScale(scale) {
        if (scale <= BigDecimal.MAX_INT_VALUE && scale >= BigDecimal.MIN_INT_VALUE) {
            return scale;
        }
        else {
            return (scale < 0 ? BigDecimal.MIN_INT_VALUE : BigDecimal.MAX_INT_VALUE);
        }
    }
    /** @internal */
    divide6(divisor) {
        // Calculate preferred scale
        const preferredScale = BigDecimal.saturateScale(this._scale - divisor._scale);
        if (this.signum() === 0) // 0/y
            return BigDecimal.zeroValueOf(preferredScale);
        else {
            /*
             * If the quotient this/divisor has a terminating decimal
             * expansion, the expansion can have no more than
             * (a.precision() + ceil(10*b.precision)/3) digits.
             * Therefore, create a MathContext object with this
             * precision and do a divide with the UNNECESSARY rounding
             * mode.
             */
            const mc = new MathContext(Math.min(this.precision() + Math.ceil(10.0 * divisor.precision() / 3.0), BigDecimal.MAX_INT_VALUE), RoundingMode.UNNECESSARY);
            let quotient;
            try {
                quotient = this.divideWithMathContext(divisor, mc);
            }
            catch (e) {
                throw new RangeError('Non-terminating decimal expansion; ' +
                    'no exact representable decimal result.');
            }
            const quotientScale = quotient.scale();
            // divide(BigDecimal, mc) tries to adjust the quotient to
            // the desired one by removing trailing zeros; since the
            // exact divide method does not have an explicit digit
            // limit, we can add zeros too.
            if (preferredScale > quotientScale)
                return quotient.setScale(preferredScale, RoundingMode.UNNECESSARY);
            return quotient;
        }
    }
    /**
     * Returns a `BigDecimal` whose value is `(this /
     * divisor)`, with rounding according to the context settings.
     *
     * @param divisor value by which this `BigDecimal` is to be divided.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @throws RangeError if the exact quotient does not have a
     *         terminating decimal expansion, including dividing by zero
     * @return `this / divisor`
     */
    divideWithMathContext(divisor, mc) {
        divisor = BigDecimal.convertToBigDecimal(divisor);
        if (divisor.signum() === 0) { // x/0
            if (this.signum() === 0) // 0/0
                throw new RangeError('Division undefined'); // NaN
            throw new RangeError('Division by zero');
        }
        if (!mc || (mc && mc.precision === 0)) {
            const preferredScale = BigDecimal.saturateScale(this._scale - divisor._scale);
            if (this.signum() === 0)
                return BigDecimal.zeroValueOf(preferredScale);
            else {
                const mc = new MathContext(Math.min(this.precision() + Math.ceil(10.0 * divisor.precision() / 3.0), Number.MAX_SAFE_INTEGER), RoundingMode.UNNECESSARY);
                let quotient;
                try {
                    quotient = this.divideWithMathContext(divisor, mc);
                }
                catch (e) {
                    throw new RangeError('Non-terminating decimal expansion; no exact representable decimal result.');
                }
                const quotientScale = quotient._scale;
                if (preferredScale > quotientScale)
                    return quotient.setScale(preferredScale, RoundingMode.UNNECESSARY);
                return quotient;
            }
        }
        const preferredScale = this._scale - divisor._scale;
        // Now calculate the answer.  We use the existing
        // divide-and-round method, but as this rounds to scale we have
        // to normalize the values here to achieve the desired result.
        // For x/y we first handle y=0 and x=0, and then normalize x and
        // y to give x' and y' with the following constraints:
        //   (a) 0.1 <= x' < 1
        //   (b)  x' <= y' < 10*x'
        // Dividing x'/y' with the required scale set to mc.precision then
        // will give a result in the range 0.1 to 1 rounded to exactly
        // the right number of digits (except in the case of a result of
        // 1.000... which can arise when x=y, or when rounding overflows
        // The 1.000... case will reduce properly to 1.
        if (this.signum() === 0)
            return BigDecimal.zeroValueOf(BigDecimal.saturateScale(preferredScale));
        const xscale = this.precision();
        const yscale = divisor.precision();
        if (this.intCompact !== BigDecimal.INFLATED) {
            if (divisor.intCompact !== BigDecimal.INFLATED) {
                return BigDecimal.divide2(this.intCompact, xscale, divisor.intCompact, yscale, preferredScale, mc);
            }
            else {
                return BigDecimal.divide3(this.intCompact, xscale, divisor.intVal, yscale, preferredScale, mc);
            }
        }
        else {
            if (divisor.intCompact !== BigDecimal.INFLATED) {
                return BigDecimal.divide4(this.intVal, xscale, divisor.intCompact, yscale, preferredScale, mc);
            }
            else {
                return BigDecimal.divide5(this.intVal, xscale, divisor.intVal, yscale, preferredScale, mc);
            }
        }
    }
    /** @internal */
    static multiply1(x, y) {
        const product = x * y;
        if (product <= Number.MAX_SAFE_INTEGER && product > Number.MIN_SAFE_INTEGER) {
            return product;
        }
        return BigDecimal.INFLATED;
    }
    /** @internal */
    static multiply2(x, y, scale) {
        const product = BigDecimal.multiply1(x, y);
        if (product !== BigDecimal.INFLATED) {
            return BigDecimal.fromInteger3(product, scale);
        }
        return new BigDecimal(BigInt(x) * BigInt(y), BigDecimal.INFLATED, scale, 0);
    }
    /** @internal */
    static multiply3(x, y, scale) {
        if (x === 0) {
            return BigDecimal.zeroValueOf(scale);
        }
        return new BigDecimal(y.valueOf() * BigInt(x), BigDecimal.INFLATED, scale, 0);
    }
    /** @internal */
    static multiply4(x, y, scale) {
        return new BigDecimal(x.valueOf() * y.valueOf(), BigDecimal.INFLATED, scale, 0);
    }
    /**
     * Multiplies two integers and rounds according to `MathContext`
     * @internal
     */
    static multiplyAndRound1(x, y, scale, mc) {
        const product = BigDecimal.multiply1(x, y);
        if (product !== BigDecimal.INFLATED) {
            return BigDecimal.doRound3(product, scale, mc);
        }
        let rsign = 1;
        if (x < 0) {
            x = -x;
            rsign = -1;
        }
        if (y < 0) {
            y = -y;
            rsign *= -1;
        }
        const res = new BigDecimal(BigInt(x) * BigInt(y) * BigInt(rsign), BigDecimal.INFLATED, scale, 0);
        return BigDecimal.doRound(res, mc);
    }
    /** @internal */
    static multiplyAndRound2(x, y, scale, mc) {
        if (x === 0) {
            return BigDecimal.zeroValueOf(scale);
        }
        return BigDecimal.doRound2(y.valueOf() * BigInt(x), scale, mc);
    }
    /** @internal */
    static multiplyAndRound3(x, y, scale, mc) {
        return BigDecimal.doRound2(x.valueOf() * y.valueOf(), scale, mc);
    }
    /** @internal */
    static divide2(xs, xscale, ys, yscale, preferredScale, mc) {
        const mcp = mc.precision;
        if (xscale <= yscale && yscale < 15 && mcp < 15) {
            return BigDecimal.divideSmallFastPath(xs, xscale, ys, yscale, preferredScale, mc);
        }
        if (BigDecimal.compareMagnitudeNormalized(xs, xscale, ys, yscale) > 0) { // satisfy constraint (b)
            yscale -= 1; // [that is, divisor *= 10]
        }
        const roundingMode = mc.roundingMode;
        // In order to find out whether the divide generates the exact result,
        // we avoid calling the above divide method. 'quotient' holds the
        // return BigDecimal object whose scale will be set to 'scl'.
        const scl = BigDecimal.checkScaleNonZero(preferredScale + yscale - xscale + mcp);
        let quotient;
        if (BigDecimal.checkScaleNonZero(mcp + yscale - xscale) > 0) {
            const raise = BigDecimal.checkScaleNonZero(mcp + yscale - xscale);
            let scaledXs;
            if ((scaledXs = BigDecimal.integerMultiplyPowerTen(xs, raise)) === BigDecimal.INFLATED) {
                const rb = BigDecimal.bigMultiplyPowerTen2(xs, raise);
                quotient = BigDecimal.divideAndRound4(rb, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
            }
            else {
                quotient = BigDecimal.divideAndRound2(scaledXs, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
            }
        }
        else {
            const newScale = BigDecimal.checkScaleNonZero(xscale - mcp);
            if (newScale === yscale) { // easy case
                quotient = BigDecimal.divideAndRound2(xs, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
            }
            else {
                const raise = BigDecimal.checkScaleNonZero(newScale - yscale);
                let scaledYs;
                if ((scaledYs = BigDecimal.integerMultiplyPowerTen(ys, raise)) === BigDecimal.INFLATED) {
                    const rb = BigDecimal.bigMultiplyPowerTen2(ys, raise);
                    quotient = BigDecimal.divideAndRound3(BigInt(xs), rb, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                }
                else {
                    quotient = BigDecimal.divideAndRound2(xs, scaledYs, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                }
            }
        }
        // doRound, here, only affects 1000000000 case.
        return BigDecimal.doRound(quotient, mc);
    }
    /** @internal */
    static divide3(xs, xscale, ys, yscale, preferredScale, mc) {
        // Normalize dividend & divisor so that both fall into [0.1, 0.999...]
        if (BigDecimal.compareMagnitudeNormalized2(xs, xscale, ys, yscale) > 0) { // satisfy constraint (b)
            yscale -= 1; // [that is, divisor *= 10]
        }
        const mcp = mc.precision;
        const roundingMode = mc.roundingMode;
        // In order to find out whether the divide generates the exact result,
        // we avoid calling the above divide method. 'quotient' holds the
        // return BigDecimal object whose scale will be set to 'scl'.
        let quotient;
        const scl = BigDecimal.checkScaleNonZero(preferredScale + yscale - xscale + mcp);
        if (BigDecimal.checkScaleNonZero(mcp + yscale - xscale) > 0) {
            const raise = BigDecimal.checkScaleNonZero(mcp + yscale - xscale);
            const rb = BigDecimal.bigMultiplyPowerTen2(xs, raise);
            quotient = BigDecimal.divideAndRound3(rb, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
        }
        else {
            const newScale = BigDecimal.checkScaleNonZero(xscale - mcp);
            const raise = BigDecimal.checkScaleNonZero(newScale - yscale);
            const rb = BigDecimal.bigMultiplyPowerTen3(ys, raise);
            quotient = BigDecimal.divideAndRound3(BigInt(xs), rb, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
        }
        // doRound, here, only affects 1000000000 case.
        return BigDecimal.doRound(quotient, mc);
    }
    /** @internal */
    static divide4(xs, xscale, ys, yscale, preferredScale, mc) {
        // Normalize dividend & divisor so that both fall into [0.1, 0.999...]
        if ((-BigDecimal.compareMagnitudeNormalized2(ys, yscale, xs, xscale)) > 0) { // satisfy constraint (b)
            yscale -= 1; // [that is, divisor *= 10]
        }
        const mcp = mc.precision;
        const roundingMode = mc.roundingMode;
        // In order to find out whether the divide generates the exact result,
        // we avoid calling the above divide method. 'quotient' holds the
        // return BigDecimal object whose scale will be set to 'scl'.
        let quotient;
        const scl = BigDecimal.checkScaleNonZero(preferredScale + yscale - xscale + mcp);
        if (BigDecimal.checkScaleNonZero(mcp + yscale - xscale) > 0) {
            const raise = BigDecimal.checkScaleNonZero(mcp + yscale - xscale);
            const rb = BigDecimal.bigMultiplyPowerTen3(xs, raise);
            quotient = BigDecimal.divideAndRound4(rb, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
        }
        else {
            const newScale = BigDecimal.checkScaleNonZero(xscale - mcp);
            if (newScale === yscale) { // easy case
                quotient = BigDecimal.divideAndRound4(xs, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
            }
            else {
                const raise = BigDecimal.checkScaleNonZero(newScale - yscale);
                let scaledYs;
                if ((scaledYs = BigDecimal.integerMultiplyPowerTen(ys, raise)) === BigDecimal.INFLATED) {
                    const rb = BigDecimal.bigMultiplyPowerTen2(ys, raise);
                    quotient = BigDecimal.divideAndRound3(xs, rb, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                }
                else {
                    quotient = BigDecimal.divideAndRound4(xs, scaledYs, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                }
            }
        }
        // doRound, here, only affects 1000000000 case.
        return BigDecimal.doRound(quotient, mc);
    }
    /** @internal */
    static divide5(xs, xscale, ys, yscale, preferredScale, mc) {
        // Normalize dividend & divisor so that both fall into [0.1, 0.999...]
        if (BigDecimal.compareMagnitudeNormalized3(xs, xscale, ys, yscale) > 0) { // satisfy constraint (b)
            yscale -= 1; // [that is, divisor *= 10]
        }
        const mcp = mc.precision;
        const roundingMode = mc.roundingMode;
        // In order to find out whether the divide generates the exact result,
        // we avoid calling the above divide method. 'quotient' holds the
        // return BigDecimal object whose scale will be set to 'scl'.
        let quotient;
        const scl = BigDecimal.checkScaleNonZero(preferredScale + yscale - xscale + mcp);
        if (BigDecimal.checkScaleNonZero(mcp + yscale - xscale) > 0) {
            const raise = BigDecimal.checkScaleNonZero(mcp + yscale - xscale);
            const rb = BigDecimal.bigMultiplyPowerTen3(xs, raise);
            quotient = BigDecimal.divideAndRound3(rb, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
        }
        else {
            const newScale = BigDecimal.checkScaleNonZero(xscale - mcp);
            const raise = BigDecimal.checkScaleNonZero(newScale - yscale);
            const rb = BigDecimal.bigMultiplyPowerTen3(ys, raise);
            quotient = BigDecimal.divideAndRound3(xs, rb, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
        }
        // doRound, here, only affects 1000000000 case.
        return BigDecimal.doRound(quotient, mc);
    }
    /**
     * Returns a `BigDecimal` whose value is the integer part
     * of `(this / divisor)`.  Since the integer part of the
     * exact quotient does not depend on the rounding mode, the
     * rounding mode does not affect the values returned by this
     * method.  The preferred scale of the result is
     * `(this.scale() - divisor.scale())`. A
     * `RangeError` is thrown if the integer part of
     * the exact quotient needs more than `mc.precision`
     * digits.
     *
     * @param divisor value by which this `BigDecimal` is to be divided.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return The integer part of `this / divisor`.
     * @throws RangeError if divisor is 0
     * @throws RangeError if `mc.precision > 0` and the result
     *         requires a precision of more than `mc.precision` digits.
     */
    divideToIntegralValue(divisor, mc) {
        divisor = BigDecimal.convertToBigDecimal(divisor);
        if (!mc || (mc && (mc.precision === 0 || this.compareMagnitude(divisor) < 0))) {
            // Calculate preferred scale
            const preferredScale = BigDecimal.saturateScale(this._scale - divisor._scale);
            if (this.compareMagnitude(divisor) < 0) {
                // much faster when this << divisor
                return BigDecimal.zeroValueOf(preferredScale);
            }
            if (this.signum() === 0 && divisor.signum() !== 0)
                return this.setScale(preferredScale, RoundingMode.UNNECESSARY);
            // Perform a divide with enough digits to round to a correct
            // integer value; then remove any fractional digits
            const maxDigits = Math.min(this.precision() + Math.ceil(10.0 * divisor.precision() / 3.0) + Math.abs(this._scale - divisor._scale) + 2, Number.MAX_SAFE_INTEGER);
            let quotient = this.divideWithMathContext(divisor, new MathContext(maxDigits, RoundingMode.DOWN));
            if (quotient._scale > 0) {
                quotient = quotient.setScale(0, RoundingMode.DOWN);
                quotient = BigDecimal.stripZerosToMatchScale(quotient.intVal, quotient.intCompact, quotient._scale, preferredScale);
            }
            if (quotient._scale < preferredScale) {
                // pad with zeros if necessary
                quotient = quotient.setScale(preferredScale, RoundingMode.UNNECESSARY);
            }
            return quotient;
        }
        // Calculate preferred scale
        const preferredScale = BigDecimal.saturateScale(this._scale - divisor._scale);
        /*
         * Perform a normal divide to mc.precision digits.  If the
         * remainder has absolute value less than the divisor, the
         * integer portion of the quotient fits into mc.precision
         * digits.  Next, remove any fractional digits from the
         * quotient and adjust the scale to the preferred value.
         */
        let result = this.divideWithMathContext(divisor, new MathContext(mc.precision, RoundingMode.DOWN));
        if (result._scale < 0) {
            /*
             * Result is an integer. See if quotient represents the
             * full integer portion of the exact quotient; if it does,
             * the computed remainder will be less than the divisor.
             */
            const product = result.multiply(divisor);
            // If the quotient is the full integer value,
            // |dividend-product| < |divisor|.
            if (this.subtract(product).compareMagnitude(divisor) >= 0) {
                throw new RangeError('Division impossible');
            }
        }
        else if (result._scale > 0) {
            /*
             * Integer portion of quotient will fit into precision
             * digits; recompute quotient to scale 0 to avoid double
             * rounding and then try to adjust, if necessary.
             */
            result = result.setScale(0, RoundingMode.DOWN);
        }
        // else result.scale() == 0;
        let precisionDiff;
        if ((preferredScale > result._scale) &&
            (precisionDiff = mc.precision - result.precision()) > 0) {
            return result.setScale(result._scale + Math.min(precisionDiff, preferredScale - result._scale));
        }
        else {
            return BigDecimal.stripZerosToMatchScale(result.intVal, result.intCompact, result._scale, preferredScale);
        }
    }
    /**
     * Returns a `BigDecimal` whose value is `(this % divisor)`, with rounding according to the context settings.
     * The `MathContext` settings affect the implicit divide
     * used to compute the remainder.  The remainder computation
     * itself is by definition exact.  Therefore, the remainder may
     * contain more than `mc.getPrecision()` digits.
     *
     * The remainder is given by
     * `this.subtract(this.divideToIntegralValue(divisor,
     * mc).multiply(divisor))`.  Note that this is not the modulo
     * operation (the result can be negative).
     *
     * @param divisor value by which this `BigDecimal` is to be divided.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return `this % divisor`, rounded as necessary.
     * @throws RangeError if divisor is 0
     * @throws RangeError if the result is inexact but the
     *         rounding mode is `UNNECESSARY`, or `mc.precision`
     *         > 0 and the result of `this.divideToIntegralValue(divisor)` would
     *         require a precision of more than `mc.precision` digits.
     * @see    {@link divideToIntegralValue}
     */
    remainder(divisor, mc) {
        return this.divideAndRemainder(divisor, mc)[1];
    }
    /**
     * Version of compareTo that ignores sign.
     * @internal
     */
    compareMagnitude(val) {
        // Match scales, avoid unnecessary inflation
        let ys = val.intCompact;
        let xs = this.intCompact;
        if (xs === 0)
            return (ys === 0) ? 0 : -1;
        if (ys === 0)
            return 1;
        const sdiff = this._scale - val._scale;
        if (sdiff !== 0) {
            // Avoid matching scales if the (adjusted) exponents differ
            const xae = this.precision() - this._scale; // [-1]
            const yae = val.precision() - val._scale; // [-1]
            if (xae < yae)
                return -1;
            if (xae > yae)
                return 1;
            if (sdiff < 0) {
                // The cases sdiff <= BigDecimal.MIN_INT_VALUE intentionally fall through.
                if (sdiff > Number.MIN_SAFE_INTEGER &&
                    (xs === BigDecimal.INFLATED ||
                        (xs = BigDecimal.integerMultiplyPowerTen(xs, -sdiff)) === BigDecimal.INFLATED) &&
                    ys === BigDecimal.INFLATED) {
                    const rb = this.bigMultiplyPowerTen(-sdiff);
                    return BigDecimal.bigIntCompareMagnitude(rb, val.intVal);
                }
            }
            else { // sdiff > 0
                // The cases sdiff > Integer.MAX_INT_VALUE intentionally fall through.
                if (sdiff <= Number.MAX_SAFE_INTEGER &&
                    (ys === BigDecimal.INFLATED ||
                        (ys = BigDecimal.integerMultiplyPowerTen(ys, sdiff)) === BigDecimal.INFLATED) &&
                    xs === BigDecimal.INFLATED) {
                    const rb = val.bigMultiplyPowerTen(sdiff);
                    return BigDecimal.bigIntCompareMagnitude(this.intVal, rb);
                }
            }
        }
        if (xs !== BigDecimal.INFLATED)
            return (ys !== BigDecimal.INFLATED) ? BigDecimal.integerCompareMagnitude(xs, ys) : -1;
        else if (ys !== BigDecimal.INFLATED)
            return 1;
        else
            return BigDecimal.bigIntCompareMagnitude(this.intVal, val.intVal);
    }
    /**
     * Compares this `BigDecimal` with the specified
     * object for equality.  Unlike {@link compareTo},
     * this method considers two `BigDecimal`
     * objects equal only if they are equal in value and
     * scale. Therefore 2.0 is not equal to 2.00 when compared by this
     * method since the former has [`BigInt`, `scale`]
     * components equal to [20, 1] while the latter has components
     * equal to [200, 2].
     *
     * One example that shows how 2.0 and 2.00 are **not**
     * substitutable for each other under some arithmetic operations
     * are the two expressions:
     *
     * ```
     * Big("2.0" ).divide(Big(3), undefined, HALF_UP) // which evaluates to 0.7
     *
     * Big("2.00").divide(Big(3), undefined, HALF_UP) // which evaluates to 0.67.
     *```
     *
     * @param value to which this `BigDecimal` is
     *         to be compared.
     * @return true if and only if the specified value is a
     *         BigDecimal whose value and scale are equal to this
     *         BigDecimal's.
     * @see    {@link compareTo}
     */
    equals(value) {
        if (!(value instanceof BigDecimal))
            return false;
        if (value === this)
            return true;
        if (this._scale !== value._scale)
            return false;
        const s = this.intCompact;
        let xs = value.intCompact;
        if (s !== BigDecimal.INFLATED) {
            if (xs === BigDecimal.INFLATED)
                xs = BigDecimal.compactValFor(value.intVal);
            return xs === s;
        }
        else if (xs !== BigDecimal.INFLATED)
            return xs === BigDecimal.compactValFor(this.intVal);
        return this.inflated() === value.inflated();
    }
    /**
     * Returns a two-element `BigDecimal` array containing the
     * result of `divideToIntegralValue` followed by the result of
     * `remainder` on the two operands calculated with rounding
     * according to the context settings.
     *
     * Note that if both the quotient and remainder are
     * needed, this method is faster than using the
     * `divideToIntegralValue` and `remainder` methods
     * separately because the division need only be carried out once.
     *
     * @param divisor value by which this `BigDecimal` is to be divided,
     *         and the remainder computed. This value will be converted to a
     *         `BigDecimal` before the operation. See the
     *         {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return a two element `BigDecimal` array: the quotient
     *         (the result of `divideToIntegralValue`) is the
     *         initial element and the remainder is the final element.
     * @throws RangeError if divisor is 0
     * @throws RangeError if the result is inexact but the
     *         rounding mode is `UNNECESSARY`, or `mc.precision > 0`
     *         and the result of `this.divideToIntegralValue(divisor)` would
     *         require a precision of more than `mc.precision` digits.
     * @see    {@link divideToIntegralValue}
     * @see    {@link remainder}
     */
    divideAndRemainder(divisor, mc) {
        divisor = BigDecimal.convertToBigDecimal(divisor);
        const result = new Array(2);
        result[0] = this.divideToIntegralValue(divisor, mc);
        result[1] = this.subtract(result[0].multiply(divisor));
        return result;
    }
    /**
     * Returns an approximation to the square root of `this`
     * with rounding according to the context settings.
     *
     * The preferred scale of the returned result is equal to
     * `this.scale()/2`. The value of the returned result is
     * always within one ulp of the exact decimal value for the
     * precision in question.  If the rounding mode is
     *  {@link RoundingMode.HALF_UP}, {@link RoundingMode.HALF_DOWN},
     * or {@link RoundingMode.HALF_EVEN}, the
     * result is within one half an ulp of the exact decimal value.
     *
     * @param mc the context to use.
     * @return the square root of `this`.
     * @throws RangeError if `this` is less than zero.
     * @throws RangeError if an exact result is requested
     * mc.getPrecision() is 0 and there is no finite decimal
     * expansion of the exact result
     * @throws RangeError if mc.getRoundingMode() is `RoundingMode.UNNECESSARY` and
     * the exact result cannot fit in `mc.getPrecision()`
     * digits.
     */
    sqrt(mc) {
        const signum = this.signum();
        if (signum !== 1) {
            let result = null;
            switch (signum) {
                case -1:
                    throw new RangeError('Attempted square root of negative BigDecimal');
                case 0:
                    result = BigDecimal.fromInteger3(0, Math.trunc(this._scale / 2));
                    return result;
                default:
                    throw new RangeError('Bad value from signum');
            }
        }
        else {
            /*
             * The following code draws on the algorithm presented in
             * "Properly Rounded Variable Precision Square Root," Hull and
             * Abrham, ACM Transactions on Mathematical Software, Vol 11,
             * No. 3, September 1985, Pages 229-237.
             *
             * The BigDecimal computational model differs from the one
             * presented in the paper in several ways: first BigDecimal
             * numbers aren't necessarily normalized, second many more
             * rounding modes are supported, including UNNECESSARY, and
             * exact results can be requested.
             *
             * The main steps of the algorithm below are as follows,
             * first argument reduce the value to the numerical range
             * [1, 10) using the following relations:
             *
             * x = y * 10 ^ exp
             * sqrt(x) = sqrt(y) * 10^(exp / 2) if exp is even
             * sqrt(x) = sqrt(y/10) * 10 ^((exp+1)/2) is exp is odd
             *
             * Then use Newton's iteration on the reduced value to compute
             * the numerical digits of the desired result.
             *
             * Finally, scale back to the desired exponent range and
             * perform any adjustment to get the preferred scale in the
             * representation.
             */
            // The code below favors relative simplicity over checking
            // for special cases that could run faster.
            const preferredScale = Math.trunc(this._scale / 2);
            const zeroWithFinalPreferredScale = BigDecimal.fromInteger3(0, preferredScale);
            // First phase of numerical normalization, strip trailing
            // zeros and check for even powers of 10.
            const stripped = this.stripTrailingZeros();
            const strippedScale = stripped._scale;
            // Numerically sqrt(10^2N) = 10^N
            if (stripped.isPowerOfTen() && strippedScale % 2 === 0) {
                let result = BigDecimal.fromInteger3(1, Math.trunc(strippedScale / 2));
                if (result._scale !== preferredScale) {
                    // Adjust to requested precision and preferred
                    // scale as appropriate.
                    result = result.add(zeroWithFinalPreferredScale, mc);
                }
                return result;
            }
            // After stripTrailingZeros, the representation is normalized as
            //
            // unscaledValue * 10^(-scale)
            //
            // where unscaledValue is an integer with the mimimum
            // precision for the cohort of the numerical value. To
            // allow binary floating-point hardware to be used to get
            // approximately a 15 digit approximation to the square
            // root, it is helpful to instead normalize this so that
            // the significand portion is to right of the decimal
            // point by roughly (scale() - precision() + 1).
            // Now the precision / scale adjustment
            let scaleAdjust;
            const scale = stripped._scale - stripped.precision() + 1;
            if (scale % 2 === 0) {
                scaleAdjust = scale;
            }
            else {
                scaleAdjust = scale - 1;
            }
            const working = stripped.scaleByPowerOfTen(scaleAdjust);
            // Use good ole' Math.sqrt to get the initial guess for
            // the Newton iteration, good to at least 15 decimal
            // digits. This approach does incur the cost of a
            //
            // BigDecimal -> double -> BigDecimal
            //
            // conversion cycle, but it avoids the need for several
            // Newton iterations in BigDecimal arithmetic to get the
            // working answer to 15 digits of precision. If many fewer
            // than 15 digits were needed, it might be faster to do
            // the loop entirely in BigDecimal arithmetic.
            //
            // (A double value might have as many as 17 decimal
            // digits of precision; it depends on the relative density
            // of binary and decimal numbers at different regions of
            // the number line.)
            //
            // (It would be possible to check for certain special
            // cases to avoid doing any Newton iterations. For
            // example, if the BigDecimal -> double conversion was
            // known to be exact and the rounding mode had a
            // low-enough precision, the post-Newton rounding logic
            // could be applied directly.)
            const guess = BigDecimal.fromValue(Math.sqrt(working.numberValue()));
            let guessPrecision = 15;
            const originalPrecision = mc.precision;
            let targetPrecision;
            // If an exact value is requested, it must only need about
            // half of the input digits to represent since multiplying
            // an N digit number by itself yield a 2N-1 digit or 2N
            // digit result.
            if (originalPrecision === 0) {
                targetPrecision = Math.trunc(stripped.precision() / 2) + 1;
            }
            else {
                /*
                 * To avoid the need for post-Newton fix-up logic, in
                 * the case of half-way rounding modes, double the
                 * target precision so that the "2p + 2" property can
                 * be relied on to accomplish the final rounding.
                 */
                switch (mc.roundingMode) {
                    case RoundingMode.HALF_UP:
                    case RoundingMode.HALF_DOWN:
                    case RoundingMode.HALF_EVEN:
                        targetPrecision = 2 * originalPrecision;
                        if (targetPrecision < 0)
                            targetPrecision = Number.MAX_SAFE_INTEGER - 2;
                        break;
                    default:
                        targetPrecision = originalPrecision;
                        break;
                }
            }
            // When setting the precision to use inside the Newton
            // iteration loop, take care to avoid the case where the
            // precision of the input exceeds the requested precision
            // and rounding the input value too soon.
            let approx = guess;
            const workingPrecision = working.precision();
            do {
                const tmpPrecision = Math.max(Math.max(guessPrecision, targetPrecision + 2), workingPrecision);
                const mcTmp = new MathContext(tmpPrecision, RoundingMode.HALF_EVEN);
                // approx = 0.5 * (approx + fraction / approx)
                approx = BigDecimal.ONE_HALF.multiply(approx.add(working.divideWithMathContext(approx, mcTmp), mcTmp));
                guessPrecision *= 2;
            } while (guessPrecision < targetPrecision + 2);
            let result;
            const targetRm = mc.roundingMode;
            if (targetRm === RoundingMode.UNNECESSARY || originalPrecision === 0) {
                const tmpRm = (targetRm === RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;
                const mcTmp = new MathContext(targetPrecision, tmpRm);
                result = approx.scaleByPowerOfTen(Math.trunc(-scaleAdjust / 2)).round(mcTmp);
                // If result*result != this numerically, the square
                // root isn't exact
                if (this.subtract(result.square()).compareTo(BigDecimal.ZERO) !== 0) {
                    throw new RangeError('Computed square root not exact.');
                }
            }
            else {
                result = approx.scaleByPowerOfTen(Math.trunc(-scaleAdjust / 2)).round(mc);
                switch (targetRm) {
                    case RoundingMode.DOWN:
                    case RoundingMode.FLOOR:
                        // Check if too big
                        if (result.square().compareTo(this) > 0) {
                            let ulp = result.ulp();
                            // Adjust increment down in case of 1.0 = 10^0
                            // since the next smaller number is only 1/10
                            // as far way as the next larger at exponent
                            // boundaries. Test approx and *not* result to
                            // avoid having to detect an arbitrary power
                            // of ten.
                            if (approx.compareTo(BigDecimal.ONE) === 0) {
                                ulp = ulp.multiply(BigDecimal.ONE_TENTH);
                            }
                            result = result.subtract(ulp);
                        }
                        break;
                    case RoundingMode.UP:
                    case RoundingMode.CEILING:
                        // Check if too small
                        if (result.square().compareTo(this) < 0) {
                            result = result.add(result.ulp());
                        }
                        break;
                    default:
                        // No additional work, rely on "2p + 2" property
                        // for correct rounding. Alternatively, could
                        // instead run the Newton iteration to around p
                        // digits and then do tests and fix-ups on the
                        // rounded value. One possible set of tests and
                        // fix-ups is given in the Hull and Abrham paper;
                        // however, additional half-way cases can occur
                        // for BigDecimal given the more varied
                        // combinations of input and output precisions
                        // supported.
                        break;
                }
            }
            if (result._scale !== preferredScale) {
                // The preferred scale of an add is
                // max(addend.scale(), augend.scale()). Therefore, if
                // the scale of the result is first minimized using
                // stripTrailingZeros(), adding a zero of the
                // preferred scale rounding to the correct precision
                // will perform the proper scale vs precision
                // tradeoffs.
                result = result.stripTrailingZeros().add(zeroWithFinalPreferredScale, new MathContext(originalPrecision, RoundingMode.UNNECESSARY));
            }
            return result;
        }
    }
    /** @internal */
    square() {
        return this.multiply(this);
    }
    /**
     * Returns the size of an ulp, a unit in the last place, of this
     * `BigDecimal`.  An ulp of a nonzero `BigDecimal`
     * value is the positive distance between this value and the
     * `BigDecimal` value next larger in magnitude with the
     * same number of digits.  An ulp of a zero value is numerically
     * equal to 1 with the scale of `this`.  The result is
     * stored with the same scale as `this` so the result
     * for zero and nonzero values is equal to `[1, this.scale()]`.
     *
     * @return the size of an ulp of `this`
     */
    ulp() {
        return BigDecimal.fromInteger2(1, this._scale, 1);
    }
    /**
     * Returns signum of a bigint. If negative -1 returned, if positive 1 returned, if zero 0 returned.
     * @param val
     * @internal
     */
    static bigIntSignum(val) {
        return val > BigDecimal.zeroBigInt ? 1 : (val < BigDecimal.zeroBigInt ? -1 : 0);
    }
    /**
     * Returns a `BigDecimal` which is numerically equal to
     * this one but with any trailing zeros removed from the
     * representation.  For example, stripping the trailing zeros from
     * the `BigDecimal` value `600.0`, which has
     * [`BigInt`, `scale`] components equal to
     * [6000n, 1], yields `6E2` with [`BigInt`, `scale`]
     * components equal to [6n, -2].
     *
     * @return a numerically equal `BigDecimal` with any
     * trailing zeros removed.
     * @throws RangeError if scale from max or min safe integer range.
     */
    stripTrailingZeros() {
        if (this.intCompact === 0 || (this.intVal !== null && BigDecimal.bigIntSignum(this.intVal) === 0)) {
            return BigDecimal.ZERO;
        }
        else if (this.intCompact !== BigDecimal.INFLATED) {
            return BigDecimal.createAndStripZerosToMatchScale(this.intCompact, this._scale, Number.MIN_SAFE_INTEGER);
        }
        else {
            return BigDecimal.createAndStripZerosToMatchScale2(this.intVal, this._scale, Number.MIN_SAFE_INTEGER);
        }
    }
    /**
     * Returns whether this `BigDecimal` is a power of ten(negative or positive).
     * @internal
     */
    isPowerOfTen() {
        return this.unscaledValue() === BigDecimal.oneBigInt;
    }
    /**
     * Returns a `BigInt` whose value is the <i>unscaled
     * value</i> of this `BigDecimal`.  (Computes <code>(this *
     * 10<sup>this.scale()</sup>)</code>.)
     *
     * @return the unscaled value of this `BigDecimal`.
     */
    unscaledValue() {
        return this.inflated();
    }
    /**
     * Returns the <i>scale</i> of this `BigDecimal`.  If zero
     * or positive, the scale is the number of digits to the right of
     * the decimal point.  If negative, the unscaled value of the
     * number is multiplied by ten to the power of the negation of the
     * scale.  For example, a scale of `-3` means the unscaled
     * value is multiplied by 1000.
     *
     * The scale will be kept in the integer range, if cannot error will be thrown.
     *
     * @return the scale of this `BigDecimal`.
     */
    scale() {
        return this._scale;
    }
    /**
     * Returns a BigDecimal whose numerical value is equal to
     * (`this` * 10<sup>n</sup>).  The scale of
     * the result is `(this.scale() - n)`.
     *
     * @param n the exponent power of ten to scale by
     * @return a BigDecimal whose numerical value is equal to
     * (`this` * 10<sup>n</sup>)
     * @throws RangeError if the scale would be outside the range of a safe integer.
     */
    scaleByPowerOfTen(n) {
        return new BigDecimal(this.intVal, this.intCompact, this.checkScale(this._scale - n), this._precision);
    }
    /**
     * Compares this `BigDecimal` numerically with the specified
     * `BigDecimal`.  Two `BigDecimal` objects that are
     * equal in value but have a different scale (like 2.0 and 2.00)
     * are considered equal by this method. Such values are in the
     * same <i>cohort</i>.
     *
     * This method is provided in preference to individual methods for
     * each of the six boolean comparison operators (`<`, `==`,
     * `>`, `>=`, `!=`, `<=`).  The suggested
     * idiom for performing these comparisons is:
     * (x.compareTo(y) &lt;<i>op</i>&gt; 0), where
     * &lt;<i>op</i>&gt; is one of the six comparison operators.

     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @return -1, 0, or 1 as this `BigDecimal` is numerically
     *          less than, equal to, or greater than `val`.
     * @see {@link sameValue}
     * @see {@link greaterThan}
     * @see {@link greaterThanOrEquals}
     * @see {@link lowerThan}
     * @see {@link lowerThanOrEquals}
     */
    compareTo(val) {
        val = BigDecimal.convertToBigDecimal(val);
        // Quick path for equal scale and non-inflated case.
        if (this._scale === val._scale) {
            const xs = this.intCompact;
            const ys = val.intCompact;
            if (xs !== BigDecimal.INFLATED && ys !== BigDecimal.INFLATED) {
                return xs !== ys ? (xs > ys ? 1 : -1) : 0;
            }
        }
        const xsign = this.signum();
        const ysign = val.signum();
        if (xsign !== ysign) {
            return xsign > ysign ? 1 : -1;
        }
        else if (xsign === 0) {
            return 0;
        }
        else {
            const cmp = this.compareMagnitude(val);
            return xsign > 0 ? cmp : -cmp;
        }
    }
    /**
    * Alias for `compareTo(val) === 0`.
    * Consider using {@link equals} in case the scale needs to be considered.
    * @returns true if the value is the same as `val`
    * @see {@link equals}
    * @see {@link compareTo}
    */
    sameValue(val) {
        return this.compareTo(val) === 0;
    }
    /**
     * Alias for `compareTo(val) > 0`.
     *
     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @returns true if the value is greater than `val`
     * @see     {@link compareTo}
     * @alias   {@link gt}
     */
    greaterThan(val) {
        return this.compareTo(val) > 0;
    }
    /**
     * @alias {@link greaterThan}
     */
    gt(val) {
        return this.greaterThan(val);
    }
    /**
     * Alias for `compareTo(val) >= 0`.
     *
     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @returns true if the value is greater than or equals to `val`
     * @see     {@link compareTo}
     * @alias   {@link gte}
     */
    greaterThanOrEquals(val) {
        return this.compareTo(val) >= 0;
    }
    /**
     * @alias {@link greaterThanOrEquals}
     */
    gte(val) {
        return this.greaterThanOrEquals(val);
    }
    /**
     * Alias for `compareTo(val) < 0`.
     *
     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @returns true if the value is lower than `val`
     * @see     {@link compareTo}
     * @alias   {@link lt}
     */
    lowerThan(val) {
        return this.compareTo(val) < 0;
    }
    /**
     * @alias {@link lowerThan}
     */
    lt(val) {
        return this.lowerThan(val);
    }
    /**
     * Alias for `compareTo(val) <= 0`.
     *
     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @returns true if the value is lower than or equals to `val`
     * @see     {@link compareTo}
     * @alias   {@link lte}
     */
    lowerThanOrEquals(val) {
        return this.compareTo(val) <= 0;
    }
    /**
     * @alias {@link lowerThanOrEquals}
     */
    lte(val) {
        return this.lowerThanOrEquals(val);
    }
    /**
     * Converts this BigDecimal to number.
     * @return number for of this BigDecimal
     */
    numberValue() {
        if (this.intCompact !== BigDecimal.INFLATED) {
            if (this._scale === 0) {
                return this.intCompact;
            }
            else {
                /*
                 * If both intCompact and the scale can be exactly
                 * represented as double values, perform a single
                 * double multiply or divide to compute the (properly
                 * rounded) result.
                 */
                if (Math.abs(this.intCompact) < Number.MAX_SAFE_INTEGER) {
                    // Don't have too guard against
                    // Math.abs(MIN_VALUE) because of outer check
                    // against INFLATED.
                    if (this._scale > 0 && this._scale <= BigDecimal.MAX_COMPACT_DIGITS) {
                        return this.intCompact / BigDecimal.NUMBER_10_POW[this._scale];
                    }
                    else if (this._scale < 0 && this._scale >= -BigDecimal.MAX_COMPACT_DIGITS) {
                        return this.intCompact * BigDecimal.NUMBER_10_POW[-this._scale];
                    }
                }
            }
        }
        // Somewhat inefficient, but guaranteed to work.
        return Number(this.toString());
    }
    /**
     * Returns a `BigDecimal` rounded according to the
     * `MathContext` settings.  If the precision setting is 0 then
     * no rounding takes place.
     *
     * The effect of this method is identical to that of the
     * {@link plus} method.
     *
     * @param mc the context to use.
     * @return a `BigDecimal` rounded according to the
     *         `MathContext` settings.
     * @see    {@link plus}
     */
    round(mc) {
        return this.plus(mc);
    }
    /**
     * Returns a `BigDecimal` whose scale is the specified
     * value, and whose unscaled value is determined by multiplying or
     * dividing this `BigDecimal`'s unscaled value by the
     * appropriate power of ten to maintain its overall value.  If the
     * scale is reduced by the operation, the unscaled value must be
     * divided (rather than multiplied), and the value may be changed;
     * in this case, the specified rounding mode is applied to the
     * division.
     *
     *
     * @param newScale scale of the `BigDecimal` value to be returned.
     * @param roundingMode The rounding mode to apply. By default it is set to `UNNECESSARY`.
     * @return a `BigDecimal` whose scale is the specified value,
     *         and whose unscaled value is determined by multiplying or
     *         dividing this `BigDecimal`'s unscaled value by the
     *         appropriate power of ten to maintain its overall value.
     * @throws RangeError if roundingMode is `UNNECESSARY`
     *         and the specified scaling operation would require
     *         rounding.
     * @see {@link RoundingMode}
     */
    setScale(newScale, roundingMode = RoundingMode.UNNECESSARY) {
        if (roundingMode < RoundingMode.UP || roundingMode > RoundingMode.UNNECESSARY)
            throw new RangeError('Invalid rounding mode');
        const oldScale = this._scale;
        if (newScale === oldScale) // easy case
            return this;
        if (this.signum() === 0) // zero can have any scale
            return BigDecimal.zeroValueOf(newScale);
        if (this.intCompact !== BigDecimal.INFLATED) {
            let rs = this.intCompact;
            if (newScale > oldScale) {
                const raise = this.checkScale(newScale - oldScale);
                if ((rs = BigDecimal.integerMultiplyPowerTen(rs, raise)) !== BigDecimal.INFLATED) {
                    return BigDecimal.fromInteger3(rs, newScale);
                }
                const rb = this.bigMultiplyPowerTen(raise);
                return new BigDecimal(rb, BigDecimal.INFLATED, newScale, (this._precision > 0) ? this._precision + raise : 0);
            }
            else {
                // newScale < oldScale -- drop some digits
                // Can't predict the precision due to the effect of rounding.
                const drop = this.checkScale(oldScale - newScale);
                if (drop < BigDecimal.TEN_POWERS_TABLE.length) {
                    return BigDecimal.divideAndRound2(rs, BigDecimal.TEN_POWERS_TABLE[drop], newScale, roundingMode, newScale);
                }
                else {
                    return BigDecimal.divideAndRound3(this.inflated(), BigInt(10) ** BigInt(drop), newScale, roundingMode, newScale);
                }
            }
        }
        else {
            if (newScale > oldScale) {
                const raise = this.checkScale(newScale - oldScale);
                const rb = BigDecimal.bigMultiplyPowerTen3(this.intVal, raise);
                return new BigDecimal(rb, BigDecimal.INFLATED, newScale, (this._precision > 0) ? this._precision + raise : 0);
            }
            else {
                // newScale < oldScale -- drop some digits
                // Can't predict the precision due to the effect of rounding.
                const drop = this.checkScale(oldScale - newScale);
                if (drop < BigDecimal.TEN_POWERS_TABLE.length)
                    return BigDecimal.divideAndRound4(this.intVal, BigDecimal.TEN_POWERS_TABLE[drop], newScale, roundingMode, newScale);
                else
                    return BigDecimal.divideAndRound3(this.intVal, BigInt(10) ** BigInt(drop), newScale, roundingMode, newScale);
            }
        }
    }
    /**
     * Returns a `BigDecimal` whose value is `(+this)`,
     * with rounding according to the context settings.
     *
     * The effect of this method is identical to that of the {@link round} method.
     *
     * @param mc the context to use.
     * @return `this`, rounded as necessary.  A zero result will
     *         have a scale of 0.
     * @see    {@link round}
     */
    plus(mc) {
        if (!mc)
            return this;
        if (mc.precision === 0) // no rounding please
            return this;
        return BigDecimal.doRound(this, mc);
    }
    /**
     * Returns a `BigDecimal` whose value is
     * <code>(this<sup>n</sup>)</code>.  The current implementation uses
     * the core algorithm defined in ANSI standard X3.274-1996 with
     * rounding according to the context settings.  In general, the
     * returned numerical value is within two ulps of the exact
     * numerical value for the chosen precision.
     *
     * The X3.274-1996 algorithm is:
     *
     * * An `RangeError` exception is thrown if
     *     * `abs(n)` > 999999999
     *     * `mc.precision == 0` and `n < 0`
     *     * `mc.precision > 0` and `n` has more than
     *    `mc.precision` decimal digits
     *
     * * if `n` is zero, a BigDecimal with value 1 is returned even if
     * `this` is zero, otherwise

     *     * if `n` is positive, the result is calculated via
     *   the repeated squaring technique into a single accumulator.
     *   The individual multiplications with the accumulator use the
     *   same math context settings as in `mc` except for a
     *   precision increased to `mc.precision + elength + 1`
     *   where `elength` is the number of decimal digits in
     *   `n`.
     *
     *     * if `n` is negative, the result is calculated as if
     *   `n` were positive; this value is then divided into one
     *   using the working precision specified above.
     *
     *     * The final value from either the positive or negative case
     *   is then rounded to the destination precision.
     *
     * @param n power to raise this `BigDecimal` to.
     * @param mc the context to use.
     * @return <code>this<sup>n</sup></code> using the ANSI standard X3.274-1996
     *         algorithm
     * @throws RangeError if the result is inexact but the
     *         rounding mode is `UNNECESSARY`, or `n` is out
     *         of range.
     */
    pow(n, mc) {
        if (!mc || (mc && mc.precision === 0)) {
            if (n < 0 || n > 999999999)
                throw new RangeError('Invalid operation');
            // No need to calculate pow(n) if result will over/underflow.
            // Don't attempt to support "supernormal" numbers.
            const newScale = this.checkScale(this._scale * n);
            return BigDecimal.fromBigInt5(this.inflated().valueOf() ** BigInt(n), newScale, 0);
        }
        if (n < -999999999 || n > 999999999)
            throw new RangeError('Invalid operation');
        if (n === 0) // x**0 == 1 in X3.274
            return BigDecimal.ONE;
        let workmc = mc; // working settings
        let mag = Math.abs(n); // magnitude of n
        if (mc.precision > 0) {
            const elength = BigDecimal.integerDigitLength(mag); // length of n in digits
            if (elength > mc.precision) // X3.274 rule
                throw new RangeError('Invalid operation');
            workmc = new MathContext(mc.precision + elength + 1, mc.roundingMode);
        }
        // ready to carry out power calculation...
        let acc = BigDecimal.ONE; // accumulator
        let seenbit = false; // set once we've seen a 1-bit
        for (let i = 1;; i++) { // for each bit [top bit ignored]
            mag <<= 1; // shift left 1 bit
            if (mag < 0) { // top bit is set
                seenbit = true; // OK, we're off
                acc = acc.multiply(this, workmc); // acc=acc*x
            }
            if (i === 31)
                break; // that was the last bit
            if (seenbit)
                acc = acc.multiply(acc, workmc); // acc=acc*acc [square]
            // else (!seenbit) no point in squaring ONE
        }
        // if negative n, calculate the reciprocal using working precision
        if (n < 0) // [hence mc.precision>0]
            acc = BigDecimal.ONE.divideWithMathContext(acc, workmc);
        // round to final precision and strip zeros
        return BigDecimal.doRound(acc, mc);
    }
    /**
     * Returns a `BigDecimal` whose value is the absolute value
     * of this `BigDecimal`, with rounding according to the
     * context settings.
     *
     * @param mc the context to use.
     * @return absolute value, rounded as necessary.
     */
    abs(mc) {
        return this.signum() < 0 ? this.negate(mc) : this.plus(mc);
    }
    /**
     * Internally used for division operation for division `number`
     * by `number`.
     * The returned `BigDecimal` object is the quotient whose scale is set
     * to the passed in scale. If the remainder is not zero, it will be rounded
     * based on the passed in roundingMode. Also, if the remainder is zero and
     * the last parameter, i.e. preferredScale is NOT equal to scale, the
     * trailing zeros of the result is stripped to match the preferredScale.
     * @internal
     */
    static divideAndRound2(ldividend, ldivisor, scale, roundingMode, preferredScale) {
        const q = Math.trunc(ldividend / ldivisor);
        if (roundingMode === RoundingMode.DOWN && scale === preferredScale)
            return BigDecimal.fromInteger3(q, scale);
        const r = ldividend % ldivisor;
        const qsign = ((ldividend < 0) === (ldivisor < 0)) ? 1 : -1; // quotient sign
        if (r !== 0) {
            const increment = BigDecimal.needIncrement(ldivisor, roundingMode, qsign, q, r);
            return BigDecimal.fromInteger3((increment ? q + qsign : q), scale);
        }
        else {
            if (preferredScale !== scale)
                return BigDecimal.createAndStripZerosToMatchScale(q, scale, preferredScale);
            else
                return BigDecimal.fromInteger3(q, scale);
        }
    }
    /**
     * Tests if quotient has to be incremented according the roundingMode
     * @internal
     */
    static needIncrement(ldivisor, roundingMode, qsign, q, r) {
        let cmpFracHalf;
        if (r <= BigDecimal.HALF_NUMBER_MIN_VALUE || r > BigDecimal.HALF_NUMBER_MAX_VALUE) {
            cmpFracHalf = 1; // 2 * r can't fit into long
        }
        else {
            cmpFracHalf = BigDecimal.integerCompareMagnitude(2 * r, ldivisor);
        }
        return BigDecimal.commonNeedIncrement(roundingMode, qsign, cmpFracHalf, (q & 1) !== 0);
    }
    /**
     * Shared logic of need increment computation.
     * @internal
     */
    static commonNeedIncrement(roundingMode, qsign, cmpFracHalf, oddQuot) {
        switch (roundingMode) {
            case RoundingMode.UNNECESSARY:
                throw new RangeError('Rounding necessary');
            case RoundingMode.UP: // Away from zero
                return true;
            case RoundingMode.DOWN: // Towards zero
                return false;
            case RoundingMode.CEILING: // Towards +infinity
                return qsign > 0;
            case RoundingMode.FLOOR: // Towards -infinity
                return qsign < 0;
            default: // Some kind of half-way rounding
                if (cmpFracHalf < 0) // We're closer to higher digit
                    return false;
                else if (cmpFracHalf > 0) // We're closer to lower digit
                    return true;
                else { // half-way
                    switch (roundingMode) {
                        case RoundingMode.HALF_DOWN:
                            return false;
                        case RoundingMode.HALF_UP:
                            return true;
                        case RoundingMode.HALF_EVEN:
                            return oddQuot;
                        default:
                            throw new RangeError(`Unexpected rounding mode ${RoundingMode[roundingMode]}`);
                    }
                }
        }
    }
    /** @internal */
    static integerCompareMagnitude(x, y) {
        if (x < 0)
            x = -x;
        if (y < 0)
            y = -y;
        return (x < y) ? -1 : ((x === y) ? 0 : 1);
    }
    /**
     * Compares magnitudes of two bigints if x < y returns -1, if equal 0 if x > y, 1.
     * @param x
     * @param y
     * @internal
     */
    static bigIntCompareMagnitude(x, y) {
        if (x < BigDecimal.zeroBigInt)
            x = BigDecimal.minusOneBigInt * x.valueOf();
        if (y < BigDecimal.zeroBigInt)
            y = BigDecimal.minusOneBigInt * y.valueOf();
        return (x < y) ? -1 : ((x === y) ? 0 : 1);
    }
    /**
     * Converts a bigint to bigdecimal
     * @param bigInt bigint
     * @param qsign sign
     * @param scale scale
     * @internal
     */
    static bigIntToBigDecimal(bigInt, qsign, scale) {
        if (bigInt <= BigInt(Number.MAX_SAFE_INTEGER) && bigInt >= BigInt(Number.MIN_SAFE_INTEGER)) {
            const numberForm = Number(bigInt);
            return new BigDecimal(null, qsign * numberForm, scale, 0);
        }
        else {
            return new BigDecimal(BigInt(qsign) * bigInt.valueOf(), BigDecimal.INFLATED, scale, 0);
        }
    }
    /**
     * Converts a bigint to number, returns INFLATED if it won't be a safe integer
     * @param bigInt bigint
     * @param qsign sign number
     * @internal
     */
    static bigIntToCompactValue(bigInt, qsign) {
        if (bigInt <= BigInt(Number.MAX_SAFE_INTEGER) && bigInt >= BigInt(Number.MIN_SAFE_INTEGER)) {
            return qsign * Number(bigInt);
        }
        else {
            return BigDecimal.INFLATED;
        }
    }
    /**
     * Internally used for division operation for division `BigInt`
     * by `BigInt`.
     * The returned `BigDecimal` object is the quotient whose scale is set
     * to the passed in scale. If the remainder is not zero, it will be rounded
     * based on the passed in roundingMode. Also, if the remainder is zero and
     * the last parameter, i.e. preferredScale is NOT equal to scale, the
     * trailing zeros of the result is stripped to match the preferredScale.
     * @internal
     */
    static divideAndRound3(bdividend, bdivisor, scale, roundingMode, preferredScale) {
        // quotient sign
        const qsign = (BigDecimal.bigIntSignum(bdividend) !== BigDecimal.bigIntSignum(bdivisor)) ? -1 : 1;
        if (bdividend < BigDecimal.zeroBigInt)
            bdividend = bdividend.valueOf() * BigDecimal.minusOneBigInt;
        if (bdivisor < BigDecimal.zeroBigInt)
            bdivisor = bdivisor.valueOf() * BigDecimal.minusOneBigInt;
        let mq = bdividend.valueOf() / bdivisor.valueOf();
        const mr = bdividend.valueOf() % bdivisor.valueOf();
        // record remainder is zero or not
        const isRemainderZero = mr === BigDecimal.zeroBigInt;
        if (!isRemainderZero) {
            if (BigDecimal.needIncrement2(bdivisor, roundingMode, qsign, mq, mr)) {
                mq += BigDecimal.oneBigInt;
            }
            return BigDecimal.bigIntToBigDecimal(mq, qsign, scale);
        }
        else {
            if (preferredScale !== scale) {
                const compactVal = BigDecimal.bigIntToCompactValue(mq, qsign);
                if (compactVal !== BigDecimal.INFLATED) {
                    return BigDecimal.createAndStripZerosToMatchScale(compactVal, scale, preferredScale);
                }
                const intVal = BigInt(qsign) * mq.valueOf();
                return BigDecimal.createAndStripZerosToMatchScale2(intVal, scale, preferredScale);
            }
            else {
                return BigDecimal.bigIntToBigDecimal(mq, qsign, scale);
            }
        }
    }
    /**
     * Tests if quotient has to be incremented according the roundingMode
     * @internal
     */
    static needIncrement2(mdivisor, roundingMode, qsign, mq, mr) {
        const cmpFracHalf = BigDecimal.compareHalf(mr, mdivisor);
        return BigDecimal.commonNeedIncrement(roundingMode, qsign, cmpFracHalf, mq.valueOf() % BigDecimal.twoBigInt === BigDecimal.oneBigInt);
    }
    /**
     * Compares half of second with first
     * @param first
     * @param second
     * @private
     */
    static compareHalf(first, second) {
        second = second.valueOf() / BigDecimal.twoBigInt;
        if (first < second)
            return -1;
        if (first > second)
            return 1;
        return 0;
    }
    /**
     * Internally used for division operation for division `BigInt`
     * by `number`.
     * The returned `BigDecimal` object is the quotient whose scale is set
     * to the passed in scale. If the remainder is not zero, it will be rounded
     * based on the passed in roundingMode. Also, if the remainder is zero and
     * the last parameter, i.e. preferredScale is NOT equal to scale, the
     * trailing zeros of the result is stripped to match the preferredScale.
     * @internal
     */
    static divideAndRound4(bdividend, ldivisor, scale, roundingMode, preferredScale) {
        const divisorNegative = ldivisor < 0;
        const dividendSignum = BigDecimal.bigIntSignum(bdividend);
        if (divisorNegative)
            ldivisor *= -1;
        if (dividendSignum === -1)
            bdividend = bdividend.valueOf() * BigDecimal.minusOneBigInt;
        let mq = bdividend.valueOf() / BigInt(ldivisor);
        let mr;
        const bDividendNumber = Number(bdividend);
        if (Number.isSafeInteger(bDividendNumber)) {
            mr = bDividendNumber % ldivisor;
        }
        else {
            mr = Number(bdividend.valueOf() % BigInt(ldivisor));
        }
        // record remainder is zero or not
        const isRemainderZero = mr === 0;
        // quotient sign
        const qsign = divisorNegative ? -dividendSignum : dividendSignum;
        if (!isRemainderZero) {
            if (BigDecimal.needIncrement3(ldivisor, roundingMode, qsign, mq, mr)) {
                mq += BigDecimal.oneBigInt;
            }
            return BigDecimal.bigIntToBigDecimal(mq, qsign, scale);
        }
        else {
            if (preferredScale !== scale) {
                const compactVal = BigDecimal.bigIntToCompactValue(mq, qsign);
                if (compactVal !== BigDecimal.INFLATED) {
                    return BigDecimal.createAndStripZerosToMatchScale(compactVal, scale, preferredScale);
                }
                const intVal = BigInt(qsign) * mq.valueOf();
                return BigDecimal.createAndStripZerosToMatchScale2(intVal, scale, preferredScale);
            }
            else {
                return BigDecimal.bigIntToBigDecimal(mq, qsign, scale);
            }
        }
    }
    /**
     * Tests if quotient has to be incremented according the roundingMode
     * @internal
     */
    static needIncrement3(ldivisor, roundingMode, qsign, mq, r) {
        let cmpFracHalf;
        if (r <= BigDecimal.HALF_NUMBER_MIN_VALUE || r > BigDecimal.HALF_NUMBER_MAX_VALUE) {
            cmpFracHalf = 1;
        }
        else {
            cmpFracHalf = BigDecimal.integerCompareMagnitude(2 * r, ldivisor);
        }
        return BigDecimal.commonNeedIncrement(roundingMode, qsign, cmpFracHalf, mq.valueOf() % BigDecimal.twoBigInt === BigDecimal.oneBigInt);
    }
    /**
     * Returns a `BigDecimal` which is equivalent to this one
     * with the decimal point moved `n` places to the left.  If
     * `n` is non-negative, the call merely adds `n` to
     * the scale.  If `n` is negative, the call is equivalent
     * to `movePointRight(-n)`.  The `BigDecimal`
     * returned by this call has value <code>(this &times;
     * 10<sup>-n</sup>)</code> and scale `max(this.scale()+n,
     * 0)`.
     *
     * @param n number of places to move the decimal point to the left.
     * @return a `BigDecimal` which is equivalent to this one with the
     *         decimal point moved `n` places to the left.
     * @throws RangeError if scale overflows.
     */
    movePointLeft(n) {
        if (n === 0)
            return this;
        // Cannot use movePointRight(-n) in case of n==BigDecimal.MIN_INT_VALUE
        const newScale = this.checkScale(this._scale + n);
        const num = new BigDecimal(this.intVal, this.intCompact, newScale, 0);
        return num._scale < 0 ? num.setScale(0, RoundingMode.UNNECESSARY) : num;
    }
    /**
     * Returns a `BigDecimal` which is equivalent to this one
     * with the decimal point moved `n` places to the right.
     * If `n` is non-negative, the call merely subtracts
     * `n` from the scale.  If `n` is negative, the call
     * is equivalent to `movePointLeft(-n)`.  The
     * `BigDecimal` returned by this call has value <code>(this
     * &times; 10<sup>n</sup>)</code> and scale `max(this.scale()-n, 0)`.
     *
     * @param n number of places to move the decimal point to the right.
     * @return a `BigDecimal` which is equivalent to this one
     *         with the decimal point moved `n` places to the right.
     * @throws RangeError if scale overflows.
     */
    movePointRight(n) {
        if (n === 0)
            return this;
        // Cannot use movePointLeft(-n) in case of n==BigDecimal.MIN_INT_VALUE
        const newScale = this.checkScale(this._scale - n);
        const num = new BigDecimal(this.intVal, this.intCompact, newScale, 0);
        return num._scale < 0 ? num.setScale(0, RoundingMode.UNNECESSARY) : num;
    }
    /**
     * Returns the minimum of this `BigDecimal` and `val`.
     *
     * @param val value with which the minimum is to be computed.
     * @return the `BigDecimal` whose value is the lesser of this
     *         `BigDecimal` and `val`.  If they are equal,
     *         as defined by the {@link compareTo}
     *         method, `this` is returned.
     * @see    {@link compareTo}
     */
    min(val) {
        return (this.compareTo(val) <= 0 ? this : val);
    }
    /**
     * Returns the maximum of this `BigDecimal` and `val`.
     *
     * @param val value with which the maximum is to be computed.
     * @return the `BigDecimal` whose value is the greater of this
     *         `BigDecimal` and `val`.  If they are equal,
     *         as defined by the {@link compareTo}
     *         method, `this` is returned.
     * @see    {@link compareTo}
     */
    max(val) {
        return (this.compareTo(val) >= 0 ? this : val);
    }
    /**
     * Returns the string representation of this `BigDecimal`,
     * using scientific notation if an exponent is needed.
     *
     * A standard canonical string form of the `BigDecimal`
     * is created as though by the following steps: first, the
     * absolute value of the unscaled value of the `BigDecimal`
     * is converted to a string in base ten using the characters
     * '0' through '9' with no leading zeros (except
     * if its value is zero, in which case a single '0'
     * character is used).
     *
     * Next, an <i>adjusted exponent</i> is calculated; this is the
     * negated scale, plus the number of characters in the converted
     * unscaled value, less one.  That is,
     * `-scale+(ulength-1)`, where `ulength` is the
     * length of the absolute value of the unscaled value in decimal
     * digits (its <i>precision</i>).
     *
     * If the scale is greater than or equal to zero and the
     * adjusted exponent is greater than or equal to `-6`, the
     * number will be converted to a character form without using
     * exponential notation.  In this case, if the scale is zero then
     * no decimal point is added and if the scale is positive a
     * decimal point will be inserted with the scale specifying the
     * number of characters to the right of the decimal point.
     * '0' characters are added to the left of the converted
     * unscaled value as necessary.  If no character precedes the
     * decimal point after this insertion then a conventional
     * '0' character is prefixed.
     *
     * Otherwise (that is, if the scale is negative, or the
     * adjusted exponent is less than `-6`), the number will be
     * converted to a character form using exponential notation.  In
     * this case, if the converted `BigInt` has more than
     * one digit a decimal point is inserted after the first digit.
     * An exponent in character form is then suffixed to the converted
     * unscaled value (perhaps with inserted decimal point); this
     * comprises the letter 'E' followed immediately by the
     * adjusted exponent converted to a character form.  The latter is
     * in base ten, using the characters '0' through
     * '9' with no leading zeros, and is always prefixed by a
     * sign character '-' (<code>'&#92;u002D'</code>) if the
     * adjusted exponent is negative, '+'
     * (<code>'&#92;u002B'</code>) otherwise).
     *
     * Finally, the entire string is prefixed by a minus sign
     * character '-' (<code>'&#92;u002D'</code>) if the unscaled
     * value is less than zero.  No sign character is prefixed if the
     * unscaled value is zero or positive.
     *
     * **Examples:**
     * For each representation [<i>unscaled value</i>, <i>scale</i>]
     * on the left, the resulting string is shown on the right.
     * <pre>
     * [123,0]      "123"
     * [-123,0]     "-123"
     * [123,-1]     "1.23E+3"
     * [123,-3]     "1.23E+5"
     * [123,1]      "12.3"
     * [123,5]      "0.00123"
     * [123,10]     "1.23E-8"
     * [-123,12]    "-1.23E-10"
     * </pre>
     *
     * **Notes:**
     *
     * * There is a one-to-one mapping between the distinguishable
     * `BigDecimal` values and the result of this conversion.
     * That is, every distinguishable `BigDecimal` value
     * (unscaled value and scale) has a unique string representation
     * as a result of using `toString`.  If that string
     * representation is converted back to a `BigDecimal` using
     * the string constructor, then the original
     * value will be recovered.
     *
     * * The {@link toEngineeringString} method may be used for
     * presenting numbers with exponents in engineering notation, and the
     * {@link setScale} method may be used for
     * rounding a `BigDecimal` so it has a known number of digits after
     * the decimal point.
     *
     * @return string representation of this `BigDecimal`.
     */
    toString() {
        let sc = this.stringCache;
        if (sc === undefined) {
            this.stringCache = sc = this.layoutString(true);
        }
        return sc;
    }
    /**
     * Returns a string representation of this `BigDecimal`,
     * using engineering notation if an exponent is needed.
     *
     * Returns a string that represents the `BigDecimal` as
     * described in the {@link toString} method, except that if
     * exponential notation is used, the power of ten is adjusted to
     * be a multiple of three (engineering notation) such that the
     * integer part of nonzero values will be in the range 1 through
     * 999.  If exponential notation is used for zero values, a
     * decimal point and one or two fractional zero digits are used so
     * that the scale of the zero value is preserved.  Note that
     * unlike the output of {@link toString}, the output of this
     * method is <em>not</em> guaranteed to recover the same [number,
     * scale] pair of this `BigDecimal` if the output string is
     * converting back to a `BigDecimal` using the string constructor.
     * The result of this method meets the weaker constraint of always producing a numerically equal
     * result from applying the string constructor to the method's output.
     *
     * @return string representation of this `BigDecimal`, using
     *         engineering notation if an exponent is needed.
     */
    toEngineeringString() {
        return this.layoutString(false);
    }
    /**
     * Returns absolute value of a bigint
     * @internal
     */
    static bigIntAbs(val) {
        if (val < BigDecimal.zeroBigInt) {
            return val.valueOf() * BigDecimal.minusOneBigInt;
        }
        else
            return val;
    }
    /**
     * Lay out this `BigDecimal` into a string.
     *
     * @param sci `true` for Scientific exponential notation;
     *            `false` for Engineering
     * @return string with canonical string representation of this
     * `BigDecimal`
     * @internal
     */
    layoutString(sci) {
        if (this._scale === 0) // zero scale is trivial
            return (this.intCompact !== BigDecimal.INFLATED) ? this.intCompact.toString() : this.intVal.toString();
        if (this._scale === 2 && this.intCompact >= 0 && this.intCompact < Number.MAX_SAFE_INTEGER) {
            // currency fast path
            const lowInt = this.intCompact % 100;
            const highInt = Math.trunc(this.intCompact / 100);
            return (highInt.toString() + '.' + BigDecimal.DIGIT_TENS[lowInt] + BigDecimal.DIGIT_ONES[lowInt]);
        }
        let coeff;
        const offset = 0; // offset is the starting index for coeff array
        // Get the significand as an absolute value
        if (this.intCompact !== BigDecimal.INFLATED) {
            coeff = Math.abs(this.intCompact).toString();
        }
        else {
            coeff = BigDecimal.bigIntAbs(this.intVal).toString();
        }
        // Construct a string.
        let str = '';
        if (this.signum() < 0) // prefix '-' if negative
            str += '-';
        const coeffLen = coeff.length - offset;
        let adjusted = -this._scale + (coeffLen - 1);
        if ((this._scale >= 0) && (adjusted >= -6)) { // plain number
            let pad = this._scale - coeffLen; // count of padding zeros
            if (pad >= 0) { // 0.xxx form
                str += '0';
                str += '.';
                for (; pad > 0; pad--) {
                    str += '0';
                }
                str += coeff.substr(offset, coeffLen);
            }
            else { // xx.xx form
                str += coeff.substr(offset, -pad);
                str += '.';
                str += coeff.substr(-pad + offset, this._scale);
            }
        }
        else { // E-notation is needed
            if (sci) { // Scientific notation
                str += coeff[offset]; // first character
                if (coeffLen > 1) { // more to come
                    str += '.';
                    str += coeff.substr(offset + 1, coeffLen - 1);
                }
            }
            else { // Engineering notation
                let sig = (adjusted % 3);
                if (sig < 0)
                    sig += 3; // [adjusted was negative]
                adjusted -= sig; // now a multiple of 3
                sig++;
                if (this.signum() === 0) {
                    switch (sig) {
                        case 1:
                            str += '0'; // exponent is a multiple of three
                            break;
                        case 2:
                            str += '0.00';
                            adjusted += 3;
                            break;
                        case 3:
                            str += '0.0';
                            adjusted += 3;
                            break;
                        default:
                            throw new RangeError('Unexpected sig value ' + sig);
                    }
                }
                else if (sig >= coeffLen) { // significand all in integer
                    str += coeff.substr(offset, coeffLen);
                    // may need some zeros, too
                    for (let i = sig - coeffLen; i > 0; i--) {
                        str += '0';
                    }
                }
                else { // xx.xxE form
                    str += coeff.substr(offset, sig);
                    str += '.';
                    str += coeff.substr(offset + sig, coeffLen - sig);
                }
            }
            if (adjusted !== 0) { // [!sci could have made 0]
                str += 'E';
                if (adjusted > 0) // force sign for positive
                    str += '+';
                str += adjusted.toString();
            }
        }
        return str;
    }
    /**
     * Returns a string representation of this `BigDecimal`
     * without an exponent field.  For values with a positive scale,
     * the number of digits to the right of the decimal point is used
     * to indicate scale.  For values with a zero or negative scale,
     * the resulting string is generated as if the value were
     * converted to a numerically equal value with zero scale and as
     * if all the trailing zeros of the zero scale value were present
     * in the result.
     *
     * The entire string is prefixed by a minus sign character '-'
     * (<code>'&#92;u002D'</code>) if the unscaled value is less than
     * zero. No sign character is prefixed if the unscaled value is
     * zero or positive.
     *
     * Note that if the result of this method is passed to the
     * string constructor, only the
     * numerical value of this `BigDecimal` will necessarily be
     * recovered; the representation of the new `BigDecimal`
     * may have a different scale.  In particular, if this
     * `BigDecimal` has a negative scale, the string resulting
     * from this method will have a scale of zero when processed by
     * the string constructor.
     *
     * @return a string representation of this `BigDecimal`
     * without an exponent field.
     * @see {@link toString}
     * @see {@link toEngineeringString}
     */
    toPlainString() {
        if (this._scale === 0) {
            if (this.intCompact !== BigDecimal.INFLATED) {
                return this.intCompact.toString();
            }
            else {
                return this.intVal.toString();
            }
        }
        if (this._scale < 0) { // No decimal point
            if (this.signum() === 0) {
                return '0';
            }
            const trailingZeros = this.checkScale(-this._scale);
            let buf = '';
            if (this.intCompact !== BigDecimal.INFLATED) {
                buf += this.intCompact.toString();
            }
            else {
                buf += this.intVal.toString();
            }
            for (let i = 0; i < trailingZeros; i++) {
                buf += '0';
            }
            return buf;
        }
        let str;
        if (this.intCompact !== BigDecimal.INFLATED) {
            str = Math.abs(this.intCompact).toString();
        }
        else {
            str = BigDecimal.bigIntAbs(this.intVal).toString();
        }
        return BigDecimal.getValueString(this.signum(), str, this._scale);
    }
    /**
     * Returns a digit.digit string
     * @internal
     */
    static getValueString(signum, intString, scale) {
        /* Insert decimal point */
        let buf = '';
        const insertionPoint = intString.length - scale;
        if (insertionPoint === 0) { /* Point goes right before intVal */
            return (signum < 0 ? '-0.' : '0.') + intString;
        }
        else if (insertionPoint > 0) { /* Point goes inside intVal */
            buf = intString.slice(0, insertionPoint) + '.' + intString.slice(insertionPoint);
            if (signum < 0)
                buf = '-' + buf;
        }
        else { /* We must insert zeros between point and intVal */
            buf += signum < 0 ? '-0.' : '0.';
            for (let i = 0; i < -insertionPoint; i++) {
                buf += '0';
            }
            buf += intString;
        }
        return buf.toString();
    }
    /**
     * Converts this `BigDecimal` to a `BigInt`.
     * Any fractional part of this will be discarded.  Note that this
     * conversion can lose information about the precision of the
     * `BigDecimal` value.
     *
     * To have an exception thrown if the conversion is inexact (in
     * other words if a nonzero fractional part is discarded), use the
     * {@link toBigIntExact} method.
     *
     * @return this `BigDecimal` converted to a `BigInt`.
     */
    toBigInt() {
        // force to an integer, quietly
        return this.setScale(0, RoundingMode.DOWN).inflated();
    }
    /**
     * Converts this `BigDecimal` to a `BigInt`,
     * checking for lost information.  An exception is thrown if this
     * `BigDecimal` has a nonzero fractional part.
     *
     * @return this `BigDecimal` converted to a `BigInt`.
     * @throws RangeError if `this` has a nonzero fractional part.
     */
    toBigIntExact() {
        // round to an integer, with Exception if decimal part non-0
        return this.setScale(0, RoundingMode.UNNECESSARY).inflated();
    }
    /**
     * Divides `BigInt` value by number value and
     * do rounding based on the passed in roundingMode.
     * @internal
     */
    static divideAndRound5(bdividend, ldivisor, roundingMode) {
        const dividendSignum = BigDecimal.bigIntSignum(bdividend);
        const divisorNegative = ldivisor < 0;
        if (dividendSignum === -1)
            bdividend = bdividend.valueOf() * BigDecimal.minusOneBigInt;
        if (divisorNegative)
            ldivisor *= -1;
        let mq = bdividend.valueOf() / BigInt(ldivisor);
        let r;
        const bDividendNumber = Number(bdividend);
        if (Number.isSafeInteger(bDividendNumber)) {
            r = bDividendNumber % ldivisor;
        }
        else {
            r = Number(bdividend.valueOf() % BigInt(ldivisor));
        }
        // record remainder is zero or not
        const isRemainderZero = (r === 0);
        // quotient sign
        const qsign = divisorNegative ? (dividendSignum * -1) : dividendSignum;
        if (!isRemainderZero) {
            if (BigDecimal.needIncrement3(ldivisor, roundingMode, qsign, mq, r)) {
                mq += BigDecimal.oneBigInt;
            }
        }
        return mq * BigInt(qsign);
    }
    /**
     * Divides `BigInt` value by `BigInt` value and
     * do rounding based on the passed in roundingMode.
     * @internal
     */
    static divideAndRound6(bdividend, bdivisor, roundingMode) {
        const bdividendSignum = BigDecimal.bigIntSignum(bdividend);
        const bdivisorSignum = BigDecimal.bigIntSignum(bdivisor);
        if (bdividend < BigDecimal.zeroBigInt)
            bdividend = bdividend.valueOf() * BigDecimal.minusOneBigInt;
        if (bdivisor < BigDecimal.zeroBigInt)
            bdivisor = bdivisor.valueOf() * BigDecimal.minusOneBigInt;
        let mq = bdividend.valueOf() / bdivisor.valueOf();
        const mr = bdividend.valueOf() % bdivisor.valueOf();
        const isRemainderZero = mr === BigDecimal.zeroBigInt; // record remainder is zero or not
        const qsign = (bdividendSignum !== bdivisorSignum) ? -1 : 1; // quotient sign
        if (!isRemainderZero) {
            if (BigDecimal.needIncrement2(bdivisor, roundingMode, qsign, mq, mr)) {
                mq += BigDecimal.oneBigInt;
            }
        }
        return mq * BigInt(qsign);
    }
    /**
     * Returns a `BigDecimal` whose value is `(xs /
     * ys)`, with rounding according to the context settings.
     *
     * Fast path - used only when (xscale <= yscale && yscale < 15
     * && mc.presision<15)
     * @internal
     */
    static divideSmallFastPath(xs, xscale, ys, yscale, preferredScale, mc) {
        const mcp = mc.precision;
        const roundingMode = mc.roundingMode;
        const xraise = yscale - xscale; // xraise >=0
        const scaledX = (xraise === 0) ? xs : BigDecimal.integerMultiplyPowerTen(xs, xraise); // can't overflow here!
        let quotient;
        const cmp = BigDecimal.integerCompareMagnitude(scaledX, ys);
        if (cmp > 0) { // satisfy constraint (b)
            yscale -= 1; // [that is, divisor *= 10]
            const scl = BigDecimal.checkScaleNonZero(preferredScale + yscale - xscale + mcp);
            if (BigDecimal.checkScaleNonZero(mcp + yscale - xscale) > 0) {
                const raise = BigDecimal.checkScaleNonZero(mcp + yscale - xscale);
                const scaledXs = BigDecimal.integerMultiplyPowerTen(xs, raise);
                if (scaledXs === BigDecimal.INFLATED) {
                    quotient = null;
                    if ((mcp - 1) >= 0 && (mcp - 1) < BigDecimal.TEN_POWERS_TABLE.length) {
                        quotient = BigDecimal.divideAndRound4(BigInt(BigDecimal.TEN_POWERS_TABLE[mcp - 1]) * BigInt(scaledX), ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                    }
                    if (quotient === null) {
                        const rb = BigDecimal.bigMultiplyPowerTen2(scaledX, mcp - 1);
                        quotient = BigDecimal.divideAndRound4(rb, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                    }
                }
                else {
                    quotient = BigDecimal.divideAndRound2(scaledXs, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                }
            }
            else {
                const newScale = BigDecimal.checkScaleNonZero(xscale - mcp);
                if (newScale === yscale) {
                    quotient = BigDecimal.divideAndRound2(xs, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                }
                else {
                    const raise = BigDecimal.checkScaleNonZero(newScale - yscale);
                    const scaledYs = BigDecimal.integerMultiplyPowerTen(ys, raise);
                    if (scaledYs === BigDecimal.INFLATED) {
                        const rb = BigDecimal.bigMultiplyPowerTen2(ys, raise);
                        quotient = BigDecimal.divideAndRound3(BigInt(xs), rb, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                    }
                    else {
                        quotient = BigDecimal.divideAndRound2(xs, scaledYs, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                    }
                }
            }
        }
        else {
            // abs(scaledX) <= abs(ys)
            // result is "scaledX * 10^msp / ys"
            const scl = BigDecimal.checkScaleNonZero(preferredScale + yscale - xscale + mcp);
            if (cmp === 0) {
                // abs(scaleX)== abs(ys) => result will be scaled 10^mcp + correct sign
                quotient = BigDecimal.roundedTenPower(((scaledX < 0) === (ys < 0)) ? 1 : -1, mcp, scl, BigDecimal.checkScaleNonZero(preferredScale));
            }
            else {
                // abs(scaledX) < abs(ys)
                const scaledXs = BigDecimal.integerMultiplyPowerTen(scaledX, mcp);
                if (scaledXs === BigDecimal.INFLATED) {
                    quotient = null;
                    if (mcp < BigDecimal.TEN_POWERS_TABLE.length) {
                        quotient = BigDecimal.divideAndRound4(BigInt(BigDecimal.TEN_POWERS_TABLE[mcp]) * BigInt(scaledX), ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                    }
                    if (quotient === null) {
                        const rb = BigDecimal.bigMultiplyPowerTen2(scaledX, mcp);
                        quotient = BigDecimal.divideAndRound4(rb, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                    }
                }
                else {
                    quotient = BigDecimal.divideAndRound2(scaledXs, ys, scl, roundingMode, BigDecimal.checkScaleNonZero(preferredScale));
                }
            }
        }
        // doRound, here, only affects 1000000000 case.
        return BigDecimal.doRound(quotient, mc);
    }
    /**
     * calculate divideAndRound for ldividend*10^raise / divisor
     * when abs(dividend)==abs(divisor);
     * @internal
     */
    static roundedTenPower(qsign, raise, scale, preferredScale) {
        if (scale > preferredScale) {
            const diff = scale - preferredScale;
            if (diff < raise) {
                return BigDecimal.scaledTenPow(raise - diff, qsign, preferredScale);
            }
            else {
                return BigDecimal.fromInteger3(qsign, scale - raise);
            }
        }
        else {
            return BigDecimal.scaledTenPow(raise, qsign, scale);
        }
    }
    /** @internal */
    static scaledTenPow(n, sign, scale) {
        if (n < BigDecimal.TEN_POWERS_TABLE.length)
            return BigDecimal.fromInteger3(sign * BigDecimal.TEN_POWERS_TABLE[n], scale);
        else {
            let unscaledVal = BigInt(10) ** BigInt(n);
            if (sign === -1) {
                unscaledVal = unscaledVal * BigDecimal.minusOneBigInt;
            }
            return new BigDecimal(unscaledVal, BigDecimal.INFLATED, scale, n + 1);
        }
    }
    /**
     * Compare Normalize dividend & divisor so that both fall into [0.1, 0.999...]
     * @internal
     */
    static compareMagnitudeNormalized(xs, xscale, ys, yscale) {
        const sdiff = xscale - yscale;
        if (sdiff !== 0) {
            if (sdiff < 0) {
                xs = BigDecimal.integerMultiplyPowerTen(xs, -sdiff);
            }
            else {
                ys = BigDecimal.integerMultiplyPowerTen(ys, sdiff);
            }
        }
        if (xs !== BigDecimal.INFLATED)
            return (ys !== BigDecimal.INFLATED) ? BigDecimal.integerCompareMagnitude(xs, ys) : -1;
        else
            return 1;
    }
    /**
     * Compare Normalize dividend & divisor so that both fall into [0.1, 0.999...]
     * @internal
     */
    static compareMagnitudeNormalized2(xs, xscale, ys, yscale) {
        if (xs === 0)
            return -1;
        const sdiff = xscale - yscale;
        if (sdiff < 0) {
            if (BigDecimal.integerMultiplyPowerTen(xs, -sdiff) === BigDecimal.INFLATED) {
                return BigDecimal.bigIntCompareMagnitude(BigDecimal.bigMultiplyPowerTen2(xs, -sdiff), ys);
            }
        }
        return -1;
    }
    /**
     * Compare Normalize dividend & divisor so that both fall into [0.1, 0.999...]
     * @internal
     */
    static compareMagnitudeNormalized3(xs, xscale, ys, yscale) {
        const sdiff = xscale - yscale;
        if (sdiff < 0) {
            return BigDecimal.bigIntCompareMagnitude(BigDecimal.bigMultiplyPowerTen3(xs, -sdiff), ys);
        }
        else { // sdiff >= 0
            return BigDecimal.bigIntCompareMagnitude(xs, BigDecimal.bigMultiplyPowerTen3(ys, sdiff));
        }
    }
    /** @internal */
    static divide7(dividend, dividendScale, divisor, divisorScale, scale, roundingMode) {
        if (BigDecimal.checkScale2(dividend, scale + divisorScale) > dividendScale) {
            const newScale = scale + divisorScale;
            const raise = newScale - dividendScale;
            if (raise < BigDecimal.TEN_POWERS_TABLE.length) {
                let xs = dividend;
                if ((xs = BigDecimal.integerMultiplyPowerTen(xs, raise)) !== BigDecimal.INFLATED) {
                    return BigDecimal.divideAndRound2(xs, divisor, scale, roundingMode, scale);
                }
            }
            const scaledDividend = BigDecimal.bigMultiplyPowerTen2(dividend, raise);
            return BigDecimal.divideAndRound4(scaledDividend, divisor, scale, roundingMode, scale);
        }
        else {
            const newScale = BigDecimal.checkScale2(divisor, dividendScale - scale);
            const raise = newScale - divisorScale;
            if (raise < BigDecimal.TEN_POWERS_TABLE.length) {
                let ys = divisor;
                if ((ys = BigDecimal.integerMultiplyPowerTen(ys, raise)) !== BigDecimal.INFLATED) {
                    return BigDecimal.divideAndRound2(dividend, ys, scale, roundingMode, scale);
                }
            }
            const scaledDivisor = BigDecimal.bigMultiplyPowerTen2(divisor, raise);
            return BigDecimal.divideAndRound3(BigInt(dividend), scaledDivisor, scale, roundingMode, scale);
        }
    }
    /** @internal */
    static divide8(dividend, dividendScale, divisor, divisorScale, scale, roundingMode) {
        if (BigDecimal.checkScale2(dividend, scale + divisorScale) > dividendScale) {
            const newScale = scale + divisorScale;
            const raise = newScale - dividendScale;
            const scaledDividend = BigDecimal.bigMultiplyPowerTen2(dividend, raise);
            return BigDecimal.divideAndRound3(scaledDividend, divisor, scale, roundingMode, scale);
        }
        else {
            const newScale = BigDecimal.checkScale3(divisor, dividendScale - scale);
            const raise = newScale - divisorScale;
            const scaledDivisor = BigDecimal.bigMultiplyPowerTen3(divisor, raise);
            return BigDecimal.divideAndRound3(BigInt(dividend), scaledDivisor, scale, roundingMode, scale);
        }
    }
    /** @internal */
    static divide9(dividend, dividendScale, divisor, divisorScale, scale, roundingMode) {
        if (BigDecimal.checkScale3(dividend, scale + divisorScale) > dividendScale) {
            const newScale = scale + divisorScale;
            const raise = newScale - dividendScale;
            const scaledDividend = BigDecimal.bigMultiplyPowerTen3(dividend, raise);
            return BigDecimal.divideAndRound4(scaledDividend, divisor, scale, roundingMode, scale);
        }
        else {
            const newScale = BigDecimal.checkScale2(divisor, dividendScale - scale);
            const raise = newScale - divisorScale;
            if (raise < BigDecimal.TEN_POWERS_TABLE.length) {
                let ys = divisor;
                if ((ys = BigDecimal.integerMultiplyPowerTen(ys, raise)) !== BigDecimal.INFLATED) {
                    return BigDecimal.divideAndRound4(dividend, ys, scale, roundingMode, scale);
                }
            }
            const scaledDivisor = BigDecimal.bigMultiplyPowerTen2(divisor, raise);
            return BigDecimal.divideAndRound3(dividend, scaledDivisor, scale, roundingMode, scale);
        }
    }
    /** @internal */
    static divide10(dividend, dividendScale, divisor, divisorScale, scale, roundingMode) {
        if (BigDecimal.checkScale3(dividend, scale + divisorScale) > dividendScale) {
            const newScale = scale + divisorScale;
            const raise = newScale - dividendScale;
            const scaledDividend = BigDecimal.bigMultiplyPowerTen3(dividend, raise);
            return BigDecimal.divideAndRound3(scaledDividend, divisor, scale, roundingMode, scale);
        }
        else {
            const newScale = BigDecimal.checkScale3(divisor, dividendScale - scale);
            const raise = newScale - divisorScale;
            const scaledDivisor = BigDecimal.bigMultiplyPowerTen3(divisor, raise);
            return BigDecimal.divideAndRound3(dividend, scaledDivisor, scale, roundingMode, scale);
        }
    }
}
exports.BigDecimal = BigDecimal;
/** @internal */
BigDecimal.zeroBigInt = BigInt(0);
/** @internal */
BigDecimal.oneBigInt = BigInt(1);
/** @internal */
BigDecimal.twoBigInt = BigInt(2);
/** @internal */
BigDecimal.minusOneBigInt = BigInt(-1);
/**
 * Sentinel value for {@link intCompact} indicating the
 * significand information is only available from intVal.
 * @internal
 */
BigDecimal.INFLATED = Number.MIN_SAFE_INTEGER;
/** @internal */
BigDecimal.INFLATED_BIGINT = BigInt(BigDecimal.INFLATED);
/** @internal */
BigDecimal.MAX_INT_VALUE = 2147483647;
/** @internal */
BigDecimal.MIN_INT_VALUE = -2147483648;
/** @internal */
BigDecimal.MAX_COMPACT_DIGITS = 15;
/** @internal */
BigDecimal.ZERO_THROUGH_TEN = [
    new BigDecimal(BigDecimal.zeroBigInt, 0, 0, 1),
    new BigDecimal(BigDecimal.oneBigInt, 1, 0, 1),
    new BigDecimal(BigDecimal.twoBigInt, 2, 0, 1),
    new BigDecimal(BigInt(3), 3, 0, 1),
    new BigDecimal(BigInt(4), 4, 0, 1),
    new BigDecimal(BigInt(5), 5, 0, 1),
    new BigDecimal(BigInt(6), 6, 0, 1),
    new BigDecimal(BigInt(7), 7, 0, 1),
    new BigDecimal(BigInt(8), 8, 0, 1),
    new BigDecimal(BigInt(9), 9, 0, 1),
    new BigDecimal(BigInt(10), 10, 0, 2),
];
/** @internal */
BigDecimal.ZERO = BigDecimal.ZERO_THROUGH_TEN[0];
/** @internal */
BigDecimal.ONE = BigDecimal.ZERO_THROUGH_TEN[1];
/** @internal */
BigDecimal.ZERO_SCALED_BY = [
    BigDecimal.ZERO_THROUGH_TEN[0],
    new BigDecimal(BigDecimal.zeroBigInt, 0, 1, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 2, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 3, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 4, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 5, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 6, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 7, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 8, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 9, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 10, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 11, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 12, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 13, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 14, 1),
    new BigDecimal(BigDecimal.zeroBigInt, 0, 15, 1),
];
/** @internal */
BigDecimal.TEN_POWERS_TABLE = [
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000,
    1000000000,
    10000000000,
    100000000000,
    1000000000000,
    10000000000000,
    100000000000000,
    1000000000000000,
];
/** @internal */
BigDecimal.HALF_NUMBER_MAX_VALUE = Number.MAX_SAFE_INTEGER / 2;
/** @internal */
BigDecimal.HALF_NUMBER_MIN_VALUE = Number.MIN_SAFE_INTEGER / 2;
/** @internal */
BigDecimal.ONE_TENTH = BigDecimal.fromInteger3(1, 1);
/** @internal */
BigDecimal.ONE_HALF = BigDecimal.fromInteger3(5, 1);
/** @internal */
BigDecimal.NUMBER_10_POW = [
    1e0, 1e1, 1e2, 1e3, 1e4, 1e5,
    1e6, 1e7, 1e8, 1e9, 1e10, 1e11,
    1e12, 1e13, 1e14, 1e15
];
/** @internal */
BigDecimal.THRESHOLDS_TABLE = [
    Number.MAX_SAFE_INTEGER,
    Number.MAX_SAFE_INTEGER / 10,
    Number.MAX_SAFE_INTEGER / 100,
    Number.MAX_SAFE_INTEGER / 1000,
    Number.MAX_SAFE_INTEGER / 10000,
    Number.MAX_SAFE_INTEGER / 100000,
    Number.MAX_SAFE_INTEGER / 1000000,
    Number.MAX_SAFE_INTEGER / 10000000,
    Number.MAX_SAFE_INTEGER / 100000000,
    Number.MAX_SAFE_INTEGER / 1000000000,
    Number.MAX_SAFE_INTEGER / 10000000000,
    Number.MAX_SAFE_INTEGER / 100000000000,
    Number.MAX_SAFE_INTEGER / 1000000000000,
    Number.MAX_SAFE_INTEGER / 10000000000000,
    Number.MAX_SAFE_INTEGER / 100000000000000,
    Number.MAX_SAFE_INTEGER / 1000000000000000,
];
/** @internal */
BigDecimal.DIGIT_TENS = [
    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',
    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',
    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',
    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',
    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',
    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',
    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',
    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',
];
/** @internal */
BigDecimal.DIGIT_ONES = [
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
];
/**
 * Constructor function for {@link BigDecimal}. Can be invoked with new or without new.
 *
 * The values passed must match one of Java BigDecimal's constructors, so the valid usages of this function is listed below:
 * ```javascript
 * Big(123n); // bigint, 123
 * Big(123n, 3); // bigint and scale, 0.123
 * Big(123n, 3, MC(2, RoundingMode.HALF_UP)); // bigint, scale and mc, 0.12
 * Big(aBigDecimal) // Copies the BigDecimal passed. "scale" and "mc" arguments will not used.
 * Big(123n, undefined, MC(2, RoundingMode.HALF_UP)); // bigint and mc, 1.2E+2
 * Big('1.13e12'); // string, 1.13E+12
 * Big('1.11e11', undefined, MC(2, RoundingMode.HALF_UP)); // string and mc, 1.1E+11
 * Big(10000); // number, 10000
 * Big(123, 5); // integer and scale, 0.00123
 * Big(1.1233, undefined, MC(2, RoundingMode.HALF_UP)); // number and scale, 1.1
 * ```
 *
 * Sample Usage:
 *```javascript
 * // Single unified constructor for multiple values
 * const { Big } = require('bigdecimal.js');
 *
 * // Construct from a string and clone it
 * const x = Big('1.1111111111111111111111');
 * const y = new Big(x); // you can also use 'new'
 *
 * const z = x.add(y);
 * console.log(z.toString()); // 2.2222222222222222222222
 *
 * // You can also construct from a number or BigInt:
 * const u = Big(1.1);
 * const v = Big(2n);
 *
 * console.log(u.toString()); // 1.1
 * console.log(v.toString()); // 2
 * ```
 *
 * @param n Any value to build a BigDecimal from. Types other than `Number` (as safe integer), `BigInt` and `BigDecimal`
 * will be internally converted to string and parsed.
 * @param scale Scale to use, by default 0.
 * @param mc MathContext object which allows you to set precision and rounding mode.
 * @throws RangeError on following situations:
 * * If value is a number:
 *     * Value is not in the range `[-Number.MAX_VALUE, Number.MAX_VALUE]`
 *     * Both a scale and a math context is provided. You can only give one of scale and math context.
 *       Passing `undefined` is same as omitting an argument.
 *     * If value is a double and scale is given.
 * * If value is not a `safe integer`, a `BigInt` or a `BigDecimal`, it will be converted to string.
 *   An error will be thrown if the string format is invalid.
 * * If value is not a `BigInt` or `number`, and scale is given.
 */
exports.Big = function _Big(n, scale, mc) {
    return BigDecimal.fromValue(n, scale, mc);
};
/**
 * Constructor function for {@link MathContext}. Can be invoked with new or without new.
 *
 * Sample Usage:
 * ```javascript
 * const { Big, MC, RoundingMode } = require('bigdecimal.js');
 *
 * const x = Big('1');
 * const y = Big('3');
 *
 * const res1 = x.divideWithMathContext(y, new MC(3));
 * console.log(res1.toString()); // 0.333
 *
 * // You can also use without `new` operator
 * const res2 = x.divideWithMathContext(y, MC(3, RoundingMode.UP));
 * console.log(res2.toString()); // 0.334
 *
 * try {
 *     x.divide(y);
 *     // throws since full precision is requested but it is not possible
 * } catch (e) {
 *     console.log(e); // RangeError: Non-terminating decimal expansion; no exact representable decimal result.
 * }
 * ```
 *
 * @param precision Precision value
 * @param roundingMode Optional rounding Mode. By default RoundingMode.HALF_UP.
 */
exports.MC = function _MC(precision, roundingMode) {
    return new MathContext(precision, roundingMode);
};
//# sourceMappingURL=bigdecimal.js.map

/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARRAY_TYPE: () => (/* binding */ ARRAY_TYPE),
/* harmony export */   EPSILON: () => (/* binding */ EPSILON),
/* harmony export */   RANDOM: () => (/* binding */ RANDOM),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   setMatrixArrayType: () => (/* binding */ setMatrixArrayType),
/* harmony export */   toRadian: () => (/* binding */ toRadian)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   glMatrix: () => (/* reexport module object */ _common_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   mat2: () => (/* reexport module object */ _mat2_js__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   mat2d: () => (/* reexport module object */ _mat2d_js__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   mat3: () => (/* reexport module object */ _mat3_js__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   mat4: () => (/* reexport module object */ _mat4_js__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   quat: () => (/* reexport module object */ _quat_js__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   quat2: () => (/* reexport module object */ _quat2_js__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   vec2: () => (/* reexport module object */ _vec2_js__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   vec3: () => (/* reexport module object */ _vec3_js__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   vec4: () => (/* reexport module object */ _vec4_js__WEBPACK_IMPORTED_MODULE_9__)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ "./node_modules/gl-matrix/esm/mat2.js");
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ "./node_modules/gl-matrix/esm/mat2d.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ "./node_modules/gl-matrix/esm/quat2.js");
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ "./node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");












/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LDU: () => (/* binding */ LDU),
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2d.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2d.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromMat2d: () => (/* binding */ fromMat2d),
/* harmony export */   fromMat4: () => (/* binding */ fromMat4),
/* harmony export */   fromQuat: () => (/* binding */ fromQuat),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   normalFromMat4: () => (/* binding */ normalFromMat4),
/* harmony export */   projection: () => (/* binding */ projection),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromQuat: () => (/* binding */ fromQuat),
/* harmony export */   fromQuat2: () => (/* binding */ fromQuat2),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromRotationTranslation: () => (/* binding */ fromRotationTranslation),
/* harmony export */   fromRotationTranslationScale: () => (/* binding */ fromRotationTranslationScale),
/* harmony export */   fromRotationTranslationScaleOrigin: () => (/* binding */ fromRotationTranslationScaleOrigin),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   fromXRotation: () => (/* binding */ fromXRotation),
/* harmony export */   fromYRotation: () => (/* binding */ fromYRotation),
/* harmony export */   fromZRotation: () => (/* binding */ fromZRotation),
/* harmony export */   frustum: () => (/* binding */ frustum),
/* harmony export */   getRotation: () => (/* binding */ getRotation),
/* harmony export */   getScaling: () => (/* binding */ getScaling),
/* harmony export */   getTranslation: () => (/* binding */ getTranslation),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   lookAt: () => (/* binding */ lookAt),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   ortho: () => (/* binding */ ortho),
/* harmony export */   orthoNO: () => (/* binding */ orthoNO),
/* harmony export */   orthoZO: () => (/* binding */ orthoZO),
/* harmony export */   perspective: () => (/* binding */ perspective),
/* harmony export */   perspectiveFromFieldOfView: () => (/* binding */ perspectiveFromFieldOfView),
/* harmony export */   perspectiveNO: () => (/* binding */ perspectiveNO),
/* harmony export */   perspectiveZO: () => (/* binding */ perspectiveZO),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   targetTo: () => (/* binding */ targetTo),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   calculateW: () => (/* binding */ calculateW),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   conjugate: () => (/* binding */ conjugate),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   fromEuler: () => (/* binding */ fromEuler),
/* harmony export */   fromMat3: () => (/* binding */ fromMat3),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   getAngle: () => (/* binding */ getAngle),
/* harmony export */   getAxisAngle: () => (/* binding */ getAxisAngle),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   ln: () => (/* binding */ ln),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   rotationTo: () => (/* binding */ rotationTo),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setAxes: () => (/* binding */ setAxes),
/* harmony export */   setAxisAngle: () => (/* binding */ setAxisAngle),
/* harmony export */   slerp: () => (/* binding */ slerp),
/* harmony export */   sqlerp: () => (/* binding */ sqlerp),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.create();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.dot(a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__.len(tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_3__.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat2.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat2.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   conjugate: () => (/* binding */ conjugate),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   fromMat4: () => (/* binding */ fromMat4),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromRotationTranslation: () => (/* binding */ fromRotationTranslation),
/* harmony export */   fromRotationTranslationValues: () => (/* binding */ fromRotationTranslationValues),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   getDual: () => (/* binding */ getDual),
/* harmony export */   getReal: () => (/* binding */ getReal),
/* harmony export */   getTranslation: () => (/* binding */ getTranslation),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   rotateAroundAxis: () => (/* binding */ rotateAroundAxis),
/* harmony export */   rotateByQuatAppend: () => (/* binding */ rotateByQuatAppend),
/* harmony export */   rotateByQuatPrepend: () => (/* binding */ rotateByQuatPrepend),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setDual: () => (/* binding */ setDual),
/* harmony export */   setReal: () => (/* binding */ setReal),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__.create();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__.getRotation(outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   angle: () => (/* binding */ angle),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat2: () => (/* binding */ transformMat2),
/* harmony export */   transformMat2d: () => (/* binding */ transformMat2d),
/* harmony export */   transformMat3: () => (/* binding */ transformMat3),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   angle: () => (/* binding */ angle),
/* harmony export */   bezier: () => (/* binding */ bezier),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   hermite: () => (/* binding */ hermite),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat3: () => (/* binding */ transformMat3),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const gl_utils_1 = __webpack_require__(/*! ./utils/gl-utils */ "./src/utils/gl-utils.ts");
const gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
const UserController_1 = __webpack_require__(/*! ./controllers/UserController */ "./src/controllers/UserController.ts");
const ApiClient_1 = __webpack_require__(/*! ./services/ApiClient */ "./src/services/ApiClient.ts");
const astroobjectdata_json_1 = __importDefault(__webpack_require__(/*! ./config/astroobjectdata.json */ "./src/config/astroobjectdata.json"));
const LODManager_1 = __webpack_require__(/*! ./models/LODManager */ "./src/models/LODManager.ts");
const WebGLShape_1 = __webpack_require__(/*! ./models/WebGLShape */ "./src/models/WebGLShape.ts");
const AstroObject_1 = __webpack_require__(/*! ./models/AstroObject */ "./src/models/AstroObject.ts");
const AstroSystem_1 = __webpack_require__(/*! ./models/AstroSystem */ "./src/models/AstroSystem.ts");
const bVec3 = __importStar(__webpack_require__(/*! ./utils/big-vec3 */ "./src/utils/big-vec3.ts"));
const bigdecimal_js_1 = __webpack_require__(/*! bigdecimal.js */ "./node_modules/bigdecimal.js/lib/bigdecimal.js");
const G = (6.6743 * (10 ** -11));
const vertexShaderSourceCode = `#version 300 es
    precision mediump float;
    
    in vec3 vertexPosition;
    in vec3 vertexColor;

    out vec3 fragmentColor;

    uniform mat4 matWorld;
    uniform mat4 matViewProj;

    void main() {
        fragmentColor = vertexColor;

        gl_Position = matViewProj * matWorld * vec4(vertexPosition, 1.0);
    }`;
const fragmentShaderSourceCode = `#version 300 es
    precision mediump float;
    
    in vec3 fragmentColor;
    out vec4 outputColor;

    void main() {
        outputColor = vec4(fragmentColor, 1.0);
    }`;
let user = new UserController_1.UserController();
function scrollFunc() {
}
let moveForward = false;
let moveBackward = false;
let moveRight = false;
let moveLeft = false;
let moveUp = false;
let moveDown = false;
function keyDown(e) {
    if (user.isMoving == false) {
        user.isMoving = true;
    }
    if (e.code == "KeyW") {
        user.velocity[2] = user.speed;
    }
    if (e.code == "KeyS") {
        user.velocity[2] = -user.speed;
    }
    if (e.code == "KeyD") {
        user.velocity[0] = user.speed;
    }
    if (e.code == "KeyA") {
        user.velocity[0] = -user.speed;
    }
    if (e.code == "Space") {
        user.velocity[1] = user.speed;
    }
    if (e.code == "ControlLeft") {
        user.velocity[1] = -user.speed;
    }
    if (e.code == "KeyB") {
        if (user.speed >= 0.1) {
            user.speed -= 0.1;
        }
        else {
            user.speed -= 0.001;
        }
    }
}
function keyUp(e) {
    if (e.code == "KeyW") {
        user.velocity[2] = 0;
    }
    if (e.code == "KeyS") {
        user.velocity[2] = 0;
    }
    if (e.code == "KeyD") {
        user.velocity[0] = 0;
    }
    if (e.code == "KeyA") {
        user.velocity[0] = 0;
    }
    if (e.code == "Space") {
        user.velocity[1] = 0;
    }
    if (e.code == "ControlLeft") {
        user.velocity[1] = 0;
    }
}
let rotating = false;
function click(e) {
    if (e.button == 1) {
        if (rotating == false) {
            user.setUserOrientation[0] = e.offsetX;
            user.setUserOrientation[1] = e.offsetY;
            user.targetUserOrientation[0] = user.setUserOrientation[0];
            user.targetUserOrientation[1] = user.setUserOrientation[1];
            rotating = true;
        }
    }
}
function click2(e) {
    if (e.button == 1) {
        user.targetUserOrientation[0] = user.setUserOrientation[0];
        user.targetUserOrientation[1] = user.setUserOrientation[1];
        user.rotationVec[0] = 0;
        user.rotationVec[1] = 0;
        rotating = false;
    }
}
function rotateCamera(e) {
    if (rotating == true) {
        user.targetUserOrientation[0] = e.offsetX;
        user.targetUserOrientation[1] = e.offsetY;
        //console.log(user.setUserOrientation[0] - user.targetUserOrientation[0],  user.setUserOrientation[1] - user.targetUserOrientation[1])
        user.rotationVec[0] = e.movementX;
        user.rotationVec[1] = e.movementY;
    }
}
function whee(e) {
    if (e.deltaY <= -100) {
        moveBackward = false;
        moveForward = true;
    }
    if (e.deltaY >= 100) {
        moveForward = false;
        moveBackward = true;
    }
}
async function main() {
    //	var loader = document.querySelector("#loader")!;
    const canvas = document.getElementById('demo-canvas');
    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
        (0, gl_utils_1.showError)('Could not get Canvas reference');
        return;
    }
    var loader = document.querySelector("#loader");
    var divContainerElement = document.querySelector("#divcontainer");
    var dataContainer = document.getElementById("datacontainer");
    var dataContainerName = document.getElementById("datacontainerName");
    var dataContainerPosition = document.getElementById("datacontainerPosition");
    var dataContainerVelocity = document.getElementById("datacontainerVelocity");
    var dataContainerAcceleration = document.getElementById("datacontainerAcceleration");
    window.addEventListener("keydown", keyDown);
    window.addEventListener("keyup", keyUp);
    window.addEventListener("mousedown", click);
    window.addEventListener("mouseup", click2);
    window.addEventListener("mousemove", rotateCamera);
    window.addEventListener("wheel", whee, { passive: false });
    const gl = (0, gl_utils_1.getContext)(canvas);
    const demoProgram = (0, gl_utils_1.createProgram)(gl, vertexShaderSourceCode, fragmentShaderSourceCode);
    if (!demoProgram) {
        (0, gl_utils_1.showError)('Failed to compile WebGL program');
        return;
    }
    const posAttrib = gl.getAttribLocation(demoProgram, 'vertexPosition');
    const colorAttrib = gl.getAttribLocation(demoProgram, 'vertexColor');
    const matWorldUniform = gl.getUniformLocation(demoProgram, 'matWorld');
    const matViewProjUniform = gl.getUniformLocation(demoProgram, 'matViewProj');
    if (posAttrib < 0 || colorAttrib < 0 || !matWorldUniform || !matViewProjUniform) {
        (0, gl_utils_1.showError)(`Failed to get attribs/uniforms: ` +
            `pos=${posAttrib}, color=${colorAttrib} ` +
            `matWorld=${!!matWorldUniform} matViewProj=${!!matViewProjUniform}`);
        return;
    }
    let astroObjectList = await buildAstroObjects(gl, posAttrib, colorAttrib, user);
    let system = new AstroSystem_1.AstroSystem(astroObjectList);
    const matWorld = gl_matrix_1.mat4.create();
    const matView = gl_matrix_1.mat4.create();
    const matProj = gl_matrix_1.mat4.create();
    const loaderText = document.getElementById('loader-text');
    if (loaderText != null) {
        loaderText.style.animationIterationCount = '1';
        loaderText.addEventListener('animationend', (event) => {
            loader.classList.add("loader-overlay--hidden");
        });
    }
    else {
        loader.classList.add("loader-overlay--hidden");
    }
    //loader.classList.add("loader-overlay--hidden");
    let lastFrameTime = performance.now();
    const frame = function () {
        const thisFrameTime = performance.now();
        const dt = (thisFrameTime - lastFrameTime) / 1000;
        // Update system here
        lastFrameTime = thisFrameTime;
        user.translate(dt);
        user.rotate(dt);
        const cameraX = user.userPosition[0];
        const cameraY = user.userPosition[1];
        const cameraZ = user.userPosition[2];
        // Updating system where every second updates a day
        system.updateAstroSystem(dt);
        gl_matrix_1.mat4.lookAt(matView, gl_matrix_1.vec3.fromValues(cameraX, cameraY, cameraZ), gl_matrix_1.vec3.fromValues(user.viewVec[0], user.viewVec[1], user.viewVec[2]), gl_matrix_1.vec3.fromValues(0, 1, 0));
        gl_matrix_1.mat4.perspective(matProj, gl_matrix_1.glMatrix.toRadian(50), canvas.width / canvas.height, 0.001, 100.0);
        const matViewProj = gl_matrix_1.mat4.create();
        gl_matrix_1.mat4.multiply(matViewProj, matProj, matView);
        canvas.width = canvas.clientWidth * devicePixelRatio;
        canvas.height = canvas.clientHeight * devicePixelRatio;
        gl.clearColor(0.0039, 0.0429, 0.0976, 1);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);
        gl.cullFace(gl.BACK);
        gl.frontFace(gl.CCW);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.useProgram(demoProgram);
        gl.uniformMatrix4fv(matViewProjUniform, false, matViewProj);
        system._astroObjectList = system._astroObjectList.sort((a, b) => {
            let bIVecA = bVec3.create();
            let bIVecB = bVec3.create();
            bVec3.scale(bIVecA, a.position, (0, bigdecimal_js_1.Big)("10").pow(-9, new bigdecimal_js_1.MC(20)));
            bVec3.scale(bIVecB, b.position, (0, bigdecimal_js_1.Big)("10").pow(-9, new bigdecimal_js_1.MC(20)));
            let iVecA = gl_matrix_1.vec3.fromValues(Number(bIVecA[0].toBigInt()), Number(bIVecA[1].toBigInt()), Number(bIVecA[2].toBigInt()));
            let iVecB = gl_matrix_1.vec3.fromValues(Number(bIVecB[0].toBigInt()), Number(bIVecB[1].toBigInt()), Number(bIVecB[2].toBigInt()));
            return gl_matrix_1.vec3.distance(user.userPosition, iVecB) - gl_matrix_1.vec3.distance(user.userPosition, iVecA);
        });
        if (user.coupledAstroObject == null) {
            dataContainer.style.visibility = "hidden";
        }
        else {
            dataContainer.style.visibility = "visible";
            dataContainerName.innerHTML = user.coupledAstroObject.name;
            dataContainerPosition.innerHTML = `${user.coupledAstroObject.position[0]}, ${user.coupledAstroObject.position[1]}, ${user.coupledAstroObject.position[2]}`;
            dataContainerVelocity.innerHTML = `${user.coupledAstroObject.velocity[0]}, ${user.coupledAstroObject.velocity[1]}, ${user.coupledAstroObject.velocity[2]}`;
            dataContainerAcceleration.innerHTML = `${user.coupledAstroObject.acceleration[0]}, ${user.coupledAstroObject.acceleration[1]}, ${user.coupledAstroObject.acceleration[2]}`;
        }
        // Here I need to check distance from camera for each item and choose to draw HTML element or 3d model
        let i = 0;
        let retList = system.getDrawList(user.userPosition);
        let v1 = bVec3.create();
        let v2 = bVec3.create();
        system._astroObjectList.forEach((obj) => {
            let bIVecA = bVec3.create();
            bVec3.scale(bIVecA, obj.position, (0, bigdecimal_js_1.Big)("10").pow(-9, new bigdecimal_js_1.MC(20)));
            obj._lodManager.draw(dt, retList.includes(obj), gl, matWorldUniform, gl_matrix_1.vec3.fromValues(Number(bIVecA[0].toEngineeringString()), Number(bIVecA[1].toEngineeringString()), Number(bIVecA[2].toEngineeringString())), matViewProj, i);
            i++;
        });
        requestAnimationFrame(frame);
    };
    requestAnimationFrame(frame);
}
async function buildAstroObjects(gl, posAttrib, colorAttrib, user) {
    let ret = [];
    const api = new ApiClient_1.ApiClient();
    const curEphemeris = await api.getEphemeris(new Date(Date.now()), Object.keys(astroobjectdata_json_1.default));
    var divContainerElement = document.querySelector("#divcontainer");
    const initialData = astroobjectdata_json_1.default;
    Object.entries(initialData).forEach(([key, data]) => {
        // Get WebGLShape
        let size = data.radius / 696349;
        let tilt = data.axialTilt;
        let rSpeed = data.rotationSpeed;
        let shape = new WebGLShape_1.WebGLShape(gl_matrix_1.vec3.create(), size, gl_matrix_1.vec3.fromValues(0, 1, 0), gl_matrix_1.glMatrix.toRadian(0), tilt, rSpeed, gl, posAttrib, colorAttrib);
        let lodManager = new LODManager_1.LODManager(shape, divContainerElement, data.name, user);
        let x0 = (0, bigdecimal_js_1.Big)((curEphemeris[key].xPos).toString()).multiply((0, bigdecimal_js_1.Big)("10").pow((curEphemeris[key].xPosExpn), new bigdecimal_js_1.MC(20)));
        let y0 = (0, bigdecimal_js_1.Big)((curEphemeris[key].yPos).toString()).multiply((0, bigdecimal_js_1.Big)("10").pow((curEphemeris[key].yPosExpn), new bigdecimal_js_1.MC(20)));
        let z0 = (0, bigdecimal_js_1.Big)((curEphemeris[key].zPos).toString()).multiply((0, bigdecimal_js_1.Big)("10").pow((curEphemeris[key].zPosExpn), new bigdecimal_js_1.MC(20)));
        let position = bVec3.fromValues(x0.toString(), z0.toString(), y0.negate().toString());
        bVec3.scale(position, position, (0, bigdecimal_js_1.Big)("1000"));
        let xV0 = (0, bigdecimal_js_1.Big)((curEphemeris[key].xVel).toString()).multiply((0, bigdecimal_js_1.Big)("10").pow((curEphemeris[key].xVelExpn), new bigdecimal_js_1.MC(20)));
        let yV0 = (0, bigdecimal_js_1.Big)((curEphemeris[key].yVel).toString()).multiply((0, bigdecimal_js_1.Big)("10").pow((curEphemeris[key].yVelExpn), new bigdecimal_js_1.MC(20)));
        let zV0 = (0, bigdecimal_js_1.Big)((curEphemeris[key].zVel).toString()).multiply((0, bigdecimal_js_1.Big)("10").pow((curEphemeris[key].zVelExpn), new bigdecimal_js_1.MC(20)));
        let velocity = bVec3.fromValues(xV0.toString(), zV0.toString(), yV0.negate().toString());
        bVec3.scale(velocity, velocity, (0, bigdecimal_js_1.Big)("1000"));
        let acceleration = bVec3.create();
        let name = data.name;
        let mass = (0, bigdecimal_js_1.Big)(eval(data.mass).toString());
        let pRadius = 1;
        let eRadius = 1;
        let astroObject = new AstroObject_1.AstroObject(position, velocity, acceleration, name, mass, data.systemSpace, data.subsystem, pRadius, eRadius, lodManager);
        astroObject._lodManager.setAstroObject(astroObject);
        //let newObj = new AstroObject(position, velocity, acceleration, name, mass, pRadius, eRadius, lodManager);
        ret.push(astroObject);
    });
    return ret;
}
try {
    main();
    // Initialize UserController
    // Initialize AstroObjects
    // Initialize AstroSystem
    //
}
catch (e) {
    (0, gl_utils_1.showError)(`Unhandled JavaScript exception: ${e}`);
}


/***/ }),

/***/ "./src/config/astroobjectdata.json":
/*!*****************************************!*\
  !*** ./src/config/astroobjectdata.json ***!
  \*****************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"10":{"name":"Sun","mass":"(1.99 * (10**30))","radius":696349,"axialTilt":0.1265364,"rotationSpeed":0,"systemSpace":40000,"subsystem":["Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune","Ceres","Pluto","Haumea","Makemake","Eris"]},"199":{"name":"Mercury","mass":"(3.285 * (10**23))","radius":2439.7,"axialTilt":0.00047,"rotationSpeed":0.0000175,"systemSpace":0,"subsystem":[]},"299":{"name":"Venus","mass":"(48.685 * (10**23))","radius":6051.8,"axialTilt":3.0962,"rotationSpeed":2.99e-7,"systemSpace":0,"subsystem":[]},"301":{"name":"Luna","mass":"(7.3476 * (10**22))","radius":1737.4,"axialTilt":0.0261,"rotationSpeed":0.00000266,"systemSpace":0,"subsystem":[]},"399":{"name":"Earth","mass":"(6 * (10**24))","radius":6378.14,"axialTilt":0.4101,"rotationSpeed":0.0000729,"systemSpace":20,"subsystem":["Luna"]},"401":{"name":"Phobos","mass":"(1.06 * (10**16))","radius":11.267,"axialTilt":0,"rotationSpeed":0.00645,"systemSpace":0,"subsystem":[]},"402":{"name":"Deimos","mass":"(1.51 * (10**15))","radius":6.2,"axialTilt":0.0349,"rotationSpeed":0.03979,"systemSpace":0,"subsystem":[]},"499":{"name":"Mars","mass":"(6.4191 * (10**22))","radius":3389.5,"axialTilt":0.436332,"rotationSpeed":0.004398,"systemSpace":0.8,"subsystem":["Phobos","Deimos"]},"599":{"name":"Jupiter","mass":"(1.898 * (10**27))","radius":71492,"axialTilt":0.05462,"rotationSpeed":0.000176,"systemSpace":0,"subsystem":[]},"699":{"name":"Saturn","mass":"(5.683 * (10**26))","radius":58232,"axialTilt":0.46635,"rotationSpeed":0.000103,"systemSpace":0,"subsystem":[]},"799":{"name":"Uranus","mass":"(8.681 * (10**25))","radius":25362,"axialTilt":1.7069,"rotationSpeed":0.00010124,"systemSpace":0,"subsystem":[]},"899":{"name":"Neptune","mass":"(1.0241 * (10 ** 26))","radius":24622,"axialTilt":0.494277,"rotationSpeed":0.0000307,"systemSpace":0,"subsystem":[]},"999":{"name":"Pluto","mass":"(1.307 * (10**22))","radius":1188.3,"axialTilt":2.0944,"rotationSpeed":0.0000179,"systemSpace":0,"subsystem":[]},"920136108":{"name":"Haumea","mass":"(4.01 * (10**21))","radius":816,"axialTilt":2.19911,"rotationSpeed":0.00044575,"systemSpace":0,"subsystem":[]},"920136199":{"name":"Eris","mass":"(1.67 * (10**22))","radius":1163,"axialTilt":0.767945,"rotationSpeed":0.000434,"systemSpace":0,"subsystem":[]},"Ceres":{"name":"Ceres","mass":"(9.3839 * (10**20))","radius":473,"axialTilt":0.06981,"rotationSpeed":0.0000616,"systemSpace":0,"subsystem":[]},"Makemake":{"name":"Makemake","mass":"(3.1 * (10**21))","radius":715,"axialTilt":0,"rotationSpeed":0.0000423,"systemSpace":0,"subsystem":[]}}');

/***/ }),

/***/ "./src/config/config.ts":
/*!******************************!*\
  !*** ./src/config/config.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = void 0;
exports.config = {
    apiUrl: "http://localhost:8000",
    environment: "development"
};


/***/ }),

/***/ "./src/controllers/UserController.ts":
/*!*******************************************!*\
  !*** ./src/controllers/UserController.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserController = void 0;
const gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
const bVec3 = __importStar(__webpack_require__(/*! ../utils/big-vec3 */ "./src/utils/big-vec3.ts"));
class UserController {
    constructor() {
        this.userPosition = gl_matrix_1.vec3.fromValues(0, 0, 10000);
        this.velocity = gl_matrix_1.vec3.fromValues(0, 0, 0);
        this.userOrientation = gl_matrix_1.vec3.fromValues(0, -90, 0);
        this.viewVec = gl_matrix_1.vec3.fromValues(0, 0, -1);
        this.setUserOrientation = gl_matrix_1.vec3.fromValues(0, 0, 0);
        this.targetUserOrientation = gl_matrix_1.vec3.fromValues(0, 0, 0);
        this.rotationVec = gl_matrix_1.vec3.fromValues(0, 0, 0);
        this.isMoving = false;
        this.speed = 10000;
        this.coupledAstroObject = null;
    }
    translate(dt) {
        let movementVec = gl_matrix_1.vec3.fromValues(0, 0, 0);
        let curSpeed = this._getCurSpeed() * dt;
        //console.log(curSpeed);
        if (this.velocity[2] > 0) {
            if (this.coupledAstroObject != null) {
                let iVec = gl_matrix_1.vec3.create();
                let tVec = bVec3.getScaledVec3(this.coupledAstroObject.position, 10, -9);
                gl_matrix_1.vec3.subtract(iVec, tVec, this.userPosition);
                gl_matrix_1.vec3.normalize(iVec, iVec);
                gl_matrix_1.vec3.scale(movementVec, iVec, curSpeed);
            }
            else {
                gl_matrix_1.vec3.scale(movementVec, gl_matrix_1.vec3.fromValues(Math.cos(gl_matrix_1.glMatrix.toRadian(this.userOrientation[1])), 0, Math.sin(gl_matrix_1.glMatrix.toRadian(this.userOrientation[1]))), curSpeed);
            }
        }
        else if (this.velocity[2] < 0) {
            if (this.coupledAstroObject != null) {
                let iVec = gl_matrix_1.vec3.create();
                let tVec = bVec3.getScaledVec3(this.coupledAstroObject.position, 10, -9);
                gl_matrix_1.vec3.subtract(iVec, tVec, this.userPosition);
                gl_matrix_1.vec3.normalize(iVec, iVec);
                gl_matrix_1.vec3.scale(movementVec, iVec, -curSpeed);
            }
            else {
                gl_matrix_1.vec3.scale(movementVec, gl_matrix_1.vec3.fromValues(Math.cos(gl_matrix_1.glMatrix.toRadian(this.userOrientation[1])), 0, Math.sin(gl_matrix_1.glMatrix.toRadian(this.userOrientation[1]))), -curSpeed);
            }
        }
        if (this.velocity[0] > 0) {
            if (this.coupledAstroObject != null) {
                let iVec = gl_matrix_1.vec3.create();
                let tVec = bVec3.getScaledVec3(this.coupledAstroObject.position, 10, -9);
                let qVec = gl_matrix_1.vec3.create();
                let cVec = gl_matrix_1.vec3.fromValues(0, 1, 0);
                gl_matrix_1.vec3.subtract(iVec, tVec, this.userPosition);
                gl_matrix_1.vec3.cross(qVec, cVec, iVec);
                gl_matrix_1.vec3.normalize(qVec, qVec);
                gl_matrix_1.vec3.scale(movementVec, qVec, -curSpeed);
            }
            else {
                gl_matrix_1.vec3.scale(movementVec, gl_matrix_1.vec3.fromValues(Math.cos(gl_matrix_1.glMatrix.toRadian(90 + this.userOrientation[1])), 0, Math.sin(gl_matrix_1.glMatrix.toRadian(90 + this.userOrientation[1]))), curSpeed);
            }
        }
        else if (this.velocity[0] < 0) {
            if (this.coupledAstroObject != null) {
                let iVec = gl_matrix_1.vec3.create();
                let tVec = bVec3.getScaledVec3(this.coupledAstroObject.position, 10, -9);
                let qVec = gl_matrix_1.vec3.create();
                let cVec = gl_matrix_1.vec3.fromValues(0, 1, 0);
                gl_matrix_1.vec3.subtract(iVec, tVec, this.userPosition);
                gl_matrix_1.vec3.cross(qVec, cVec, iVec);
                gl_matrix_1.vec3.normalize(qVec, qVec);
                gl_matrix_1.vec3.scale(movementVec, qVec, curSpeed);
            }
            else {
                gl_matrix_1.vec3.scale(movementVec, gl_matrix_1.vec3.fromValues(Math.cos(gl_matrix_1.glMatrix.toRadian(90 + this.userOrientation[1])), 0, Math.sin(gl_matrix_1.glMatrix.toRadian(90 + this.userOrientation[1]))), -curSpeed);
            }
        }
        if (this.velocity[1] > 0) {
            if (this.coupledAstroObject != null) {
                let iVec = gl_matrix_1.vec3.create();
                let tVec = bVec3.getScaledVec3(this.coupledAstroObject.position, 10, -9);
                let qVec = gl_matrix_1.vec3.create();
                let cVec = gl_matrix_1.vec3.fromValues(0, 1, 0);
                gl_matrix_1.vec3.subtract(iVec, tVec, this.userPosition);
                gl_matrix_1.vec3.cross(qVec, cVec, iVec);
                gl_matrix_1.vec3.cross(cVec, qVec, iVec);
                gl_matrix_1.vec3.normalize(cVec, cVec);
                gl_matrix_1.vec3.scale(movementVec, cVec, -curSpeed);
            }
            else {
                gl_matrix_1.vec3.scale(movementVec, gl_matrix_1.vec3.fromValues(0, 1, 0), curSpeed);
            }
        }
        else if (this.velocity[1] < 0) {
            if (this.coupledAstroObject != null) {
                let iVec = gl_matrix_1.vec3.create();
                let tVec = bVec3.getScaledVec3(this.coupledAstroObject.position, 10, -9);
                let qVec = gl_matrix_1.vec3.create();
                let cVec = gl_matrix_1.vec3.fromValues(0, 1, 0);
                gl_matrix_1.vec3.subtract(iVec, tVec, this.userPosition);
                gl_matrix_1.vec3.cross(qVec, cVec, iVec);
                gl_matrix_1.vec3.cross(cVec, qVec, iVec);
                gl_matrix_1.vec3.normalize(cVec, cVec);
                gl_matrix_1.vec3.scale(movementVec, cVec, curSpeed);
            }
            else {
                gl_matrix_1.vec3.scale(movementVec, gl_matrix_1.vec3.fromValues(0, 1, 0), -curSpeed);
            }
        }
        gl_matrix_1.vec3.add(this.userPosition, this.userPosition, movementVec); //(vec3.scale(this.velocity, this.velocity, dt)))
    }
    rotate(dt) {
        //this.userOrientation[0] += 1
        // console.log(this.setUserOrientation[0], this.targetUserOrientation[0])
        if (this.coupledAstroObject == null) {
            let d = Math.sqrt((this.targetUserOrientation[0] - this.setUserOrientation[0]) ** 2 + (this.targetUserOrientation[1] - this.setUserOrientation[1]) ** 2);
            if (d >= 5) {
                let newX = this.setUserOrientation[0] + (10 / d) * (this.targetUserOrientation[0] - this.setUserOrientation[0]);
                let newY = this.setUserOrientation[1] + (10 / d) * (this.targetUserOrientation[1] - this.setUserOrientation[1]);
                //console.log(this.userOrientation[0], this.userOrientation[1])
                this.userOrientation[1] -= (newX - this.setUserOrientation[0]) / 5;
                this.userOrientation[0] += (newY - this.setUserOrientation[1]) / 5;
                /*
                        cameraX+(Math.cos(glMatrix.toRadian(user.userOrientation[0]))*Math.cos(glMatrix.toRadian(user.userOrientation[1])))
                    cameraY+Math.sin(glMatrix.toRadian(user.userOrientation[0]))
                    cameraZ+(Math.cos(glMatrix.toRadian(user.userOrientation[0]))*Math.sin(glMatrix.toRadian(user.userOrientation[1])))
            */
                //this.viewVec[0] = this.userPosition[0]+(Math.cos(glMatrix.toRadian(this.userOrientation[0]))*Math.cos(glMatrix.toRadian(this.userOrientation[1]))) 
                //this.viewVec[1] = this.userPosition[1]+Math.sin(glMatrix.toRadian(this.userOrientation[0]))
                //this.viewVec[2] = this.userPosition[2]+(Math.cos(glMatrix.toRadian(this.userOrientation[0]))*Math.sin(glMatrix.toRadian(this.userOrientation[1])))
                this.setUserOrientation[0] = newX;
                this.setUserOrientation[1] = newY;
            }
            else {
                this.targetUserOrientation[0] = this.setUserOrientation[0];
                this.targetUserOrientation[1] = this.setUserOrientation[1];
            }
            this.viewVec[0] = this.userPosition[0] + (Math.cos(gl_matrix_1.glMatrix.toRadian(this.userOrientation[0])) * Math.cos(gl_matrix_1.glMatrix.toRadian(this.userOrientation[1])));
            this.viewVec[1] = this.userPosition[1] + Math.sin(gl_matrix_1.glMatrix.toRadian(this.userOrientation[0]));
            this.viewVec[2] = this.userPosition[2] + (Math.cos(gl_matrix_1.glMatrix.toRadian(this.userOrientation[0])) * Math.sin(gl_matrix_1.glMatrix.toRadian(this.userOrientation[1])));
        }
        else {
            let i1 = bVec3.getScaledVec3(this.coupledAstroObject.position, 10, -9);
            gl_matrix_1.vec3.subtract(this.viewVec, i1, this.userPosition);
            gl_matrix_1.vec3.add(this.viewVec, this.viewVec, this.userPosition);
            let tVec = gl_matrix_1.vec3.create();
            gl_matrix_1.vec3.normalize(tVec, this.viewVec);
            let theta = Math.asin(tVec[0]);
            let phi = Math.asin((tVec[1]) / Math.cos(theta));
            this.userOrientation[0] = (theta * 180) / Math.PI;
            this.userOrientation[1] = (phi * 180) / Math.PI;
        }
    }
    setCoupledAstroObject(obj) {
        this.coupledAstroObject = obj;
        //console.log(`Coupled object set to ${obj.name}`);
    }
    _getCurSpeed() {
        let curSpeed = this.speed;
        if (this.coupledAstroObject != null) {
            let scaledObjPos = bVec3.getScaledVec3(this.coupledAstroObject.position, 10, -9);
            let dist = gl_matrix_1.vec3.distance(this.userPosition, scaledObjPos);
            let posSpeed = 100000000;
            curSpeed = dist;
            console.log("curSpeed:", curSpeed, dist);
        }
        return curSpeed;
    }
}
exports.UserController = UserController;


/***/ }),

/***/ "./src/geometry.ts":
/*!*************************!*\
  !*** ./src/geometry.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TABLE_INDICES = exports.TABLE_VERTICES = exports.CUBE_INDICES = exports.CUBE_VERTICES = exports.PYRAMID_INDICES = exports.PYRAMID_VERTICES = exports.SPHERE_VERTICES = exports.Sphere = void 0;
exports.create3dPosColorInterleavedVao = create3dPosColorInterleavedVao;
const gl_utils_1 = __webpack_require__(/*! ./utils/gl-utils */ "./src/utils/gl-utils.ts");
// Iterate through each sector
// Iterate through each stack
// Get x, y, and z values. Need to tie them together to create faces
class Vertex {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
class Sphere {
    constructor(stacks, sectors, xScalar, yScalar) {
        let verticesSize = (6 * 3 * sectors) + (6 * 3 * sectors) + (6 * 4 * sectors * (stacks - 2));
        let indicesSize = (3 * sectors) + (3 * sectors) + (6 * sectors * (stacks - 2)); // need to add extra for bottom indices/vertices
        this.vertices = new Float32Array(verticesSize);
        this.indices = new Uint16Array(indicesSize);
        let verts = [];
        this.calculateVertices(verts, stacks, sectors, xScalar, yScalar);
        // link top
        let m = 0;
        let n = 0;
        let l = 0;
        let q = 0;
        while (l < verts[0].length) {
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 1.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 1.0;
            this.indices[q] = q;
            q++;
            this.vertices[m++] = verts[0][n].x;
            this.vertices[m++] = verts[0][n].y;
            this.vertices[m++] = verts[0][n].z;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 1.0;
            this.indices[q] = q;
            q++;
            if (n + 1 >= verts[0].length) {
                n = 0;
            }
            else {
                n++;
            }
            this.vertices[m++] = verts[0][n].x;
            this.vertices[m++] = verts[0][n].y;
            this.vertices[m++] = verts[0][n].z;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 1.0;
            this.indices[q] = q;
            q++;
            l++;
        }
        let tracker = q;
        for (let k = 0; k < verts.length - 1; k++) {
            for (let n = 0; n < verts[k].length; n++) {
                let tempN = n;
                if (tempN + 1 >= verts[k].length) {
                    tempN = -1;
                }
                this.vertices[m++] = verts[k][n].x; // left corner
                this.vertices[m++] = verts[k][n].y;
                this.vertices[m++] = verts[k][n].z;
                this.vertices[m++] = 1.0;
                this.vertices[m++] = 0.0;
                this.vertices[m++] = 0.0;
                this.indices[q] = tracker;
                tracker++;
                q++;
                this.vertices[m++] = verts[k][tempN + 1].x; // right corner
                this.vertices[m++] = verts[k][tempN + 1].y;
                this.vertices[m++] = verts[k][tempN + 1].z;
                this.vertices[m++] = 1.0;
                this.vertices[m++] = 0.0;
                this.vertices[m++] = 0.0;
                let rightCornerIndex = tracker;
                this.indices[q] = rightCornerIndex;
                tracker++;
                q++;
                this.vertices[m++] = verts[k + 1][n].x; // bottom left corner
                this.vertices[m++] = verts[k + 1][n].y;
                this.vertices[m++] = verts[k + 1][n].z;
                this.vertices[m++] = 0.0;
                this.vertices[m++] = 1.0;
                this.vertices[m++] = 0.0;
                let bottomLeftCornerIndex = tracker;
                this.indices[q] = bottomLeftCornerIndex;
                tracker++;
                q++;
                this.indices[q] = rightCornerIndex;
                q++;
                this.indices[q] = bottomLeftCornerIndex;
                q++;
                this.vertices[m++] = verts[k + 1][tempN + 1].x; // bottom right corner
                this.vertices[m++] = verts[k + 1][tempN + 1].y;
                this.vertices[m++] = verts[k + 1][tempN + 1].z;
                this.vertices[m++] = 0.0;
                this.vertices[m++] = 0.0;
                this.vertices[m++] = 1.0;
                this.indices[q] = tracker;
                tracker++;
                q++;
            }
        }
        l = 0;
        console.log(verts[verts.length - 1]);
        while (l < verts[verts.length - 1].length) {
            this.vertices[m++] = 0.0;
            this.vertices[m++] = -1.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 1.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 0.0;
            this.indices[q] = tracker;
            tracker++;
            q++;
            this.vertices[m++] = verts[verts.length - 1][n].x;
            this.vertices[m++] = verts[verts.length - 1][n].y;
            this.vertices[m++] = verts[verts.length - 1][n].z;
            this.vertices[m++] = 1.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 0.0;
            this.indices[q] = tracker;
            tracker++;
            q++;
            if (n + 1 >= verts[0].length) {
                n = 0;
            }
            else {
                n++;
            }
            this.vertices[m++] = verts[verts.length - 1][n].x;
            this.vertices[m++] = verts[verts.length - 1][n].y;
            this.vertices[m++] = verts[verts.length - 1][n].z;
            this.vertices[m++] = 1.0;
            this.vertices[m++] = 0.0;
            this.vertices[m++] = 0.0;
            this.indices[q] = tracker;
            tracker++;
            q++;
            l++;
            console.log(m);
        }
        // link middle
        // link bottom\
        console.log(this.vertices);
        console.log(this.indices);
    }
    calculateVertices(verts, stacks, sectors, xScalar, yScalar) {
        let stackStep = 180 / stacks;
        let sectorStep = 360 / sectors;
        let i = 0;
        let theta = stackStep;
        let thetaRadians;
        let phi;
        let phiRadians;
        let x, y, z;
        while (theta < 180) {
            verts[i] = [];
            phi = 0;
            thetaRadians = (90 - theta) * Math.PI / 180;
            y = yScalar * Math.sin(thetaRadians);
            let tempX = xScalar * Math.cos(thetaRadians);
            while (phi < 360) {
                phiRadians = phi * Math.PI / 180;
                x = tempX * Math.cos(phiRadians);
                z = tempX * Math.sin(phiRadians);
                verts[i].push(new Vertex(x, y, z));
                phi += sectorStep;
            }
            theta += stackStep;
            i++;
        }
    }
}
exports.Sphere = Sphere;
exports.SPHERE_VERTICES = new Float32Array([
    0, 1, 0 // Top point
]);
exports.PYRAMID_VERTICES = new Float32Array([
    1.0, -1.0, 1.0, 1, 0, 0,
    -1.0, -1.0, 1.0, 1, 0, 0,
    0.0, 1.0, 0.0, 1, 0, 0, // front
    -1.0, -1.0, 1.0, 0, 1, 0,
    -1.0, -1.0, -1.0, 0, 1, 0,
    0.0, 1.0, 0.0, 0, 1, 0, // left
    1.0, -1.0, 1.0, 0, 0, 1,
    1.0, -1.0, -1.0, 0, 0, 1,
    0.0, 1.0, 0.0, 0, 0, 1, // right
    1.0, -1.0, -1.0, 1, 0, 0,
    -1.0, -1.0, -1.0, 1, 0, 0,
    0.0, 1.0, 0.0, 1, 0, 0, // back
    -1.0, -1.0, -1.0, 0, 1, 0,
    1.0, -1.0, -1.0, 0, 1, 0,
    1.0, -1.0, 1.0, 0, 1, 0,
    -1.0, -1.0, 1.0, 0, 1, 0, // bottom
]);
exports.PYRAMID_INDICES = new Uint16Array([
    0, 1, 2,
    3, 4, 5,
    6, 7, 8,
    9, 10, 11,
    12, 13, 14,
    12, 14, 15, // bottom
]);
exports.CUBE_VERTICES = new Float32Array([
    -1.0, -1.0, 1.0, 1, 0, 0,
    1.0, -1.0, 1.0, 1, 0, 0,
    1.0, 1.0, 1.0, 1, 0, 0,
    -1.0, 1.0, 1.0, 1, 0, 0,
    // Back face
    -1.0, -1.0, -1.0, 1, 0, 0,
    -1.0, 1.0, -1.0, 1, 0, 0,
    1.0, 1.0, -1.0, 1, 0, 0,
    1.0, -1.0, -1.0, 1, 0, 0,
    // Top face
    -1.0, 1.0, -1.0, 0, 1, 0,
    -1.0, 1.0, 1.0, 0, 1, 0,
    1.0, 1.0, 1.0, 0, 1, 0,
    1.0, 1.0, -1.0, 0, 1, 0,
    // Bottom face
    -1.0, -1.0, -1.0, 0, 1, 0,
    1.0, -1.0, -1.0, 0, 1, 0,
    1.0, -1.0, 1.0, 0, 1, 0,
    -1.0, -1.0, 1.0, 0, 1, 0,
    // Right face
    1.0, -1.0, -1.0, 0, 0, 1,
    1.0, 1.0, -1.0, 0, 0, 1,
    1.0, 1.0, 1.0, 0, 0, 1,
    1.0, -1.0, 1.0, 0, 0, 1,
    // Left face
    -1.0, -1.0, -1.0, 0, 0, 1,
    -1.0, -1.0, 1.0, 0, 0, 1,
    -1.0, 1.0, 1.0, 0, 0, 1,
    -1.0, 1.0, -1.0, 0, 0, 1,
]);
exports.CUBE_INDICES = new Uint16Array([
    0, 1, 2,
    0, 2, 3, // front
    4, 5, 6,
    4, 6, 7, // back
    8, 9, 10,
    8, 10, 11, // top
    12, 13, 14,
    12, 14, 15, // bottom
    16, 17, 18,
    16, 18, 19, // right
    20, 21, 22,
    20, 22, 23, // left
]);
exports.TABLE_VERTICES = new Float32Array([
    // Top face
    -10.0, 0.0, -10.0, 0.2, 0.2, 0.2,
    -10.0, 0.0, 10.0, 0.2, 0.2, 0.2,
    10.0, 0.0, 10.0, 0.2, 0.2, 0.2,
    10.0, 0.0, -10.0, 0.2, 0.2, 0.2,
]);
exports.TABLE_INDICES = new Uint16Array([
    0, 1, 2,
    0, 2, 3, // top
]);
function create3dPosColorInterleavedVao(gl, vertexBuffer, indexBuffer, posAttrib, colorAttrib) {
    const vao = gl.createVertexArray();
    if (!vao) {
        (0, gl_utils_1.showError)('Failed to create VAO');
        return null;
    }
    gl.bindVertexArray(vao);
    gl.enableVertexAttribArray(posAttrib);
    gl.enableVertexAttribArray(colorAttrib);
    // Interleaved format: (x, y, z, r, g, b) (all f32)
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(posAttrib, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);
    gl.vertexAttribPointer(colorAttrib, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    return vao;
}


/***/ }),

/***/ "./src/models/AstroObject.ts":
/*!***********************************!*\
  !*** ./src/models/AstroObject.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AstroObject = void 0;
const bigdecimal_js_1 = __webpack_require__(/*! bigdecimal.js */ "./node_modules/bigdecimal.js/lib/bigdecimal.js");
const bVec3 = __importStar(__webpack_require__(/*! ../utils/big-vec3 */ "./src/utils/big-vec3.ts"));
class AstroObject {
    constructor(position, velocity, acceleration, name, mass, systemSpace, subsystem, _polarRadius, _equatorialRadius, _lodManager) {
        this.position = position;
        this.velocity = velocity;
        this.acceleration = acceleration;
        this.name = name;
        this.mass = mass;
        this.systemSpace = systemSpace;
        this.subsystem = subsystem;
        this._polarRadius = _polarRadius;
        this._equatorialRadius = _equatorialRadius;
        this._lodManager = _lodManager;
    }
    updatePhysics(dt) {
        this._updatePosition(dt);
        this._updateVelocity(dt);
    }
    // Updates AstroObject position based on change of time and acceleration
    _updatePosition(dt) {
        const DT = (0, bigdecimal_js_1.Big)(dt.toString());
        let v0 = bVec3.create();
        bVec3.scale(v0, this.velocity, DT);
        let r0 = bVec3.create();
        bVec3.add(r0, this.position, v0);
        let a0 = bVec3.create();
        let aScale = (0, bigdecimal_js_1.Big)("0.5").multiply(DT);
        bVec3.scale(a0, this.acceleration, aScale);
        bVec3.add(this.position, r0, a0);
    }
    _updateVelocity(dt) {
        const DT = (0, bigdecimal_js_1.Big)(dt.toString());
        // Intermediate vec3's to copy vec3 operations into
        let i1 = bVec3.create();
        // Copy initial velocity values
        let v0 = bVec3.create();
        bVec3.copy(v0, this.velocity);
        // Set new velocity
        bVec3.scale(i1, this.acceleration, DT);
        bVec3.add(this.velocity, v0, i1);
    }
}
exports.AstroObject = AstroObject;


/***/ }),

/***/ "./src/models/AstroSystem.ts":
/*!***********************************!*\
  !*** ./src/models/AstroSystem.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AstroSystem = void 0;
const bigdecimal_js_1 = __webpack_require__(/*! bigdecimal.js */ "./node_modules/bigdecimal.js/lib/bigdecimal.js");
const bVec3 = __importStar(__webpack_require__(/*! ../utils/big-vec3 */ "./src/utils/big-vec3.ts"));
// Gravitational constant in m^3*kg^-1*s^-2
const G = (6.6743 * (10 ** -11));
// This handles physics for an entire Astronomical system
// Examples would be The Solar System and Alpha Centauri.
class AstroSystem {
    constructor(_astroObjectList) {
        this._astroObjectList = _astroObjectList;
    }
    // Calculates new acceleration values due to gravity and computes new positions of each astro object in the system
    updateAstroSystem(dt) {
        this._computeGravityVectors();
        const tft = performance.now();
        for (const astroObject of this._astroObjectList) {
            astroObject.updatePhysics(dt);
        }
        console.log((performance.now() - tft) / 1000);
    }
    _computeGravityVectors() {
        // Zero out every AstroObject's acceleration
        for (const astroObject of this._astroObjectList) {
            bVec3.zero(astroObject.acceleration);
        }
        // Recalculate the acceleration due to gravity for every AstroObject in the system
        // The invariant is that the gravity is completely calculated for every AstroObject to the left of i
        for (let i = 0; i < (this._astroObjectList.length - 1); i++) {
            for (let j = (i + 1); j < this._astroObjectList.length; j++) {
                let gravityAccelI = bVec3.create();
                let gravityAccelJ = bVec3.create();
                // Find directional vectors for the force of gravity between the 2 AstroObjects
                bVec3.subtract(gravityAccelI, this._astroObjectList[j].position, this._astroObjectList[i].position);
                bVec3.negate(gravityAccelJ, gravityAccelI);
                // Normalize the directional vectors
                bVec3.normalize(gravityAccelI, gravityAccelI);
                bVec3.normalize(gravityAccelJ, gravityAccelJ);
                const sqDistance = bVec3.distance(this._astroObjectList[i].position, this._astroObjectList[j].position);
                // Calculate the magnitude of the force of gravity for both objects				
                const gMagI = ((0, bigdecimal_js_1.Big)(G.toString()).multiply(this._astroObjectList[j].mass)).divide(sqDistance.pow(2), 20, bigdecimal_js_1.RoundingMode.CEILING);
                const gMagJ = ((0, bigdecimal_js_1.Big)(G.toString()).multiply(this._astroObjectList[i].mass)).divide(sqDistance.pow(2), 20, bigdecimal_js_1.RoundingMode.CEILING);
                bVec3.scale(gravityAccelI, gravityAccelI, gMagI);
                bVec3.scale(gravityAccelJ, gravityAccelJ, gMagJ);
                // Compound acceleration due to gravity for both objects to get their overall acceleration
                bVec3.add(this._astroObjectList[i].acceleration, this._astroObjectList[i].acceleration, gravityAccelI);
                bVec3.add(this._astroObjectList[j].acceleration, this._astroObjectList[j].acceleration, gravityAccelJ);
            }
        }
    }
    getDrawList(userPosition) {
        let evalList = [];
        for (let k = 0; k < this._astroObjectList.length; k++) {
            if (this._astroObjectList[k].name == "Sun") {
                evalList.push(this._astroObjectList[k]);
            }
        }
        let retList = [];
        while (evalList.length != 0) {
            retList.push(evalList.shift());
            let v = bVec3.create();
            bVec3.scale(v, retList[retList.length - 1].position, (0, bigdecimal_js_1.Big)("10").pow(-9, new bigdecimal_js_1.MC(20)));
            if ((0, bigdecimal_js_1.Big)((retList[retList.length - 1].systemSpace).toString()).greaterThan(bVec3.distance(bVec3.fromValues(userPosition[0].toString(), userPosition[1].toString(), userPosition[2].toString()), v))) {
                for (let i = 0; i < this._astroObjectList.length; i++) {
                    for (let j = 0; j < retList[retList.length - 1].subsystem.length; j++) {
                        if (retList[retList.length - 1].subsystem[j] == this._astroObjectList[i].name) {
                            evalList.push(this._astroObjectList[i]);
                        }
                    }
                }
            }
        }
        console.log(retList);
        return retList;
    }
}
exports.AstroSystem = AstroSystem;


/***/ }),

/***/ "./src/models/LODManager.ts":
/*!**********************************!*\
  !*** ./src/models/LODManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LODManager = void 0;
const gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
class LODManager {
    constructor(_shape, divContainerElement, name, userController) {
        this._shape = _shape;
        this.userController = userController;
        this._div = document.createElement("div");
        if (name == "Sun") {
            this._div.className = "sun";
        }
        else {
            this._div.className = "planet";
        }
        let txt = document.createElement("div");
        txt.className = "text-node";
        let dot = document.createElement("div");
        let textNode = document.createTextNode(name);
        txt.appendChild(textNode);
        this._div.appendChild(txt);
        divContainerElement.appendChild(this._div);
        this.astroObject = null;
    }
    setAstroObject(ast) {
        this.astroObject = ast;
        let that = this;
        this._div.onclick = function () { if (that.astroObject != null) {
            that.userController.setCoupledAstroObject(that.astroObject);
        } };
    }
    testClick() {
        if (this.astroObject != null) {
            this.userController.setCoupledAstroObject(this.astroObject);
        }
        else {
            console.log("No coupled object", this.astroObject);
        }
    }
    draw(dt, isVisible, gl, matWorldUniform, drawPos, mvp, drawOrder) {
        this._shape.draw(gl, matWorldUniform, drawPos, dt);
        if (!isVisible) {
            this._div.style.visibility = 'hidden';
        }
        else {
            let clipspace = gl_matrix_1.vec4.create();
            gl_matrix_1.vec4.transformMat4(clipspace, [drawPos[0], drawPos[1], drawPos[2], 1], mvp);
            clipspace[0] /= clipspace[2];
            clipspace[1] /= clipspace[2];
            let pixelX = (clipspace[0] * 0.5 + 0.5) * gl.canvas.width;
            let pixelY = (clipspace[1] * -0.5 + 0.5) * gl.canvas.height;
            if (clipspace[2] >= 0) {
                this._div.style.visibility = 'visible';
                this._div.style.zIndex = `${drawOrder}`;
                this._div.style.left = `${Math.floor(pixelX)}px`;
                this._div.style.top = `${Math.floor(pixelY)}px`;
            }
            else {
                this._div.style.visibility = 'hidden';
            }
        }
    }
}
exports.LODManager = LODManager;


/***/ }),

/***/ "./src/models/WebGLShape.ts":
/*!**********************************!*\
  !*** ./src/models/WebGLShape.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLShape = void 0;
const gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
const gl_utils_1 = __webpack_require__(/*! ../utils/gl-utils */ "./src/utils/gl-utils.ts");
const geometry_1 = __webpack_require__(/*! ../geometry */ "./src/geometry.ts");
class WebGLShape {
    constructor(_pos, _scale, _rotationAxis, _yRotationAngle, _zRotationAngle, _rotationSpeed, gl, posAttrib, colorAttrib) {
        this._pos = _pos;
        this._scale = _scale;
        this._rotationAxis = _rotationAxis;
        this._yRotationAngle = _yRotationAngle;
        this._zRotationAngle = _zRotationAngle;
        this._rotationSpeed = _rotationSpeed;
        this._matWorld = gl_matrix_1.mat4.create();
        this._scaleVec = gl_matrix_1.vec3.create();
        this._rotation = gl_matrix_1.quat.create();
        let ellipsoid = new geometry_1.Sphere(36, 36, 1, 1);
        let ellipsoidVertices = (0, gl_utils_1.createStaticVertexBuffer)(gl, ellipsoid.vertices);
        let ellipsoidIndices = (0, gl_utils_1.createStaticIndexBuffer)(gl, ellipsoid.indices);
        if (!ellipsoidVertices || !ellipsoidIndices) {
            throw new Error(`Failed to create geo: ellipsoid (v=${!!ellipsoidVertices}, i=${ellipsoidIndices})`);
        }
        let ellipsoidVao = (0, geometry_1.create3dPosColorInterleavedVao)(gl, ellipsoidVertices, ellipsoidIndices, posAttrib, colorAttrib);
        if (!ellipsoidVao) {
            throw new Error(`Failed to create geo: ellipsoid=${!!ellipsoidVao}`);
        }
        this.vao = ellipsoidVao;
        this.numIndices = ellipsoid.indices.length;
    }
    draw(gl, matWorldUniform, drawPos, dt) {
        this._rotate(dt);
        let iQuat = gl_matrix_1.quat.create();
        let yQuat = gl_matrix_1.quat.create();
        let zQuat = gl_matrix_1.quat.create();
        gl_matrix_1.quat.setAxisAngle(yQuat, gl_matrix_1.vec3.fromValues(0, 1, 0), this._yRotationAngle);
        gl_matrix_1.quat.setAxisAngle(zQuat, gl_matrix_1.vec3.fromValues(0, 0, 1), this._zRotationAngle);
        gl_matrix_1.quat.multiply(this._rotation, zQuat, yQuat);
        gl_matrix_1.vec3.set(this._scaleVec, this._scale, this._scale, this._scale);
        gl_matrix_1.mat4.fromRotationTranslationScale(this._matWorld, this._rotation, drawPos, this._scaleVec);
        gl.uniformMatrix4fv(matWorldUniform, false, this._matWorld);
        gl.bindVertexArray(this.vao);
        gl.drawElements(gl.TRIANGLES, this.numIndices, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
    }
    _rotate(dt) {
        this._yRotationAngle += (this._rotationSpeed * dt);
        if (this._yRotationAngle >= (2 * Math.PI)) {
            this._yRotationAngle -= (2 * Math.PI);
        }
    }
}
exports.WebGLShape = WebGLShape;


/***/ }),

/***/ "./src/services/ApiClient.ts":
/*!***********************************!*\
  !*** ./src/services/ApiClient.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const config_1 = __webpack_require__(/*! ../config/config */ "./src/config/config.ts");
const api_utils_1 = __webpack_require__(/*! ../utils/api-utils */ "./src/utils/api-utils.ts");
class ApiClient {
    constructor() {
        this._baseApiUrl = `${config_1.config.apiUrl}`;
    }
    // Calls Api to get the positions and velocities of AstroObjects at a certain time. Returns a dictionary where the key is the AstroObject Id and the value has the position and velocity data
    async getEphemeris(dateTime, astroIdList) {
        let ephemerisDict = {};
        const dateTimeStr = this._formatDateTime(dateTime);
        // Calls the Api for each AstroObject Id
        for (const id of astroIdList) {
            let response = await fetch(`${this._baseApiUrl}/planet-state?id=${id}&timestamp=${dateTimeStr}`, { method: 'GET' });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            let data = await response.json();
            ephemerisDict[id] = data;
        }
        return ephemerisDict;
    }
    // Formats Date object into string of format YYYY-MM-DD-HH:mm
    _formatDateTime(dateTime) {
        const year = (0, api_utils_1.addLeadingZeroes)(String(dateTime.getFullYear()), 4);
        const month = (0, api_utils_1.addLeadingZeroes)(String(dateTime.getMonth()), 2);
        const day = (0, api_utils_1.addLeadingZeroes)(String(dateTime.getDate()), 2);
        const hour = (0, api_utils_1.addLeadingZeroes)(String(dateTime.getHours()), 2);
        const minute = (0, api_utils_1.addLeadingZeroes)(String(dateTime.getMinutes()), 2);
        return `${year}-${month}-${day}-${hour}:${minute}`;
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./src/utils/api-utils.ts":
/*!********************************!*\
  !*** ./src/utils/api-utils.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addLeadingZeroes = addLeadingZeroes;
// Pads strings with leading zeroes to obtain a certain length. Primarily used for formatting the Date strings in Api calls.
function addLeadingZeroes(str, targetLen) {
    while (str.length < targetLen) {
        str = '0' + str;
    }
    return str;
}


/***/ }),

/***/ "./src/utils/big-vec3.ts":
/*!*******************************!*\
  !*** ./src/utils/big-vec3.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.zero = zero;
exports.getScaledVec3 = getScaledVec3;
const bigdecimal_js_1 = __webpack_require__(/*! bigdecimal.js */ "./node_modules/bigdecimal.js/lib/bigdecimal.js");
const gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
function create() {
    let out = [(0, bigdecimal_js_1.Big)("0"), (0, bigdecimal_js_1.Big)("0"), (0, bigdecimal_js_1.Big)("0")];
    return out;
}
function clone(a) {
    let out = [a[0], a[1], a[2]];
    return out;
}
function length(a) {
    const mc = new bigdecimal_js_1.MC(20, bigdecimal_js_1.RoundingMode.CEILING);
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const sumSquares = (((x.multiply(x)).add(y.multiply(y))).add(z.multiply(z)));
    return sumSquares.sqrt(mc);
}
function fromValues(x, y, z) {
    let out = [(0, bigdecimal_js_1.Big)(x), (0, bigdecimal_js_1.Big)(y), (0, bigdecimal_js_1.Big)(z)];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function set(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function add(out, a, b) {
    const mc = new bigdecimal_js_1.MC(20);
    out[0] = a[0].add(b[0], mc);
    out[1] = a[1].add(b[1], mc);
    out[2] = a[2].add(b[2], mc);
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0].subtract(b[0]);
    out[1] = a[1].subtract(b[1]);
    out[2] = a[2].subtract(b[2]);
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0].multiply(b[0]);
    out[1] = a[1].multiply(b[1]);
    out[2] = a[2].multiply(b[2]);
    return out;
}
function divide(out, a, b) {
    out[0] = a[0].divide(b[0], 20, bigdecimal_js_1.RoundingMode.CEILING);
    out[1] = a[1].divide(b[1], 20, bigdecimal_js_1.RoundingMode.CEILING);
    out[2] = a[2].divide(b[2], 20, bigdecimal_js_1.RoundingMode.CEILING);
    return out;
}
function getCeilMC(num) {
    if (num.precision() == num.scale()) {
        return new bigdecimal_js_1.MC(1, bigdecimal_js_1.RoundingMode.CEILING);
    }
    else {
        return new bigdecimal_js_1.MC(num.precision() - num.scale(), bigdecimal_js_1.RoundingMode.CEILING);
    }
}
function ceil(out, a) {
    out[0] = a[0].round(getCeilMC(a[0]));
    out[1] = a[1].round(getCeilMC(a[1]));
    out[2] = a[2].round(getCeilMC(a[2]));
    return out;
}
function getFloorMC(num) {
    if (num.precision() == num.scale()) {
        return new bigdecimal_js_1.MC(1, bigdecimal_js_1.RoundingMode.FLOOR);
    }
    else {
        return new bigdecimal_js_1.MC(num.precision() - num.scale(), bigdecimal_js_1.RoundingMode.FLOOR);
    }
}
function floor(out, a) {
    out[0] = a[0].round(getFloorMC(a[0]));
    out[1] = a[1].round(getFloorMC(a[1]));
    out[2] = a[2].round(getFloorMC(a[2]));
    return out;
}
function min(out, a, b) {
    out[0] = a[0].min(b[0]);
    out[1] = a[1].min(b[1]);
    out[2] = a[2].min(b[2]);
    return out;
}
function max(out, a, b) {
    out[0] = a[0].max(b[0]);
    out[1] = a[1].max(b[1]);
    out[2] = a[2].max(b[2]);
    return out;
}
function getRoundMC(num) {
    if (num.greaterThan("0")) {
        if (num.precision() == num.scale()) {
            return new bigdecimal_js_1.MC(1, bigdecimal_js_1.RoundingMode.HALF_UP);
        }
        else {
            return new bigdecimal_js_1.MC(num.precision() - num.scale(), bigdecimal_js_1.RoundingMode.HALF_UP);
        }
    }
    else {
        if (num.precision() == num.scale()) {
            return new bigdecimal_js_1.MC(1, bigdecimal_js_1.RoundingMode.HALF_DOWN);
        }
        else {
            return new bigdecimal_js_1.MC(num.precision() - num.scale(), bigdecimal_js_1.RoundingMode.HALF_DOWN);
        }
    }
}
function round(out, a) {
    out[0] = a[0].round(getRoundMC(a[0]));
    out[1] = a[1].round(getRoundMC(a[1]));
    out[2] = a[2].round(getRoundMC(a[2]));
    return out;
}
function scale(out, a, b) {
    out[0] = a[0].multiply(b);
    out[1] = a[1].multiply(b);
    out[2] = a[2].multiply(b);
    return out;
}
function scaleAndAdd(out, a, b, scale) {
    out[0] = (a[0].add(b[0])).multiply(scale);
    out[1] = (a[1].add(b[1])).multiply(scale);
    out[2] = (a[2].add(b[2])).multiply(scale);
    return out;
}
function distance(a, b) {
    const mc = new bigdecimal_js_1.MC(20, bigdecimal_js_1.RoundingMode.CEILING);
    const x = b[0].subtract(a[0]);
    const y = b[1].subtract(a[1]);
    const z = b[2].subtract(a[2]);
    const sumSquares = (((x.multiply(x)).add(y.multiply(y))).add(z.multiply(z)));
    return sumSquares.sqrt(mc);
}
function squaredDistance(a, b) {
    const x = b[0].subtract(a[0]);
    const y = b[1].subtract(a[1]);
    const z = b[2].subtract(a[2]);
    const sumSquares = (((x.multiply(x)).add(y.multiply(y))).add(z.multiply(z)));
    return sumSquares;
}
function squaredLength(a) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const sumSquares = (((x.multiply(x)).add(y.multiply(y))).add(z.multiply(z)));
    return sumSquares;
}
function negate(out, a) {
    out[0] = a[0].negate();
    out[1] = a[1].negate();
    out[2] = a[2].negate();
    return out;
}
function inverse(out, a) {
    out[0] = (0, bigdecimal_js_1.Big)("1").divide(a[0]);
    out[1] = (0, bigdecimal_js_1.Big)("1").divide(a[1]);
    out[2] = (0, bigdecimal_js_1.Big)("1").divide(a[2]);
    return out;
}
function normalize(out, a) {
    let len = squaredLength(a);
    if (len.greaterThan((0, bigdecimal_js_1.Big)("0"))) {
        len = (0, bigdecimal_js_1.Big)("1").divide(length(a), 20, bigdecimal_js_1.RoundingMode.CEILING);
    }
    out[0] = a[0].multiply(len);
    out[1] = a[1].multiply(len);
    out[2] = a[2].multiply(len);
    return out;
}
function zero(out) {
    out[0] = (0, bigdecimal_js_1.Big)(0);
    out[1] = (0, bigdecimal_js_1.Big)(0);
    out[2] = (0, bigdecimal_js_1.Big)(0);
    return out;
}
function getScaledVec3(bVec, num, power) {
    let sV = create();
    scale(sV, bVec, (0, bigdecimal_js_1.Big)(num.toString()).pow(power, new bigdecimal_js_1.MC(20)));
    let out = gl_matrix_1.vec3.create();
    out[0] = Number(sV[0].toEngineeringString());
    out[1] = Number(sV[1].toEngineeringString());
    out[2] = Number(sV[2].toEngineeringString());
    return out;
}


/***/ }),

/***/ "./src/utils/gl-utils.ts":
/*!*******************************!*\
  !*** ./src/utils/gl-utils.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showError = showError;
exports.getRandomInRange = getRandomInRange;
exports.createStaticVertexBuffer = createStaticVertexBuffer;
exports.createStaticIndexBuffer = createStaticIndexBuffer;
exports.createProgram = createProgram;
exports.getContext = getContext;
function showError(errorText) {
    console.error(errorText);
    const errorBoxDiv = document.getElementById('error-box');
    if (errorBoxDiv === null) {
        return;
    }
    const errorElement = document.createElement('p');
    errorElement.innerText = errorText;
    errorBoxDiv.appendChild(errorElement);
}
function getRandomInRange(min, max) {
    return Math.random() * (max - min) + min;
}
function createStaticVertexBuffer(gl, data) {
    const buffer = gl.createBuffer();
    if (!buffer) {
        showError('Failed to allocated buffer');
        return null;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return buffer;
}
function createStaticIndexBuffer(gl, data) {
    const buffer = gl.createBuffer();
    if (!buffer) {
        showError('Failed to allocated buffer');
        return null;
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    return buffer;
}
function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    const program = gl.createProgram();
    if (!vertexShader || !fragmentShader || !program) {
        showError(`Failed to allocate GL objects (`
            + `vs=${!!vertexShader}, `
            + `fs=${!!fragmentShader}, `
            + `program=${!!program})`);
        return null;
    }
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        const errorMessage = gl.getShaderInfoLog(vertexShader);
        showError(`Failed to compile vertex shader: ${errorMessage}`);
        return null;
    }
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        const errorMessage = gl.getShaderInfoLog(fragmentShader);
        showError(`Failed to compile fragment shader: ${errorMessage}`);
        return null;
    }
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const errorMessage = gl.getProgramInfoLog(program);
        showError(`Failed to link GPU program: ${errorMessage}`);
        return null;
    }
    return program;
}
function getContext(canvas) {
    const gl = canvas.getContext('webgl2');
    if (!gl) {
        const isWebGl1Supported = !!(document.createElement('canvas')).getContext('webgl');
        if (isWebGl1Supported) {
            throw new Error('WebGL 1 is supported, but not v2 - try using a different device or browser');
        }
        else {
            throw new Error('WebGL is not supported on this device - try using a different device or browser');
        }
    }
    return gl;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFD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QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsMkJBQTJCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELDhDQUE4QztBQUM5Qyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsdUJBQXVCO0FBQ3ZCLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGlCQUFpQjtBQUNqQiw4Q0FBOEM7QUFDOUM7QUFDQSxzREFBc0Q7QUFDdEQsbUJBQW1CO0FBQ25CLDJEQUEyRDtBQUMzRCxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLGtEQUFrRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeGtJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7QUFDdkQ7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakR3QztBQUNOO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUCxnQkFBZ0Isa0RBQW1COztBQUVuQyxNQUFNLGtEQUFtQjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6Qjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0I7QUFDN1M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9haUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7O0FBRW5DLE1BQU0sa0RBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUCxnQkFBZ0Isa0RBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsU0FBUztBQUN0Qjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsU0FBUztBQUN0Qjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCO0FBQ3ZkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyZWlDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7O0FBRW5DLE1BQU0sa0RBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekI7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0I7QUFDdHRCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDendCaUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjs7QUFFbkMsTUFBTSxrREFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksK0NBQWdCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksK0NBQWdCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLHdCQUF3QixrREFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxNQUFNO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxNQUFNO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFlBQVksTUFBTTtBQUNsQjs7QUFFTztBQUNQLG9CQUFvQixrREFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekI7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLCtDQUFnQiwrQkFBK0IsK0NBQWdCLCtCQUErQiwrQ0FBZ0I7QUFDL0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IsdUVBQXVFLCtDQUFnQix5RUFBeUUsK0NBQWdCLHlFQUF5RSwrQ0FBZ0IseUVBQXlFLCtDQUFnQix5RUFBeUUsK0NBQWdCLHlFQUF5RSwrQ0FBZ0I7QUFDL3pDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcjNEaUM7QUFDTjtBQUNBO0FBQ0E7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjs7QUFFbkMsTUFBTSxrREFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxZQUFZO0FBQ3hCOztBQUVPO0FBQ1A7QUFDQTs7QUFFQSxVQUFVLCtDQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLFlBQVk7QUFDeEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0MsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSixvQkFBb0IsK0NBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsOENBQWU7QUFDMUIsV0FBVyw4Q0FBZTtBQUMxQixXQUFXLDhDQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTyxZQUFZLDJDQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTyxpQkFBaUIsZ0RBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTyxXQUFXLDBDQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRU8sVUFBVSx5Q0FBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTyxVQUFVLHlDQUFRO0FBQ3pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFTyxZQUFZLDJDQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRU8sVUFBVSx5Q0FBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRU8sV0FBVywwQ0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPLGFBQWEsNENBQVc7QUFDL0I7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFTyxvQkFBb0IsbURBQWtCO0FBQzdDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVPLGdCQUFnQiwrQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsU0FBUztBQUN0Qjs7QUFFTyxrQkFBa0IsaURBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPLGFBQWEsNENBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLDRDQUFXO0FBQzNCLGtCQUFrQixnREFBZTtBQUNqQyxrQkFBa0IsZ0RBQWU7QUFDakM7QUFDQSxjQUFjLHlDQUFROztBQUV0QjtBQUNBLE1BQU0sMkNBQVU7QUFDaEIsVUFBVSx5Q0FBUSxzQkFBc0IsMkNBQVU7QUFDbEQsTUFBTSwrQ0FBYztBQUNwQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSwyQ0FBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUCxhQUFhLDRDQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyc0J1QztBQUNOO0FBQ0E7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1AsZUFBZSxrREFBbUI7O0FBRWxDLE1BQU0sa0RBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVPO0FBQ1AsZUFBZSxrREFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVPO0FBQ1AsZUFBZSxrREFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUCxlQUFlLGtEQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWMsNENBQVc7QUFDekIsRUFBRSxpREFBZ0I7QUFDbEIsY0FBYyxrREFBbUI7QUFDakMsRUFBRSxvREFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxlQUFlO0FBQzNCLFlBQVksTUFBTTtBQUNsQjs7QUFFTyxjQUFjLDBDQUFTO0FBQzlCO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxlQUFlO0FBQzNCLFlBQVksTUFBTTtBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU8sY0FBYywwQ0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLGVBQWU7QUFDM0IsWUFBWSxNQUFNO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDZDQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDZDQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDZDQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0Esc0JBQXNCLCtDQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRU8sVUFBVSx5Q0FBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRU8sYUFBYSw0Q0FBVztBQUMvQjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVPLG9CQUFvQixtREFBa0I7QUFDN0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0I7QUFDam9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2wwQndDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7O0FBRW5DLE1BQU0sa0RBQW1CO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0EsVUFBVSw4Q0FBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQWdCLHFFQUFxRSwrQ0FBZ0I7QUFDbkk7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9tQnVDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7O0FBRW5DLE1BQU0sa0RBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUCxnQkFBZ0Isa0RBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0EsVUFBVSw4Q0FBZTtBQUN6QixVQUFVLDhDQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFNBQVM7QUFDdEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFNBQVM7QUFDdEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQjtBQUN4TjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbHhCdUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjs7QUFFbkMsTUFBTSxrREFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDhDQUFlO0FBQ3hCLFNBQVMsOENBQWU7QUFDeEI7QUFDQSxJQUFJOztBQUVKO0FBQ0EsU0FBUyw4Q0FBZTtBQUN4QixTQUFTLDhDQUFlO0FBQ3hCO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0I7QUFDN1M7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RwQkQsMEZBQXlIO0FBRXpILGtHQUEyRTtBQUMzRSx3SEFBOEQ7QUFDOUQsbUdBQWlEO0FBQ2pELDhJQUF1RDtBQUV2RCxrR0FBaUQ7QUFDakQsa0dBQWlEO0FBQ2pELHFHQUFtRDtBQUNuRCxxR0FBbUQ7QUFDbkQsbUdBQTRDO0FBQzVDLG1IQUFpRTtBQUVqRSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBQyxDQUFDLEVBQUUsSUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFFN0IsTUFBTSxzQkFBc0IsR0FBRzs7Ozs7Ozs7Ozs7Ozs7O01BZXpCLENBQUM7QUFFUCxNQUFNLHdCQUF3QixHQUFHOzs7Ozs7OztNQVEzQixDQUFDO0FBRVAsSUFBSSxJQUFJLEdBQUcsSUFBSSwrQkFBYyxFQUFFLENBQUM7QUFHaEMsU0FBUyxVQUFVO0FBQ25CLENBQUM7QUFDRCxJQUFJLFdBQVcsR0FBRyxLQUFLO0FBQ3ZCLElBQUksWUFBWSxHQUFHLEtBQUs7QUFDeEIsSUFBSSxTQUFTLEdBQUcsS0FBSztBQUNyQixJQUFJLFFBQVEsR0FBRyxLQUFLO0FBQ3BCLElBQUksTUFBTSxHQUFHLEtBQUs7QUFDbEIsSUFBSSxRQUFRLEdBQUcsS0FBSztBQUNwQixTQUFTLE9BQU8sQ0FBQyxDQUFnQjtJQUM3QixJQUFHLElBQUksQ0FBQyxRQUFRLElBQUksS0FBSyxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJO0lBQ3hCLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksTUFBTSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSztJQUNqQyxDQUFDO0lBQ0QsSUFBRyxDQUFDLENBQUMsSUFBSSxJQUFJLE1BQU0sRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSztJQUNsQyxDQUFDO0lBQ0QsSUFBRyxDQUFDLENBQUMsSUFBSSxJQUFJLE1BQU0sRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUs7SUFDakMsQ0FBQztJQUNELElBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxNQUFNLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUs7SUFDbEMsQ0FBQztJQUNELElBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLO0lBQ2pDLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksYUFBYSxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLO0lBQ2xDLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksTUFBTSxFQUFFLENBQUM7UUFDckIsSUFBRyxJQUFJLENBQUMsS0FBSyxJQUFJLEdBQUcsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyxLQUFLLElBQUksR0FBRztRQUNsQixDQUFDO2FBQU0sQ0FBQztZQUNQLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSztRQUNwQixDQUFDO0lBQ0UsQ0FBQztBQUNMLENBQUM7QUFDRCxTQUFTLEtBQUssQ0FBQyxDQUFnQjtJQUMzQixJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksTUFBTSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3hCLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksTUFBTSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3hCLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksTUFBTSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3hCLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksTUFBTSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3hCLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksT0FBTyxFQUFFLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3hCLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksYUFBYSxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3hCLENBQUM7QUFDTCxDQUFDO0FBQ0QsSUFBSSxRQUFRLEdBQUcsS0FBSztBQUNwQixTQUFTLEtBQUssQ0FBQyxDQUFhO0lBQ3hCLElBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUNmLElBQUcsUUFBUSxJQUFJLEtBQUssRUFBRSxDQUFDO1lBQ25CLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTztZQUN0QyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU87WUFDdEMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7WUFDMUQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7WUFDMUQsUUFBUSxHQUFHLElBQUk7UUFDbkIsQ0FBQztJQUNMLENBQUM7QUFDTCxDQUFDO0FBQ0QsU0FBUyxNQUFNLENBQUMsQ0FBYTtJQUN6QixJQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDZixJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDdkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ3ZCLFFBQVEsR0FBRyxLQUFLO0lBQ3BCLENBQUM7QUFDTCxDQUFDO0FBQ0QsU0FBUyxZQUFZLENBQUMsQ0FBYTtJQUMvQixJQUFHLFFBQVEsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU87UUFDekMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPO1FBQ3pDLHNJQUFzSTtRQUN0SSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTO1FBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVM7SUFDckMsQ0FBQztBQUNMLENBQUM7QUFDRCxTQUFTLElBQUksQ0FBQyxDQUFhO0lBQ3ZCLElBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2xCLFlBQVksR0FBRyxLQUFLO1FBQ3BCLFdBQVcsR0FBRyxJQUFJO0lBQ3RCLENBQUM7SUFDRCxJQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFLENBQUM7UUFDakIsV0FBVyxHQUFHLEtBQUs7UUFDbkIsWUFBWSxHQUFHLElBQUk7SUFDdkIsQ0FBQztBQUNMLENBQUM7QUFDRCxLQUFLLFVBQVUsSUFBSTtJQUduQixtREFBbUQ7SUFDOUMsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2RCxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxNQUFNLFlBQVksaUJBQWlCLENBQUMsRUFBRSxDQUFDO1FBQ3BELHdCQUFTLEVBQUMsZ0NBQWdDLENBQUMsQ0FBQztRQUM1QyxPQUFPO0lBQ1gsQ0FBQztJQUNGLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFFLENBQUM7SUFFL0MsSUFBSSxtQkFBbUIsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBRTtJQUNsRSxJQUFJLGFBQWEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBRTtJQUM3RCxJQUFJLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsbUJBQW1CLENBQUU7SUFDckUsSUFBSSxxQkFBcUIsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUFFO0lBQzdFLElBQUkscUJBQXFCLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBRTtJQUM3RSxJQUFJLHlCQUF5QixHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsMkJBQTJCLENBQUU7SUFFckYsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMzQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ25ELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFHM0QsTUFBTSxFQUFFLEdBQUcseUJBQVUsRUFBQyxNQUFNLENBQUMsQ0FBQztJQUc5QixNQUFNLFdBQVcsR0FBRyw0QkFBYSxFQUFDLEVBQUUsRUFBRSxzQkFBc0IsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO0lBQ3hGLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNmLHdCQUFTLEVBQUMsaUNBQWlDLENBQUMsQ0FBQztRQUM3QyxPQUFPO0lBQ1gsQ0FBQztJQUVELE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUN0RSxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBRXJFLE1BQU0sZUFBZSxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDdkUsTUFBTSxrQkFBa0IsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBRTdFLElBQUksU0FBUyxHQUFHLENBQUMsSUFBSSxXQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUM5RSx3QkFBUyxFQUFDLGtDQUFrQztZQUN4QyxPQUFPLFNBQVMsV0FBVyxXQUFXLEdBQUc7WUFDekMsWUFBWSxDQUFDLENBQUMsZUFBZSxnQkFBZ0IsQ0FBQyxDQUFDLGtCQUFrQixFQUFFLENBQUMsQ0FBQztRQUN6RSxPQUFPO0lBQ1gsQ0FBQztJQUNELElBQUksZUFBZSxHQUFHLE1BQU0saUJBQWlCLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDaEYsSUFBSSxNQUFNLEdBQUcsSUFBSSx5QkFBVyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBRTlDLE1BQU0sUUFBUSxHQUFHLGdCQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDL0IsTUFBTSxPQUFPLEdBQUcsZ0JBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUM5QixNQUFNLE9BQU8sR0FBRyxnQkFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBRTlCLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDMUQsSUFBSSxVQUFVLElBQUksSUFBSSxFQUFFLENBQUM7UUFDNUIsVUFBVSxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsR0FBRyxHQUFHLENBQUM7UUFDM0MsVUFBVSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ3pELE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLHdCQUF3QixDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO1NBQU0sQ0FBQztRQUNQLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUNELGlEQUFpRDtJQUVqRCxJQUFJLGFBQWEsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDdEMsTUFBTSxLQUFLLEdBQUc7UUFFakIsTUFBTSxhQUFhLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sRUFBRSxHQUFHLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUNsRCxxQkFBcUI7UUFDckIsYUFBYSxHQUFHLGFBQWEsQ0FBQztRQUM5QixJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUVmLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTVDLG1EQUFtRDtRQUM1QyxNQUFNLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDO1FBRTVCLGdCQUFJLENBQUMsTUFBTSxDQUNQLE9BQU8sRUFDUCxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxFQUMxQyxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUNsRSxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFOUIsZ0JBQUksQ0FBQyxXQUFXLENBQ1osT0FBTyxFQUNQLG9CQUFRLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUNyQixNQUFNLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQzVCLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUVsQixNQUFNLFdBQVcsR0FBRyxnQkFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRWxDLGdCQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFN0MsTUFBTSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxHQUFHLGdCQUFnQixDQUFDO1FBQ3JELE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQztRQUV2RCxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3BELEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXpCLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUvQyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBTzNCLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFJbkUsTUFBTSxDQUFDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDL0QsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQzVCLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUM1QixLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLHVCQUFHLEVBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksa0JBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0QsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSx1QkFBRyxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLGtCQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9ELElBQUksS0FBSyxHQUFHLGdCQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDdEgsSUFBSSxLQUFLLEdBQUcsZ0JBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN0SCxPQUFPLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLEdBQUMsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUM7UUFDdkYsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFHLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUNwQyxhQUFhLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUM7UUFDM0MsQ0FBQzthQUFNLENBQUM7WUFDUCxhQUFhLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7WUFDM0MsaUJBQWlCLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUM7WUFDM0QscUJBQXFCLENBQUMsU0FBUyxHQUFHLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUMzSixxQkFBcUIsQ0FBQyxTQUFTLEdBQUcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzNKLHlCQUF5QixDQUFDLFNBQVMsR0FBRyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDNUssQ0FBQztRQUVELHNHQUFzRztRQUMvRixJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ2hCLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUNuRCxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDeEIsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3hCLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUN2QyxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDNUIsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFFBQVEsRUFBRSx1QkFBRyxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLGtCQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxlQUFlLEVBQUUsZ0JBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDak8sQ0FBQyxFQUFFLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVJLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFDRCxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRUQsS0FBSyxVQUFVLGlCQUFpQixDQUFDLEVBQTBCLEVBQUUsU0FBaUIsRUFBRSxXQUFtQixFQUFFLElBQW9CO0lBQ3hILElBQUksR0FBRyxHQUFrQixFQUFFO0lBQzNCLE1BQU0sR0FBRyxHQUFHLElBQUkscUJBQVMsRUFBRSxDQUFDO0lBRTVCLE1BQU0sWUFBWSxHQUFHLE1BQU0sR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLDhCQUFVLENBQUMsQ0FBQyxDQUFDO0lBS3ZGLElBQUksbUJBQW1CLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUU7SUFFdEUsTUFBTSxXQUFXLEdBQUcsOEJBQStDLENBQUM7SUFDcEUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ25ELGlCQUFpQjtRQUNqQixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFDLE1BQU07UUFDN0IsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUMxQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQ2hDLElBQUksS0FBSyxHQUFHLElBQUksdUJBQVUsQ0FBQyxnQkFBSSxDQUFDLE1BQU0sRUFBRSxFQUNuQyxJQUFJLEVBQ04sZ0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFDcEIsb0JBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQ3BCLElBQUksRUFDSixNQUFNLEVBQ04sRUFBRSxFQUNGLFNBQVMsRUFDVCxXQUFXLENBQUMsQ0FBQztRQUNsQixJQUFJLFVBQVUsR0FBRyxJQUFJLHVCQUFVLENBQUMsS0FBSyxFQUFFLG1CQUFtQixFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDN0UsSUFBSSxFQUFFLEdBQUcsdUJBQUcsRUFBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyx1QkFBRyxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLGtCQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BILElBQUksRUFBRSxHQUFHLHVCQUFHLEVBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsdUJBQUcsRUFBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxrQkFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwSCxJQUFJLEVBQUUsR0FBRyx1QkFBRyxFQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLHVCQUFHLEVBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLElBQUksa0JBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEgsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3RGLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSx1QkFBRyxFQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFFN0MsSUFBSSxHQUFHLEdBQUcsdUJBQUcsRUFBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyx1QkFBRyxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLGtCQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JILElBQUksR0FBRyxHQUFHLHVCQUFHLEVBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsdUJBQUcsRUFBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxrQkFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNySCxJQUFJLEdBQUcsR0FBRyx1QkFBRyxFQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLHVCQUFHLEVBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLElBQUksa0JBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckgsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQUUsR0FBRyxDQUFDLFFBQVEsRUFBRSxFQUFFLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3pGLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSx1QkFBRyxFQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFFN0MsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRWxDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDckIsSUFBSSxJQUFJLEdBQUcsdUJBQUcsRUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDM0MsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQztRQUNoQixJQUFJLFdBQVcsR0FBRyxJQUFJLHlCQUFXLENBQUMsUUFBUSxFQUNyQyxRQUFRLEVBQ1IsWUFBWSxFQUNaLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxDQUFDLFdBQVcsRUFDaEIsSUFBSSxDQUFDLFNBQVMsRUFDZCxPQUFPLEVBQ1AsT0FBTyxFQUNQLFVBQVUsQ0FBQyxDQUFDO1FBQ2pCLFdBQVcsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBSXBELDJHQUEyRztRQUMzRyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBSUgsT0FBTyxHQUFHO0FBQ1gsQ0FBQztBQUVELElBQUksQ0FBQztJQUNKLElBQUksRUFBRTtJQUNOLDRCQUE0QjtJQUM1QiwwQkFBMEI7SUFDMUIseUJBQXlCO0lBQ3pCLEVBQUU7QUFFSCxDQUFDO0FBQUMsT0FBTSxDQUFDLEVBQUUsQ0FBQztJQUNSLHdCQUFTLEVBQUMsbUNBQW1DLENBQUMsRUFBRSxDQUFDO0FBQ3JELENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hYWSxjQUFNLEdBQUc7SUFDckIsTUFBTSxFQUFFLHVCQUFtQjtJQUMzQixXQUFXLEVBQUUsYUFBb0I7Q0FDakMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMRixrR0FBMkU7QUFFM0Usb0dBQTJDO0FBRTNDLE1BQWEsY0FBYztJQVl2QjtRQUNJLElBQUksQ0FBQyxZQUFZLEdBQUcsZ0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUM7UUFDaEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsZUFBZSxHQUFHLGdCQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMscUJBQXFCLEdBQUcsZ0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLFdBQVcsR0FBRyxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUs7UUFDekIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztJQUM1QixDQUFDO0lBRU0sU0FBUyxDQUFDLEVBQVU7UUFDdkIsSUFBSSxXQUFXLEdBQUcsZ0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztRQUNoRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTtRQUN2Qyx3QkFBd0I7UUFDakIsSUFBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3RCLElBQUksSUFBSSxDQUFDLGtCQUFrQixJQUFJLElBQUksRUFBRSxDQUFDO2dCQUNoRCxJQUFJLElBQUksR0FBRyxnQkFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN6QixJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pFLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUM3QyxnQkFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzNCLGdCQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDckMsQ0FBQztpQkFBTSxDQUFDO2dCQUNBLGdCQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDO1lBQ3pLLENBQUM7UUFFRSxDQUFDO2FBQU0sSUFBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3ZDLElBQUksSUFBSSxDQUFDLGtCQUFrQixJQUFJLElBQUksRUFBRSxDQUFDO2dCQUNyQyxJQUFJLElBQUksR0FBRyxnQkFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN6QixJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pFLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUM3QyxnQkFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzNCLGdCQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUMxQyxDQUFDO2lCQUFNLENBQUM7Z0JBQ0ksZ0JBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLGdCQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztZQUM5SyxDQUFDO1FBRUssQ0FBQztRQUNELElBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUNoQyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLEVBQUUsQ0FBQztnQkFDckMsSUFBSSxJQUFJLEdBQUcsZ0JBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN6RSxJQUFJLElBQUksR0FBRyxnQkFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN6QixJQUFJLElBQUksR0FBRyxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNwQyxnQkFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDN0MsZ0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7Z0JBQzVCLGdCQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDM0IsZ0JBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzFDLENBQUM7aUJBQU0sQ0FBQztnQkFDUCxnQkFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsZ0JBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxvQkFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEdBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDO1lBQ3hLLENBQUM7UUFDSyxDQUFDO2FBQU0sSUFBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3ZDLElBQUksSUFBSSxDQUFDLGtCQUFrQixJQUFJLElBQUksRUFBRSxDQUFDO2dCQUNyQyxJQUFJLElBQUksR0FBRyxnQkFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN6QixJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pFLElBQUksSUFBSSxHQUFHLGdCQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3pCLElBQUksSUFBSSxHQUFHLGdCQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3BDLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUM3QyxnQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQztnQkFDNUIsZ0JBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUMzQixnQkFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3pDLENBQUM7aUJBQU0sQ0FBQztnQkFDSSxnQkFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsZ0JBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxvQkFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEdBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFFcEwsQ0FBQztRQUNGLENBQUM7UUFDTSxJQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFFaEMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLElBQUksSUFBSSxFQUFFLENBQUM7Z0JBQ3JDLElBQUksSUFBSSxHQUFHLGdCQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3pCLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekUsSUFBSSxJQUFJLEdBQUcsZ0JBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxJQUFJLEdBQUcsZ0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDcEMsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQzdDLGdCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO2dCQUM1QixnQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQztnQkFDNUIsZ0JBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztnQkFDMUIsZ0JBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTFDLENBQUM7aUJBQU0sQ0FBQztnQkFDSSxnQkFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsZ0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUM7WUFDdkUsQ0FBQztRQUVLLENBQUM7YUFBTSxJQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFFdkMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLElBQUksSUFBSSxFQUFFLENBQUM7Z0JBQ3JDLElBQUksSUFBSSxHQUFHLGdCQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3pCLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekUsSUFBSSxJQUFJLEdBQUcsZ0JBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxJQUFJLEdBQUcsZ0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDcEMsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQzdDLGdCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO2dCQUM1QixnQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQztnQkFDNUIsZ0JBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztnQkFDMUIsZ0JBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN6QyxDQUFDO2lCQUFNLENBQUM7Z0JBQ0ksZ0JBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLGdCQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFDeEUsQ0FBQztRQUNGLENBQUM7UUFFTSxnQkFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLG1EQUFpRDtJQUNoSCxDQUFDO0lBQ00sTUFBTSxDQUFDLEVBQVU7UUFDcEIsOEJBQThCO1FBQy9CLHlFQUF5RTtRQUN4RSxJQUFJLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUM3QyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBRSxDQUFDLENBQUM7WUFDekksSUFBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQ1IsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekcsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekcsK0RBQStEO2dCQUMvRCxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUM7Z0JBQ2hFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLElBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQztnQkFDekU7Ozs7Y0FJRjtnQkFDVSxxSkFBcUo7Z0JBQzVKLDZGQUE2RjtnQkFDdEYsb0pBQW9KO2dCQUMzSixJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSTtnQkFDMUIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUk7WUFDckMsQ0FBQztpQkFBTSxDQUFDO2dCQUNKLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO2dCQUMxRCxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztZQUM5RCxDQUFDO1lBQ1IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxvQkFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xKLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwRixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekosQ0FBQzthQUFNLENBQUM7WUFDUCxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkUsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ25ELGdCQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDeEQsSUFBSSxJQUFJLEdBQUcsZ0JBQUksQ0FBQyxNQUFNLEVBQUU7WUFDeEIsZ0JBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNuQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFDLEdBQUcsQ0FBQyxHQUFDLElBQUksQ0FBQyxFQUFFO1lBQzdDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUMsR0FBRyxDQUFDLEdBQUMsSUFBSSxDQUFDLEVBQUU7UUFFNUMsQ0FBQztJQUNFLENBQUM7SUFHTSxxQkFBcUIsQ0FBQyxHQUFnQjtRQUM1QyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxDQUFDO1FBQ2xDLG1EQUFtRDtJQUNoRCxDQUFDO0lBRU8sWUFBWTtRQUNuQixJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQzlCLElBQUksSUFBSSxDQUFDLGtCQUFrQixJQUFJLElBQUksRUFBRSxDQUFDO1lBQ3JDLElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqRixJQUFJLElBQUksR0FBRyxnQkFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQztZQUN6RCxJQUFJLFFBQVEsR0FBRyxTQUFTLENBQUM7WUFFekIsUUFBUSxHQUFHLElBQUk7WUFDZixPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDO1FBQ3pDLENBQUM7UUFDRCxPQUFPLFFBQVEsQ0FBQztJQUNiLENBQUM7Q0FDSjtBQWhMRCx3Q0FnTEM7Ozs7Ozs7Ozs7Ozs7O0FDb0hELHdFQWdDQztBQXhVRCwwRkFBNkM7QUFFN0MsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QixvRUFBb0U7QUFFcEUsTUFBTSxNQUFNO0lBSVIsWUFBWSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDdkMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsQ0FBQztDQUNKO0FBRUQsTUFBYSxNQUFNO0lBSWYsWUFBWSxNQUFjLEVBQUUsT0FBZSxFQUFFLE9BQWUsRUFBRSxPQUFlO1FBQ3pFLElBQUksWUFBWSxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsR0FBQyxPQUFPLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsT0FBTyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFDLE9BQU8sR0FBQyxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hFLElBQUksV0FBVyxHQUFHLENBQUMsQ0FBQyxHQUFDLE9BQU8sQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLE9BQU8sQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLE9BQU8sR0FBQyxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZ0RBQWdEO1FBQ2xILElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLFdBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUc1QyxJQUFJLEtBQUssR0FBVSxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQU1qRSxXQUFXO1FBQ1gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3BCLENBQUMsRUFBRSxDQUFDO1lBQ0osSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEIsQ0FBQyxFQUFFLENBQUM7WUFDSixJQUFJLENBQUMsR0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN6QixDQUFDLEdBQUcsQ0FBQztZQUNULENBQUM7aUJBQU0sQ0FBQztnQkFDSixDQUFDLEVBQUU7WUFDUCxDQUFDO1lBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEIsQ0FBQyxFQUFFLENBQUM7WUFDSixDQUFDLEVBQUc7UUFDUixDQUFDO1FBQ0QsSUFBSSxPQUFPLEdBQUcsQ0FBQztRQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3RDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQ3ZDLElBQUksS0FBSyxHQUFHLENBQUM7Z0JBQ2IsSUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztvQkFDL0IsS0FBSyxHQUFHLENBQUMsQ0FBQztnQkFDZCxDQUFDO2dCQUNELElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLGNBQWM7Z0JBQ2pELElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUN6QixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztnQkFDMUIsT0FBTyxFQUFFO2dCQUNULENBQUMsRUFBRSxDQUFDO2dCQUNKLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxlQUFlO2dCQUN4RCxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUN6QixJQUFJLGdCQUFnQixHQUFHLE9BQU8sQ0FBQztnQkFDL0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQztnQkFDbkMsT0FBTyxFQUFFO2dCQUNULENB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QyxHQUFHLENBQUMsQ0FBQztJQUNYLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDWCxPQUFPLEdBQUcsQ0FBQztBQUNaLENBQUM7QUFFRCxTQUFnQixHQUFHLENBQUMsR0FBaUIsRUFBRSxDQUFlLEVBQUUsQ0FBZTtJQUN0RSxNQUFNLEVBQUUsR0FBRyxJQUFJLGtCQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzVCLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1QixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDNUIsT0FBTyxHQUFHLENBQUM7QUFDWixDQUFDO0FBRUQsU0FBZ0IsUUFBUSxDQUFDLEdBQWlCLEVBQUUsQ0FBZSxFQUFFLENBQWU7SUFDM0UsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsT0FBTyxHQUFHLENBQUM7QUFDWixDQUFD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QztJQUNoRSxDQUFDO0FBQ0YsQ0FBQztBQUVELFNBQWdCLEtBQUssQ0FBQyxHQUFpQixFQUFFLENBQWU7SUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFdEMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEMsT0FBTyxHQUFHLENBQUM7QUFDWixDQUFDO0FBRUQsU0FBZ0IsR0FBRyxDQUFDLEdBQWlCLEVBQUUsQ0FBZSxFQUFFLENBQWU7SUFDdEUsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEIsT0FBTyxHQUFHLENBQUM7QUFDWixDQUFDO0FBSUQsU0FBZ0IsR0FBRyxDQUFDLEdBQWlCLEVBQUUsQ0FBZSxFQUFFLENBQWU7SUFDdEUsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENB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QUMsQ0FBQztJQUMxQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUMsT0FBTyxHQUFHLENBQUM7QUFDWixDQUFDO0FBRUQsU0FBZ0IsUUFBUSxDQUFDLENBQWUsRUFBRSxDQUFlO0lBQ3hELE1BQU0sRUFBRSxHQUFHLElBQUksa0JBQUUsQ0FBQyxFQUFFLEVBQUUsNEJBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1QyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlCLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3RSxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7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O1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TdGFyIE1hcC8uL25vZGVfbW9kdWxlcy9iaWdkZWNpbWFsLmpzL2xpYi9iaWdkZWNpbWFsLmpzIiwid2VicGFjazovL1N0YXIgTWFwLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vY29tbW9uLmpzIiwid2VicGFjazovL1N0YXIgTWFwLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQyLmpzIiwid2VicGFjazovL1N0YXIgTWFwLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vbWF0MmQuanMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQzLmpzIiwid2VicGFjazovL1N0YXIgTWFwLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vbWF0NC5qcyIsIndlYnBhY2s6Ly9TdGFyIE1hcC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3F1YXQuanMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9xdWF0Mi5qcyIsIndlYnBhY2s6Ly9TdGFyIE1hcC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzIuanMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMzLmpzIiwid2VicGFjazovL1N0YXIgTWFwLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjNC5qcyIsIndlYnBhY2s6Ly9TdGFyIE1hcC8uL3NyYy9hcHAudHMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly9TdGFyIE1hcC8uL3NyYy9jb250cm9sbGVycy9Vc2VyQ29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9TdGFyIE1hcC8uL3NyYy9nZW9tZXRyeS50cyIsIndlYnBhY2s6Ly9TdGFyIE1hcC8uL3NyYy9tb2RlbHMvQXN0cm9PYmplY3QudHMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvLi9zcmMvbW9kZWxzL0FzdHJvU3lzdGVtLnRzIiwid2VicGFjazovL1N0YXIgTWFwLy4vc3JjL21vZGVscy9MT0RNYW5hZ2VyLnRzIiwid2VicGFjazovL1N0YXIgTWFwLy4vc3JjL21vZGVscy9XZWJHTFNoYXBlLnRzIiwid2VicGFjazovL1N0YXIgTWFwLy4vc3JjL3NlcnZpY2VzL0FwaUNsaWVudC50cyIsIndlYnBhY2s6Ly9TdGFyIE1hcC8uL3NyYy91dGlscy9hcGktdXRpbHMudHMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvLi9zcmMvdXRpbHMvYmlnLXZlYzMudHMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvLi9zcmMvdXRpbHMvZ2wtdXRpbHMudHMiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL1N0YXIgTWFwL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vU3RhciBNYXAvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9TdGFyIE1hcC93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL1N0YXIgTWFwL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9TdGFyIE1hcC93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICBDb3B5cmlnaHQgKGMpIDIwMjEgU2Vya2FuIMOWemVsLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kZ1xuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1DID0gZXhwb3J0cy5CaWcgPSBleHBvcnRzLkJpZ0RlY2ltYWwgPSBleHBvcnRzLk1hdGhDb250ZXh0ID0gZXhwb3J0cy5Sb3VuZGluZ01vZGUgPSB2b2lkIDA7XG4vKipcbiAqIFNwZWNpZmllcyBhIGByb3VuZGluZyBwb2xpY3lgIGZvciBudW1lcmljYWwgb3BlcmF0aW9ucyBjYXBhYmxlXG4gKiBvZiBkaXNjYXJkaW5nIHByZWNpc2lvbi4gRWFjaCByb3VuZGluZyBtb2RlIGluZGljYXRlcyBob3cgdGhlIGxlYXN0XG4gKiBzaWduaWZpY2FudCByZXR1cm5lZCBkaWdpdCBvZiBhIHJvdW5kZWQgcmVzdWx0IGlzIHRvIGJlIGNhbGN1bGF0ZWQuXG4gKiBJZiBmZXdlciBkaWdpdHMgYXJlIHJldHVybmVkIHRoYW4gdGhlIGRpZ2l0cyBuZWVkZWQgdG8gcmVwcmVzZW50XG4gKiB0aGUgZXhhY3QgbnVtZXJpY2FsIHJlc3VsdCwgdGhlIGRpc2NhcmRlZCBkaWdpdHMgd2lsbCBiZSByZWZlcnJlZFxuICogdG8gYXMgdGhlIGBkaXNjYXJkZWQgZnJhY3Rpb25gIHJlZ2FyZGxlc3MgdGhlIGRpZ2l0cydcbiAqIGNvbnRyaWJ1dGlvbiB0byB0aGUgdmFsdWUgb2YgdGhlIG51bWJlci4gIEluIG90aGVyIHdvcmRzLFxuICogY29uc2lkZXJlZCBhcyBhIG51bWVyaWNhbCB2YWx1ZSwgdGhlIGRpc2NhcmRlZCBmcmFjdGlvbiBjb3VsZCBoYXZlXG4gKiBhbiBhYnNvbHV0ZSB2YWx1ZSBncmVhdGVyIHRoYW4gb25lLlxuICpcbiAqIEVhY2ggcm91bmRpbmcgbW9kZSBkZXNjcmlwdGlvbiBpbmNsdWRlcyBhIHRhYmxlIGxpc3RpbmcgaG93XG4gKiBkaWZmZXJlbnQgdHdvLWRpZ2l0IGRlY2ltYWwgdmFsdWVzIHdvdWxkIHJvdW5kIHRvIGEgb25lIGRpZ2l0XG4gKiBkZWNpbWFsIHZhbHVlIHVuZGVyIHRoZSByb3VuZGluZyBtb2RlIGluIHF1ZXN0aW9uLiBUaGUgcmVzdWx0XG4gKiBjb2x1bW4gaW4gdGhlIHRhYmxlcyBjb3VsZCBiZSBnb3R0ZW4gYnkgY3JlYXRpbmcgYVxuICogYEJpZ0RlY2ltYWxgIG51bWJlciB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUsIGZvcm1pbmcgYVxuICoge0BsaW5rIE1hdGhDb250ZXh0fSBvYmplY3Qgd2l0aCB0aGUgcHJvcGVyIHNldHRpbmdzXG4gKiAoYHByZWNpc2lvbmAgc2V0IHRvIGAxYCwgYW5kIHRoZSBgcm91bmRpbmdNb2RlYCBzZXQgdG8gdGhlIHJvdW5kaW5nXG4gKiBtb2RlIGluIHF1ZXN0aW9uKSwgYW5kIGNhbGxpbmcge0BsaW5rIEJpZ0RlY2ltYWwucm91bmQgfCByb3VuZH0gb25cbiAqIHRoaXMgbnVtYmVyIHdpdGggdGhlIHByb3BlciBgTWF0aENvbnRleHRgLiAgQSBzdW1tYXJ5IHRhYmxlIHNob3dpbmcgdGhlIHJlc3VsdHNcbiAqIG9mIHRoZXNlIHJvdW5kaW5nIG9wZXJhdGlvbnMgZm9yIGFsbCByb3VuZGluZyBtb2RlcyBhcHBlYXJzIGJlbG93LlxuICpcbiAqIHwgSW5wdXQgfCBVUCB8IERPV04gfCBDRUlMSU5HIHwgRkxPT1IgfCBIQUxGX1VQIHwgSEFMRl9ET1dOIHwgSEFMRl9FVkVOIHwgVU5ORUNFU1NBUlkgfFxuICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuICogfCA1LjUgfCA2IHwgNSB8IDYgfCA1IHwgNiB8IDUgfCA2IHwgUmFuZ2VFcnJvciB8XG4gKiB8IDIuNSB8IDMgfCAyIHwgMyB8IDIgfCAzIHwgMiB8IDIgfCBSYW5nZUVycm9yIHxcbiAqIHwgMS42IHwgMiB8IDEgfCAyIHwgMSB8IDIgfCAyIHwgMiB8IFJhbmdlRXJyb3IgfFxuICogfCAxLjEgfCAyIHwgMSB8IDIgfCAxIHwgMSB8IDEgfCAxIHwgUmFuZ2VFcnJvciB8XG4gKiB8IDEuMCB8IDEgfCAxIHwgMSB8IDEgfCAxIHwgMSB8IDEgfCAxIHxcbiAqIHwgLTEuMCB8IC0xIHwgLTEgfCAtMSB8IC0xIHwgLTEgfCAtMSB8IC0xIHwgLTEgfFxuICogfCAtMS4xIHwgLTIgfCAtMSB8IC0xIHwgLTIgfCAtMSB8IC0xIHwgLTEgfCBSYW5nZUVycm9yIHxcbiAqIHwgLTEuNiB8IC0yIHwgLTEgfCAtMSB8IC0yIHwgLTIgfCAtMiB8IC0yIHwgUmFuZ2VFcnJvciB8XG4gKiB8IC0yLjUgfCAtMyB8IC0yIHwgLTIgfCAtMyB8IC0zIHwgLTIgfCAtMiB8IFJhbmdlRXJyb3IgfFxuICogfCAtNS41IHwgLTYgfCAtNSB8IC01IHwgLTYgfCAtNiB8IC01IHwgLTYgfCBSYW5nZUVycm9yIHxcbiAqXG4gKi9cbnZhciBSb3VuZGluZ01vZGU7XG4oZnVuY3Rpb24gKFJvdW5kaW5nTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFJvdW5kaW5nIG1vZGUgdG8gcm91bmQgYXdheSBmcm9tIHplcm8uICBBbHdheXMgaW5jcmVtZW50cyB0aGVcbiAgICAgKiBkaWdpdCBwcmlvciB0byBhIG5vbi16ZXJvIGRpc2NhcmRlZCBmcmFjdGlvbi4gIE5vdGUgdGhhdCB0aGlzXG4gICAgICogcm91bmRpbmcgbW9kZSBuZXZlciBkZWNyZWFzZXMgdGhlIG1hZ25pdHVkZSBvZiB0aGUgY2FsY3VsYXRlZFxuICAgICAqIHZhbHVlLlxuICAgICAqL1xuICAgIFJvdW5kaW5nTW9kZVtSb3VuZGluZ01vZGVbXCJVUFwiXSA9IDBdID0gXCJVUFwiO1xuICAgIC8qKlxuICAgICAqIFJvdW5kaW5nIG1vZGUgdG8gcm91bmQgdG93YXJkcyB6ZXJvLiAgTmV2ZXIgaW5jcmVtZW50cyB0aGUgZGlnaXRcbiAgICAgKiBwcmlvciB0byBhIGRpc2NhcmRlZCBmcmFjdGlvbiAoaS5lLiwgdHJ1bmNhdGVzKS4gIE5vdGUgdGhhdCB0aGlzXG4gICAgICogcm91bmRpbmcgbW9kZSBuZXZlciBpbmNyZWFzZXMgdGhlIG1hZ25pdHVkZSBvZiB0aGUgY2FsY3VsYXRlZCB2YWx1ZS5cbiAgICAgKiBUaGlzIG1vZGUgY29ycmVzcG9uZHMgdG8gdGhlIElFRUUgNzU0LTIwMTkgcm91bmRpbmctZGlyZWN0aW9uXG4gICAgICogYXR0cmlidXRlIFwicm91bmRUb3dhcmRaZXJvXCIuXG4gICAgICovXG4gICAgUm91bmRpbmdNb2RlW1JvdW5kaW5nTW9kZVtcIkRPV05cIl0gPSAxXSA9IFwiRE9XTlwiO1xuICAgIC8qKlxuICAgICAqIFJvdW5kaW5nIG1vZGUgdG8gcm91bmQgdG93YXJkcyBwb3NpdGl2ZSBpbmZpbml0eS4gIElmIHRoZVxuICAgICAqIHJlc3VsdCBpcyBwb3NpdGl2ZSwgYmVoYXZlcyBhcyBmb3IgYFJvdW5kaW5nTW9kZS5VUGA7XG4gICAgICogaWYgbmVnYXRpdmUsIGJlaGF2ZXMgYXMgZm9yIGBSb3VuZGluZ01vZGUuRE9XTmAuICBOb3RlXG4gICAgICogdGhhdCB0aGlzIHJvdW5kaW5nIG1vZGUgbmV2ZXIgZGVjcmVhc2VzIHRoZSBjYWxjdWxhdGVkIHZhbHVlLlxuICAgICAqIFRoaXMgbW9kZSBjb3JyZXNwb25kcyB0byB0aGUgSUVFRSA3NTQtMjAxOSByb3VuZGluZy1kaXJlY3Rpb25cbiAgICAgKiBhdHRyaWJ1dGUgXCJyb3VuZFRvd2FyZFBvc2l0aXZlXCIuXG4gICAgICovXG4gICAgUm91bmRpbmdNb2RlW1JvdW5kaW5nTW9kZVtcIkNFSUxJTkdcIl0gPSAyXSA9IFwiQ0VJTElOR1wiO1xuICAgIC8qKlxuICAgICAqIFJvdW5kaW5nIG1vZGUgdG8gcm91bmQgdG93YXJkcyBuZWdhdGl2ZSBpbmZpbml0eS4gIElmIHRoZVxuICAgICAqIHJlc3VsdCBpcyBwb3NpdGl2ZSwgYmVoYXZlIGFzIGZvciBgUm91bmRpbmdNb2RlLkRPV05gO1xuICAgICAqIGlmIG5lZ2F0aXZlLCBiZWhhdmUgYXMgZm9yIGBSb3VuZGluZ01vZGUuVVBgLiAgTm90ZSB0aGF0XG4gICAgICogdGhpcyByb3VuZGluZyBtb2RlIG5ldmVyIGluY3JlYXNlcyB0aGUgY2FsY3VsYXRlZCB2YWx1ZS5cbiAgICAgKiBUaGlzIG1vZGUgY29ycmVzcG9uZHMgdG8gdGhlIElFRUUgNzU0LTIwMTkgcm91bmRpbmctZGlyZWN0aW9uXG4gICAgICogYXR0cmlidXRlIFwicm91bmRUb3dhcmROZWdhdGl2ZVwiLlxuICAgICAqL1xuICAgIFJvdW5kaW5nTW9kZVtSb3VuZGluZ01vZGVbXCJGTE9PUlwiXSA9IDNdID0gXCJGTE9PUlwiO1xuICAgIC8qKlxuICAgICAqIFJvdW5kaW5nIG1vZGUgdG8gcm91bmQgdG93YXJkcyBcIm5lYXJlc3QgbmVpZ2hib3JcIlxuICAgICAqIHVubGVzcyBib3RoIG5laWdoYm9ycyBhcmUgZXF1aWRpc3RhbnQsIGluIHdoaWNoIGNhc2Ugcm91bmQgdXAuXG4gICAgICogQmVoYXZlcyBhcyBmb3IgYFJvdW5kaW5nTW9kZS5VUGAgaWYgdGhlIGRpc2NhcmRlZFxuICAgICAqIGZyYWN0aW9uIGlzICZnZTsgMC41OyBvdGhlcndpc2UsIGJlaGF2ZXMgYXMgZm9yXG4gICAgICogYFJvdW5kaW5nTW9kZS5ET1dOYC4gIE5vdGUgdGhhdCB0aGlzIGlzIHRoZSByb3VuZGluZ1xuICAgICAqIG1vZGUgY29tbW9ubHkgdGF1Z2h0IGF0IHNjaG9vbC5cbiAgICAgKiBUaGlzIG1vZGUgY29ycmVzcG9uZHMgdG8gdGhlIElFRUUgNzU0LTIwMTkgcm91bmRpbmctZGlyZWN0aW9uXG4gICAgICogYXR0cmlidXRlIFwicm91bmRUaWVzVG9Bd2F5XCIuXG4gICAgICovXG4gICAgUm91bmRpbmdNb2RlW1JvdW5kaW5nTW9kZVtcIkhBTEZfVVBcIl0gPSA0XSA9IFwiSEFMRl9VUFwiO1xuICAgIC8qKlxuICAgICAqIFJvdW5kaW5nIG1vZGUgdG8gcm91bmQgdG93YXJkcyBcIm5lYXJlc3QgbmVpZ2hib3JcIlxuICAgICAqIHVubGVzcyBib3RoIG5laWdoYm9ycyBhcmUgZXF1aWRpc3RhbnQsIGluIHdoaWNoIGNhc2Ugcm91bmRcbiAgICAgKiBkb3duLiAgQmVoYXZlcyBhcyBmb3IgYFJvdW5kaW5nTW9kZS5VUGAgaWYgdGhlIGRpc2NhcmRlZFxuICAgICAqIGZyYWN0aW9uIGlzICZndDsgMC41OyBvdGhlcndpc2UsIGJlaGF2ZXMgYXMgZm9yXG4gICAgICogYFJvdW5kaW5nTW9kZS5ET1dOYC5cbiAgICAgKi9cbiAgICBSb3VuZGluZ01vZGVbUm91bmRpbmdNb2RlW1wiSEFMRl9ET1dOXCJdID0gNV0gPSBcIkhBTEZfRE9XTlwiO1xuICAgIC8qKlxuICAgICAqIFJvdW5kaW5nIG1vZGUgdG8gcm91bmQgdG93YXJkcyB0aGUgXCJuZWFyZXN0IG5laWdoYm9yXCJcbiAgICAgKiB1bmxlc3MgYm90aCBuZWlnaGJvcnMgYXJlIGVxdWlkaXN0YW50LCBpbiB3aGljaCBjYXNlLCByb3VuZFxuICAgICAqIHRvd2FyZHMgdGhlIGV2ZW4gbmVpZ2hib3IuICBCZWhhdmVzIGFzIGZvclxuICAgICAqIGBSb3VuZGluZ01vZGUuSEFMRl9VUGAgaWYgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZVxuICAgICAqIGRpc2NhcmRlZCBmcmFjdGlvbiBpcyBvZGQ7IGJlaGF2ZXMgYXMgZm9yXG4gICAgICogYFJvdW5kaW5nTW9kZS5IQUxGX0RPV05gIGlmIGl0J3MgZXZlbi4gIE5vdGUgdGhhdCB0aGlzXG4gICAgICogaXMgdGhlIHJvdW5kaW5nIG1vZGUgdGhhdCBzdGF0aXN0aWNhbGx5IG1pbmltaXplcyBjdW11bGF0aXZlXG4gICAgICogZXJyb3Igd2hlbiBhcHBsaWVkIHJlcGVhdGVkbHkgb3ZlciBhIHNlcXVlbmNlIG9mIGNhbGN1bGF0aW9ucy5cbiAgICAgKiBJdCBpcyBzb21ldGltZXMga25vd24gYXMgXCJCYW5rZXIncyByb3VuZGluZyxcIiBhbmQgaXNcbiAgICAgKiBjaGllZmx5IHVzZWQgaW4gdGhlIFVTQS5cbiAgICAgKiBUaGlzIG1vZGUgY29ycmVzcG9uZHMgdG8gdGhlIElFRUUgNzU0LTIwMTkgcm91bmRpbmctZGlyZWN0aW9uXG4gICAgICogYXR0cmlidXRlIFwicm91bmRUaWVzVG9FdmVuXCIuXG4gICAgICovXG4gICAgUm91bmRpbmdNb2RlW1JvdW5kaW5nTW9kZVtcIkhBTEZfRVZFTlwiXSA9IDZdID0gXCJIQUxGX0VWRU5cIjtcbiAgICAvKipcbiAgICAgKiBSb3VuZGluZyBtb2RlIHRvIGFzc2VydCB0aGF0IHRoZSByZXF1ZXN0ZWQgb3BlcmF0aW9uIGhhcyBhbiBleGFjdFxuICAgICAqIHJlc3VsdCwgaGVuY2Ugbm8gcm91bmRpbmcgaXMgbmVjZXNzYXJ5LiAgSWYgdGhpcyByb3VuZGluZyBtb2RlIGlzXG4gICAgICogc3BlY2lmaWVkIG9uIGFuIG9wZXJhdGlvbiB0aGF0IHlpZWxkcyBhbiBpbmV4YWN0IHJlc3VsdCwgYW5cbiAgICAgKiBgUmFuZ2VFcnJvcmAgaXMgdGhyb3duLlxuICAgICAqL1xuICAgIFJvdW5kaW5nTW9kZVtSb3VuZGluZ01vZGVbXCJVTk5FQ0VTU0FSWVwiXSA9IDddID0gXCJVTk5FQ0VTU0FSWVwiO1xufSkoUm91bmRpbmdNb2RlIHx8IChleHBvcnRzLlJvdW5kaW5nTW9kZSA9IFJvdW5kaW5nTW9kZSA9IHt9KSk7XG4vKipcbiAqIEltbXV0YWJsZSBvYmplY3RzIHdoaWNoIGVuY2Fwc3VsYXRlIHRoZSBjb250ZXh0IHNldHRpbmdzIHdoaWNoXG4gKiBkZXNjcmliZSBjZXJ0YWluIHJ1bGVzIGZvciBudW1lcmljYWwgb3BlcmF0b3JzLCBzdWNoIGFzIHRob3NlXG4gKiBpbXBsZW1lbnRlZCBieSB0aGUge0BsaW5rIEJpZ0RlY2ltYWx9IGNsYXNzLlxuICpcbiAqIFRoZSBiYXNlLWluZGVwZW5kZW50IHNldHRpbmdzIGFyZTpcbiAqXG4gKiAqIHByZWNpc2lvbjogdGhlIG51bWJlciBvZiBkaWdpdHMgdG8gYmUgdXNlZCBmb3IgYW4gb3BlcmF0aW9uOyByZXN1bHRzIGFyZVxuICogcm91bmRlZCB0byB0aGlzIHByZWNpc2lvblxuICogKiByb3VuZGluZ01vZGU6IGEge0BsaW5rIFJvdW5kaW5nTW9kZX0gb2JqZWN0IHdoaWNoIHNwZWNpZmllcyB0aGUgYWxnb3JpdGhtIHRvIGJlXG4gKiB1c2VkIGZvciByb3VuZGluZy5cbiAqXG4gKiBTYW1wbGUgVXNhZ2U6XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCB7IEJpZywgTUMsIFJvdW5kaW5nTW9kZSB9ID0gcmVxdWlyZSgnYmlnZGVjaW1hbC5qcycpO1xuICpcbiAqIGNvbnN0IHggPSBCaWcoJzEnKTtcbiAqIGNvbnN0IHkgPSBCaWcoJzMnKTtcbiAqXG4gKiBjb25zdCByZXMxID0geC5kaXZpZGVXaXRoTWF0aENvbnRleHQoeSwgbmV3IE1DKDMpKTtcbiAqIGNvbnNvbGUubG9nKHJlczEudG9TdHJpbmcoKSk7IC8vIDAuMzMzXG4gKlxuICogLy8gWW91IGNhbiBhbHNvIHVzZSB3aXRob3V0IGBuZXdgIG9wZXJhdG9yXG4gKiBjb25zdCByZXMyID0geC5kaXZpZGVXaXRoTWF0aENvbnRleHQoeSwgTUMoMywgUm91bmRpbmdNb2RlLlVQKSk7XG4gKiBjb25zb2xlLmxvZyhyZXMyLnRvU3RyaW5nKCkpOyAvLyAwLjMzNFxuICpcbiAqIHRyeSB7XG4gKiAgICAgeC5kaXZpZGUoeSk7XG4gKiAgICAgLy8gdGhyb3dzIHNpbmNlIGZ1bGwgcHJlY2lzaW9uIGlzIHJlcXVlc3RlZCBidXQgaXQgaXMgbm90IHBvc3NpYmxlXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7IC8vIFJhbmdlRXJyb3I6IE5vbi10ZXJtaW5hdGluZyBkZWNpbWFsIGV4cGFuc2lvbjsgbm8gZXhhY3QgcmVwcmVzZW50YWJsZSBkZWNpbWFsIHJlc3VsdC5cbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBNYXRoQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocHJlY2lzaW9uLCByb3VuZGluZ01vZGUgPSBNYXRoQ29udGV4dC5ERUZBVUxUX1JPVU5ESU5HTU9ERSkge1xuICAgICAgICBpZiAocHJlY2lzaW9uIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdGhDb250ZXh0IHByZWNpc2lvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghUm91bmRpbmdNb2RlW3JvdW5kaW5nTW9kZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJvdW5kaW5nTW9kZSBpcyBpbnZhbGlkOiAke3JvdW5kaW5nTW9kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgICAgdGhpcy5yb3VuZGluZ01vZGUgPSByb3VuZGluZ01vZGU7XG4gICAgfVxufVxuZXhwb3J0cy5NYXRoQ29udGV4dCA9IE1hdGhDb250ZXh0O1xuLyoqIEBpbnRlcm5hbCAqL1xuTWF0aENvbnRleHQuREVGQVVMVF9ST1VORElOR01PREUgPSBSb3VuZGluZ01vZGUuSEFMRl9VUDtcbi8qKlxuICogQSBgTWF0aENvbnRleHRgIG9iamVjdCB3aG9zZSBzZXR0aW5ncyBoYXZlIHRoZSB2YWx1ZXNcbiAqIHJlcXVpcmVkIGZvciB1bmxpbWl0ZWQgcHJlY2lzaW9uIGFyaXRobWV0aWMuXG4gKiBUaGUgdmFsdWVzIG9mIHRoZSBzZXR0aW5ncyBhcmU6IGBwcmVjaXNpb249MCByb3VuZGluZ01vZGU9SEFMRl9VUGBcbiAqL1xuTWF0aENvbnRleHQuVU5MSU1JVEVEID0gbmV3IE1hdGhDb250ZXh0KDAsIFJvdW5kaW5nTW9kZS5IQUxGX1VQKTtcbi8qKlxuICogQSBgTWF0aENvbnRleHRgIG9iamVjdCB3aXRoIGEgcHJlY2lzaW9uIHNldHRpbmdcbiAqIG1hdGNoaW5nIHRoZSBwcmVjaXNpb24gb2YgdGhlIElFRUUgNzU0LTIwMTkgZGVjaW1hbDMyIGZvcm1hdCwgNyBkaWdpdHMsIGFuZCBhXG4gKiByb3VuZGluZyBtb2RlIG9mIHtAbGluayBSb3VuZGluZ01vZGUuSEFMRl9FVkVOIHwgIEhBTEZfRVZFTn0uXG4gKiBOb3RlIHRoZSBleHBvbmVudCByYW5nZSBvZiBkZWNpbWFsMzIgaXMgKipub3QqKiB1c2VkIGZvclxuICogcm91bmRpbmcuXG4gKi9cbk1hdGhDb250ZXh0LkRFQ0lNQUwzMiA9IG5ldyBNYXRoQ29udGV4dCg3LCBSb3VuZGluZ01vZGUuSEFMRl9FVkVOKTtcbi8qKlxuICogQSBgTWF0aENvbnRleHRgIG9iamVjdCB3aXRoIGEgcHJlY2lzaW9uIHNldHRpbmdcbiAqIG1hdGNoaW5nIHRoZSBwcmVjaXNpb24gb2YgdGhlIElFRUUgNzU0LTIwMTkgZGVjaW1hbDY0IGZvcm1hdCwgMTYgZGlnaXRzLCBhbmQgYVxuICogcm91bmRpbmcgbW9kZSBvZiB7QGxpbmsgUm91bmRpbmdNb2RlLkhBTEZfRVZFTiB8IEhBTEZfRVZFTn0uXG4gKiBOb3RlIHRoZSBleHBvbmVudCByYW5nZSBvZiBkZWNpbWFsNjQgaXMgKipub3QqKiB1c2VkIGZvclxuICogcm91bmRpbmcuXG4gKi9cbk1hdGhDb250ZXh0LkRFQ0lNQUw2NCA9IG5ldyBNYXRoQ29udGV4dCgxNiwgUm91bmRpbmdNb2RlLkhBTEZfRVZFTik7XG4vKipcbiAqIEEgYE1hdGhDb250ZXh0YCBvYmplY3Qgd2l0aCBhIHByZWNpc2lvbiBzZXR0aW5nXG4gKiBtYXRjaGluZyB0aGUgcHJlY2lzaW9uIG9mIHRoZSBJRUVFIDc1NC0yMDE5IGRlY2ltYWwxMjggZm9ybWF0LCAzNCBkaWdpdHMsIGFuZCBhXG4gKiByb3VuZGluZyBtb2RlIG9mIHtAbGluayBSb3VuZGluZ01vZGUuSEFMRl9FVkVOIHwgSEFMRl9FVkVOfS5cbiAqIE5vdGUgdGhlIGV4cG9uZW50IHJhbmdlIG9mIGRlY2ltYWw2NCBpcyAqKm5vdCoqIHVzZWQgZm9yXG4gKiByb3VuZGluZy5cbiAqL1xuTWF0aENvbnRleHQuREVDSU1BTDEyOCA9IG5ldyBNYXRoQ29udGV4dCgzNCwgUm91bmRpbmdNb2RlLkhBTEZfRVZFTik7XG4vKipcbiAqIFtCaWdJbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0JpZ0ludCkgYmFzZWQgQmlnRGVjaW1hbFxuICogaW1wbGVtZW50YXRpb24uIFRoaXMgY2xhc3MgaXMgcG9ydGVkIGZyb20gamF2YS5tYXRoLkJpZ0RlY2ltYWwuIFRoZSBmb2xsb3dpbmcgZG9jdW1lbnRhdGlvbiBpcyBhZGFwdGVkIGZyb20gb3Blbmpkay9qZGtcbiAqIHJlcG9zaXRvcnkuXG4gKlxuICogSW1tdXRhYmxlLCBhcmJpdHJhcnktcHJlY2lzaW9uIHNpZ25lZCBkZWNpbWFsIG51bWJlcnMuICBBXG4gKiBgQmlnRGVjaW1hbGAgY29uc2lzdHMgb2YgYW4gYXJiaXRyYXJ5IHByZWNpc2lvbiBudW1iZXJcbiAqIHtAbGluayB1bnNjYWxlZFZhbHVlIHwgdW5zY2FsZWQgdmFsdWV9IGFuZCBhIHtAbGluayBzY2FsZSB8IHNjYWxlfS5cbiAqIElmIHplcm8gb3IgcG9zaXRpdmUsIHRoZSBzY2FsZSBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyB0byB0aGUgcmlnaHQgb2YgdGhlIGRlY2ltYWxcbiAqIHBvaW50LiBJZiBuZWdhdGl2ZSwgdGhlIHVuc2NhbGVkIHZhbHVlIG9mIHRoZSBudW1iZXIgaXMgbXVsdGlwbGllZFxuICogYnkgdGVuIHRvIHRoZSBwb3dlciBvZiB0aGUgbmVnYXRpb24gb2YgdGhlIHNjYWxlLiAgVGhlIHZhbHVlIG9mIHRoZVxuICogbnVtYmVyIHJlcHJlc2VudGVkIGJ5IHRoZSBgQmlnRGVjaW1hbGAgaXMgdGhlcmVmb3JlXG4gKiA8Y29kZT4odW5zY2FsZWRWYWx1ZSAmdGltZXM7IDEwPHN1cD4tc2NhbGU8L3N1cD4pPC9jb2RlPi5cbiAqXG4gKiBUaGUgYEJpZ0RlY2ltYWxgIGNsYXNzIHByb3ZpZGVzIG9wZXJhdGlvbnMgZm9yXG4gKiBhcml0aG1ldGljLCBzY2FsZSBtYW5pcHVsYXRpb24sIHJvdW5kaW5nLCBjb21wYXJpc29uLCBoYXNoaW5nLCBhbmRcbiAqIGZvcm1hdCBjb252ZXJzaW9uLiAgVGhlIHtAbGluayB0b1N0cmluZ30gbWV0aG9kIHByb3ZpZGVzIGFcbiAqIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhIGBCaWdEZWNpbWFsYC5cbiAqXG4gKiBUaGUgYEJpZ0RlY2ltYWxgIGNsYXNzIGdpdmVzIGl0cyB1c2VyIGNvbXBsZXRlIGNvbnRyb2xcbiAqIG92ZXIgcm91bmRpbmcgYmVoYXZpb3IuICBJZiBubyByb3VuZGluZyBtb2RlIGlzIHNwZWNpZmllZCBhbmQgdGhlXG4gKiBleGFjdCByZXN1bHQgY2Fubm90IGJlIHJlcHJlc2VudGVkLCBhIGBSYW5nZUVycm9yYFxuICogaXMgdGhyb3duOyBvdGhlcndpc2UsIGNhbGN1bGF0aW9ucyBjYW4gYmUgY2FycmllZCBvdXQgdG8gYSBjaG9zZW5cbiAqIHByZWNpc2lvbiBhbmQgcm91bmRpbmcgbW9kZSBieSBzdXBwbHlpbmcgYW4gYXBwcm9wcmlhdGUge0BsaW5rXG4gKiBNYXRoQ29udGV4dH0gb2JqZWN0IHRvIHRoZSBvcGVyYXRpb24uICBJbiBlaXRoZXIgY2FzZSwgZWlnaHRcbiAqIDxlbT5yb3VuZGluZyBtb2RlczwvZW0+IGFyZSBwcm92aWRlZCBmb3IgdGhlIGNvbnRyb2wgb2Ygcm91bmRpbmcuXG4gKlxuICogV2hlbiBhIGBNYXRoQ29udGV4dGAgb2JqZWN0IGlzIHN1cHBsaWVkIHdpdGggYSBwcmVjaXNpb25cbiAqIHNldHRpbmcgb2YgMCAoZm9yIGV4YW1wbGUsIHtAbGluayBNYXRoQ29udGV4dC5VTkxJTUlURUR9KSxcbiAqIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBhcmUgZXhhY3QsIGFzIGFyZSB0aGUgYXJpdGhtZXRpYyBtZXRob2RzXG4gKiB3aGljaCB0YWtlIG5vIGBNYXRoQ29udGV4dGAgb2JqZWN0LiBBcyBhIGNvcm9sbGFyeSBvZlxuICogY29tcHV0aW5nIHRoZSBleGFjdCByZXN1bHQsIHRoZSByb3VuZGluZyBtb2RlIHNldHRpbmcgb2YgYSBgXG4gKiBNYXRoQ29udGV4dGAgb2JqZWN0IHdpdGggYSBwcmVjaXNpb24gc2V0dGluZyBvZiAwIGlzIG5vdCB1c2VkIGFuZFxuICogdGh1cyBpcnJlbGV2YW50LiAgSW4gdGhlIGNhc2Ugb2YgZGl2aWRlLCB0aGUgZXhhY3QgcXVvdGllbnQgY291bGRcbiAqIGhhdmUgYW4gaW5maW5pdGVseSBsb25nIGRlY2ltYWwgZXhwYW5zaW9uOyBmb3IgZXhhbXBsZSwgMSBkaXZpZGVkXG4gKiBieSAzLiAgSWYgdGhlIHF1b3RpZW50IGhhcyBhIG5vbi10ZXJtaW5hdGluZyBkZWNpbWFsIGV4cGFuc2lvbiBhbmRcbiAqIHRoZSBvcGVyYXRpb24gaXMgc3BlY2lmaWVkIHRvIHJldHVybiBhbiBleGFjdCByZXN1bHQsIGEgUmFuZ2VFcnJvclxuICogaXMgdGhyb3duLiAgT3RoZXJ3aXNlLCB0aGUgZXhhY3QgcmVzdWx0IG9mIHRoZVxuICogZGl2aXNpb24gaXMgcmV0dXJuZWQsIGFzIGRvbmUgZm9yIG90aGVyIG9wZXJhdGlvbnMuXG4gKlxuICogV2hlbiB0aGUgcHJlY2lzaW9uIHNldHRpbmcgaXMgbm90IDAsIHRoZSBydWxlcyBvZiBgQmlnRGVjaW1hbGBcbiAqIGFyaXRobWV0aWMgYXJlIGJyb2FkbHkgY29tcGF0aWJsZSB3aXRoIHNlbGVjdGVkIG1vZGVzXG4gKiBvZiBvcGVyYXRpb24gb2YgdGhlIGFyaXRobWV0aWMgZGVmaW5lZCBpbiBBTlNJIFgzLjI3NC0xOTk2IGFuZCBBTlNJXG4gKiBYMy4yNzQtMTk5Ni9BTSAxLTIwMDAgKHNlY3Rpb24gNy40KS4gIFVubGlrZSB0aG9zZSBzdGFuZGFyZHMsXG4gKiBgQmlnRGVjaW1hbGAgaW5jbHVkZXMgbWFueSByb3VuZGluZyBtb2Rlcy4gIEFueSBjb25mbGljdHNcbiAqIGJldHdlZW4gdGhlc2UgQU5TSSBzdGFuZGFyZHMgYW5kIHRoZSBgQmlnRGVjaW1hbGBcbiAqIHNwZWNpZmljYXRpb24gYXJlIHJlc29sdmVkIGluIGZhdm9yIG9mIGBCaWdEZWNpbWFsYC5cbiAqXG4gKiBTaW5jZSB0aGUgc2FtZSBudW1lcmljYWwgdmFsdWUgY2FuIGhhdmUgZGlmZmVyZW50XG4gKiByZXByZXNlbnRhdGlvbnMgKHdpdGggZGlmZmVyZW50IHNjYWxlcyksIHRoZSBydWxlcyBvZiBhcml0aG1ldGljXG4gKiBhbmQgcm91bmRpbmcgbXVzdCBzcGVjaWZ5IGJvdGggdGhlIG51bWVyaWNhbCByZXN1bHQgYW5kIHRoZSBzY2FsZVxuICogdXNlZCBpbiB0aGUgcmVzdWx0J3MgcmVwcmVzZW50YXRpb24uXG4gKlxuICogVGhlIGRpZmZlcmVudCByZXByZXNlbnRhdGlvbnMgb2YgdGhlIHNhbWUgbnVtZXJpY2FsIHZhbHVlIGFyZVxuICogY2FsbGVkIG1lbWJlcnMgb2YgdGhlIHNhbWUgPGk+Y29ob3J0PC9pPi4gVGhlIHtAbGlua1xuICogY29tcGFyZVRvIHwgIG5hdHVyYWwgb3JkZXJ9IG9mIGBCaWdEZWNpbWFsYFxuICogY29uc2lkZXJzIG1lbWJlcnMgb2YgdGhlIHNhbWUgY29ob3J0IHRvIGJlIGVxdWFsIHRvIGVhY2ggb3RoZXIuIEluXG4gKiBjb250cmFzdCwgdGhlIHtAbGluayBlcXVhbHMgfCBlcXVhbHN9IG1ldGhvZCByZXF1aXJlcyBib3RoIHRoZVxuICogbnVtZXJpY2FsIHZhbHVlIGFuZCByZXByZXNlbnRhdGlvbiB0byBiZSB0aGUgc2FtZSBmb3IgZXF1YWxpdHkgdG9cbiAqIGhvbGQuIFRoZSByZXN1bHRzIG9mIG1ldGhvZHMgbGlrZSB7QGxpbmsgc2NhbGV9IGFuZCB7QGxpbmtcbiAqIHVuc2NhbGVkVmFsdWV9IHdpbGwgZGlmZmVyIGZvciBudW1lcmljYWxseSBlcXVhbCB2YWx1ZXMgd2l0aFxuICogZGlmZmVyZW50IHJlcHJlc2VudGF0aW9ucy5cbiAqXG4gKiBJbiBnZW5lcmFsIHRoZSByb3VuZGluZyBtb2RlcyBhbmQgcHJlY2lzaW9uIHNldHRpbmcgZGV0ZXJtaW5lXG4gKiBob3cgb3BlcmF0aW9ucyByZXR1cm4gcmVzdWx0cyB3aXRoIGEgbGltaXRlZCBudW1iZXIgb2YgZGlnaXRzIHdoZW5cbiAqIHRoZSBleGFjdCByZXN1bHQgaGFzIG1vcmUgZGlnaXRzIChwZXJoYXBzIGluZmluaXRlbHkgbWFueSBpbiB0aGVcbiAqIGNhc2Ugb2YgZGl2aXNpb24gYW5kIHNxdWFyZSByb290KSB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIHJldHVybmVkLlxuICpcbiAqIEZpcnN0LCB0aGUgdG90YWwgbnVtYmVyIG9mIGRpZ2l0cyB0byByZXR1cm4gaXMgc3BlY2lmaWVkIGJ5IHRoZVxuICogYE1hdGhDb250ZXh0YCdzIGBwcmVjaXNpb25gIHNldHRpbmc7IHRoaXMgZGV0ZXJtaW5lc1xuICogdGhlIHJlc3VsdCdzIDxpPnByZWNpc2lvbjwvaT4uICBUaGUgZGlnaXQgY291bnQgc3RhcnRzIGZyb20gdGhlXG4gKiBsZWZ0bW9zdCBub256ZXJvIGRpZ2l0IG9mIHRoZSBleGFjdCByZXN1bHQuICBUaGUgcm91bmRpbmcgbW9kZVxuICogZGV0ZXJtaW5lcyBob3cgYW55IGRpc2NhcmRlZCB0cmFpbGluZyBkaWdpdHMgYWZmZWN0IHRoZSByZXR1cm5lZFxuICogcmVzdWx0LlxuICpcbiAqIEZvciBhbGwgYXJpdGhtZXRpYyBvcGVyYXRvcnMsIHRoZSBvcGVyYXRpb24gaXMgY2FycmllZCBvdXQgYXNcbiAqIHRob3VnaCBhbiBleGFjdCBpbnRlcm1lZGlhdGUgcmVzdWx0IHdlcmUgZmlyc3QgY2FsY3VsYXRlZCBhbmQgdGhlblxuICogcm91bmRlZCB0byB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBzcGVjaWZpZWQgYnkgdGhlIHByZWNpc2lvbiBzZXR0aW5nXG4gKiAoaWYgbmVjZXNzYXJ5KSwgdXNpbmcgdGhlIHNlbGVjdGVkIHJvdW5kaW5nIG1vZGUuICBJZiB0aGUgZXhhY3RcbiAqIHJlc3VsdCBpcyBub3QgcmV0dXJuZWQsIHNvbWUgZGlnaXQgcG9zaXRpb25zIG9mIHRoZSBleGFjdCByZXN1bHRcbiAqIGFyZSBkaXNjYXJkZWQuICBXaGVuIHJvdW5kaW5nIGluY3JlYXNlcyB0aGUgbWFnbml0dWRlIG9mIHRoZVxuICogcmV0dXJuZWQgcmVzdWx0LCBpdCBpcyBwb3NzaWJsZSBmb3IgYSBuZXcgZGlnaXQgcG9zaXRpb24gdG8gYmVcbiAqIGNyZWF0ZWQgYnkgYSBjYXJyeSBwcm9wYWdhdGluZyB0byBhIGxlYWRpbmcgXCI5XCIgZGlnaXQuXG4gKiBGb3IgZXhhbXBsZSwgcm91bmRpbmcgdGhlIHZhbHVlIDk5OS45IHRvIHRocmVlIGRpZ2l0cyByb3VuZGluZyB1cFxuICogd291bGQgYmUgbnVtZXJpY2FsbHkgZXF1YWwgdG8gb25lIHRob3VzYW5kLCByZXByZXNlbnRlZCBhc1xuICogMTAwJnRpbWVzOzEwPHN1cD4xPC9zdXA+LiAgSW4gc3VjaCBjYXNlcywgdGhlIG5ldyBcIjFcIiBpc1xuICogdGhlIGxlYWRpbmcgZGlnaXQgcG9zaXRpb24gb2YgdGhlIHJldHVybmVkIHJlc3VsdC5cbiAqXG4gKiBGb3IgbWV0aG9kcyBhbmQgY29uc3RydWN0b3JzIHdpdGggYSBgTWF0aENvbnRleHRgXG4gKiBwYXJhbWV0ZXIsIGlmIHRoZSByZXN1bHQgaXMgaW5leGFjdCBidXQgdGhlIHJvdW5kaW5nIG1vZGUgaXMge0BsaW5rXG4gKiBSb3VuZGluZ01vZGUuVU5ORUNFU1NBUlkgfCBVTk5FQ0VTU0FSWX0sIGEgUmFuZ2VFcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBCZXNpZGVzIGEgbG9naWNhbCBleGFjdCByZXN1bHQsIGVhY2ggYXJpdGhtZXRpYyBvcGVyYXRpb24gaGFzIGFcbiAqIHByZWZlcnJlZCBzY2FsZSBmb3IgcmVwcmVzZW50aW5nIGEgcmVzdWx0LiAgVGhlIHByZWZlcnJlZFxuICogc2NhbGUgZm9yIGVhY2ggb3BlcmF0aW9uIGlzIGxpc3RlZCBpbiB0aGUgdGFibGUgYmVsb3cuXG4gKlxuICogPHRhYmxlIGNsYXNzPVwic3RyaXBlZFwiIHN0eWxlPVwidGV4dC1hbGlnbjpsZWZ0XCI+XG4gKiA8Y2FwdGlvbj5QcmVmZXJyZWQgU2NhbGVzIGZvciBSZXN1bHRzIG9mIEFyaXRobWV0aWMgT3BlcmF0aW9uc1xuICogPC9jYXB0aW9uPlxuICogPHRoZWFkPlxuICogPHRyPjx0aCBzY29wZT1cImNvbFwiPk9wZXJhdGlvbjwvdGg+PHRoIHNjb3BlPVwiY29sXCI+UHJlZmVycmVkIFNjYWxlIG9mIFJlc3VsdDwvdGg+PC90cj5cbiAqIDwvdGhlYWQ+XG4gKiA8dGJvZHk+XG4gKiA8dHI+PHRoIHNjb3BlPVwicm93XCI+QWRkPC90aD48dGQ+bWF4KGFkZGVuZC5zY2FsZSgpLCBhdWdlbmQuc2NhbGUoKSk8L3RkPlxuICogPHRyPjx0aCBzY29wZT1cInJvd1wiPlN1YnRyYWN0PC90aD48dGQ+bWF4KG1pbnVlbmQuc2NhbGUoKSwgc3VidHJhaGVuZC5zY2FsZSgpKTwvdGQ+XG4gKiA8dHI+PHRoIHNjb3BlPVwicm93XCI+TXVsdGlwbHk8L3RoPjx0ZD5tdWx0aXBsaWVyLnNjYWxlKCkgKyBtdWx0aXBsaWNhbmQuc2NhbGUoKTwvdGQ+XG4gKiA8dHI+PHRoIHNjb3BlPVwicm93XCI+RGl2aWRlPC90aD48dGQ+ZGl2aWRlbmQuc2NhbGUoKSAtIGRpdmlzb3Iuc2NhbGUoKTwvdGQ+XG4gKiA8dHI+PHRoIHNjb3BlPVwicm93XCI+U3F1YXJlIHJvb3Q8L3RoPjx0ZD5yYWRpY2FuZC5zY2FsZSgpLzI8L3RkPlxuICogPC90Ym9keT5cbiAqIDwvdGFibGU+XG4gKlxuICogVGhlc2Ugc2NhbGVzIGFyZSB0aGUgb25lcyB1c2VkIGJ5IHRoZSBtZXRob2RzIHdoaWNoIHJldHVybiBleGFjdFxuICogYXJpdGhtZXRpYyByZXN1bHRzOyBleGNlcHQgdGhhdCBhbiBleGFjdCBkaXZpZGUgbWF5IGhhdmUgdG8gdXNlIGFcbiAqIGxhcmdlciBzY2FsZSBzaW5jZSB0aGUgZXhhY3QgcmVzdWx0IG1heSBoYXZlIG1vcmUgZGlnaXRzLiAgRm9yXG4gKiBleGFtcGxlLCBgMS8zMmAgaXMgYDAuMDMxMjVgLlxuICpcbiAqIEJlZm9yZSByb3VuZGluZywgdGhlIHNjYWxlIG9mIHRoZSBsb2dpY2FsIGV4YWN0IGludGVybWVkaWF0ZVxuICogcmVzdWx0IGlzIHRoZSBwcmVmZXJyZWQgc2NhbGUgZm9yIHRoYXQgb3BlcmF0aW9uLiBJZiB0aGUgZXhhY3RcbiAqIG51bWVyaWNhbCByZXN1bHQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIGBwcmVjaXNpb25gXG4gKiBkaWdpdHMsIHJvdW5kaW5nIHNlbGVjdHMgdGhlIHNldCBvZiBkaWdpdHMgdG8gcmV0dXJuIGFuZCB0aGUgc2NhbGVcbiAqIG9mIHRoZSByZXN1bHQgaXMgcmVkdWNlZCBmcm9tIHRoZSBzY2FsZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdFxuICogdG8gdGhlIGxlYXN0IHNjYWxlIHdoaWNoIGNhbiByZXByZXNlbnQgdGhlIGBwcmVjaXNpb25gXG4gKiBkaWdpdHMgYWN0dWFsbHkgcmV0dXJuZWQuICBJZiB0aGUgZXhhY3QgcmVzdWx0IGNhbiBiZSByZXByZXNlbnRlZFxuICogd2l0aCBhdCBtb3N0IGBwcmVjaXNpb25gIGRpZ2l0cywgdGhlIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgcmVzdWx0IHdpdGggdGhlIHNjYWxlIGNsb3Nlc3QgdG8gdGhlIHByZWZlcnJlZCBzY2FsZSBpc1xuICogcmV0dXJuZWQuICBJbiBwYXJ0aWN1bGFyLCBhbiBleGFjdGx5IHJlcHJlc2VudGFibGUgcXVvdGllbnQgbWF5IGJlXG4gKiByZXByZXNlbnRlZCBpbiBmZXdlciB0aGFuIGBwcmVjaXNpb25gIGRpZ2l0cyBieSByZW1vdmluZ1xuICogdHJhaWxpbmcgemVyb3MgYW5kIGRlY3JlYXNpbmcgdGhlIHNjYWxlLiAgRm9yIGV4YW1wbGUsIHJvdW5kaW5nIHRvXG4gKiB0aHJlZSBkaWdpdHMgdXNpbmcgdGhlIHtAbGluayBSb3VuZGluZ01vZGUuRkxPT1IgfCBmbG9vcn1cbiAqIHJvdW5kaW5nIG1vZGUsIDxicj5cbiAqXG4gKiBgMTkvMTAwID0gMC4xOSAgIC8vIG51bWJlcj0xOSwgIHNjYWxlPTJgIDxicj5cbiAqXG4gKiBidXQ8YnI+XG4gKlxuICogYDIxLzExMCA9IDAuMTkwICAvLyBudW1iZXI9MTkwLCBzY2FsZT0zYCA8YnI+XG4gKlxuICogTm90ZSB0aGF0IGZvciBhZGQsIHN1YnRyYWN0LCBhbmQgbXVsdGlwbHksIHRoZSByZWR1Y3Rpb24gaW5cbiAqIHNjYWxlIHdpbGwgZXF1YWwgdGhlIG51bWJlciBvZiBkaWdpdCBwb3NpdGlvbnMgb2YgdGhlIGV4YWN0IHJlc3VsdFxuICogd2hpY2ggYXJlIGRpc2NhcmRlZC4gSWYgdGhlIHJvdW5kaW5nIGNhdXNlcyBhIGNhcnJ5IHByb3BhZ2F0aW9uIHRvXG4gKiBjcmVhdGUgYSBuZXcgaGlnaC1vcmRlciBkaWdpdCBwb3NpdGlvbiwgYW4gYWRkaXRpb25hbCBkaWdpdCBvZiB0aGVcbiAqIHJlc3VsdCBpcyBkaXNjYXJkZWQgdGhhbiB3aGVuIG5vIG5ldyBkaWdpdCBwb3NpdGlvbiBpcyBjcmVhdGVkLlxuICpcbiAqIE90aGVyIG1ldGhvZHMgbWF5IGhhdmUgc2xpZ2h0bHkgZGlmZmVyZW50IHJvdW5kaW5nIHNlbWFudGljcy5cbiAqIEZvciBleGFtcGxlLCB0aGUgcmVzdWx0IG9mIHRoZSBgcG93YCBtZXRob2QgdXNpbmcgdGhlXG4gKiB7QGxpbmsgcG93IHwgc3BlY2lmaWVkIGFsZ29yaXRobX0gY2FuXG4gKiBvY2Nhc2lvbmFsbHkgZGlmZmVyIGZyb20gdGhlIHJvdW5kZWQgbWF0aGVtYXRpY2FsIHJlc3VsdCBieSBtb3JlXG4gKiB0aGFuIG9uZSB1bml0IGluIHRoZSBsYXN0IHBsYWNlLCBvbmUgPGk+e0BsaW5rIHVscH08L2k+LlxuICpcbiAqIFR3byB0eXBlcyBvZiBvcGVyYXRpb25zIGFyZSBwcm92aWRlZCBmb3IgbWFuaXB1bGF0aW5nIHRoZSBzY2FsZVxuICogb2YgYSBgQmlnRGVjaW1hbGA6IHNjYWxpbmcvcm91bmRpbmcgb3BlcmF0aW9ucyBhbmQgZGVjaW1hbFxuICogcG9pbnQgbW90aW9uIG9wZXJhdGlvbnMuICBTY2FsaW5nL3JvdW5kaW5nIG9wZXJhdGlvbnMgKHtAbGlua1xuICogc2V0U2NhbGV9IGFuZCB7QGxpbmsgcm91bmR9KSByZXR1cm4gYVxuICogYEJpZ0RlY2ltYWxgIHdob3NlIHZhbHVlIGlzIGFwcHJveGltYXRlbHkgKG9yIGV4YWN0bHkpIGVxdWFsXG4gKiB0byB0aGF0IG9mIHRoZSBvcGVyYW5kLCBidXQgd2hvc2Ugc2NhbGUgb3IgcHJlY2lzaW9uIGlzIHRoZVxuICogc3BlY2lmaWVkIHZhbHVlOyB0aGF0IGlzLCB0aGV5IGluY3JlYXNlIG9yIGRlY3JlYXNlIHRoZSBwcmVjaXNpb25cbiAqIG9mIHRoZSBzdG9yZWQgbnVtYmVyIHdpdGggbWluaW1hbCBlZmZlY3Qgb24gaXRzIHZhbHVlLiAgRGVjaW1hbFxuICogcG9pbnQgbW90aW9uIG9wZXJhdGlvbnMgKHtAbGluayBtb3ZlUG9pbnRMZWZ0fSBhbmRcbiAqIHtAbGluayBtb3ZlUG9pbnRSaWdodH0pIHJldHVybiBhXG4gKiBgQmlnRGVjaW1hbGAgY3JlYXRlZCBmcm9tIHRoZSBvcGVyYW5kIGJ5IG1vdmluZyB0aGUgZGVjaW1hbFxuICogcG9pbnQgYSBzcGVjaWZpZWQgZGlzdGFuY2UgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uXG4gKlxuICogQXMgYSBudW1iZXIsIHRoZSBzZXQgb2YgdmFsdWVzIGZvciB0aGUgc2NhbGUgaXMgbGFyZ2UsXG4gKiBidXQgYm91bmRlZC4gSWYgdGhlIHNjYWxlIG9mIGEgcmVzdWx0IHdvdWxkIGV4Y2VlZCB0aGUgcmFuZ2Ugb2YgYVxuICogc2FmZSBudW1iZXIsIGVpdGhlciBieSBvdmVyZmxvdyBvciB1bmRlcmZsb3csIHRoZSBvcGVyYXRpb24gbWF5XG4gKiB0aHJvdyBhIFJhbmdlckVycm9yLlxuICpcbiAqIEZvciB0aGUgc2FrZSBvZiBicmV2aXR5IGFuZCBjbGFyaXR5LCBwc2V1ZG8tY29kZSBpcyB1c2VkXG4gKiB0aHJvdWdob3V0IHRoZSBkZXNjcmlwdGlvbnMgb2YgYEJpZ0RlY2ltYWxgIG1ldGhvZHMuICBUaGVcbiAqIHBzZXVkby1jb2RlIGV4cHJlc3Npb24gYChpICsgailgIGlzIHNob3J0aGFuZCBmb3IgXCJhXG4gKiBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXMgdGhhdCBvZiB0aGUgYEJpZ0RlY2ltYWxgXG4gKiBgaWAgYWRkZWQgdG8gdGhhdCBvZiB0aGUgYEJpZ0RlY2ltYWxgXG4gKiBgamAuXCIgVGhlIHBzZXVkby1jb2RlIGV4cHJlc3Npb24gYChpID09IGopYCBpc1xuICogc2hvcnRoYW5kIGZvciBcImB0cnVlYCBpZiBhbmQgb25seSBpZiB0aGVcbiAqIGBCaWdEZWNpbWFsYCBgaWAgcmVwcmVzZW50cyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGVcbiAqIGBCaWdEZWNpbWFsYCBgamAuXCIgT3RoZXIgcHNldWRvLWNvZGUgZXhwcmVzc2lvbnNcbiAqIGFyZSBpbnRlcnByZXRlZCBzaW1pbGFybHkuICBTcXVhcmUgYnJhY2tldHMgYXJlIHVzZWQgdG8gcmVwcmVzZW50XG4gKiB0aGUgcGFydGljdWxhciBgQmlnSW50YCBhbmQgc2NhbGUgcGFpciBkZWZpbmluZyBhXG4gKiBgQmlnRGVjaW1hbGAgdmFsdWU7IGZvciBleGFtcGxlIFsxOSwgMl0gaXMgdGhlXG4gKiBgQmlnRGVjaW1hbGAgbnVtZXJpY2FsbHkgZXF1YWwgdG8gMC4xOSBoYXZpbmcgYSBzY2FsZSBvZiAyLlxuICpcbiAqIDxoMj5SZWxhdGlvbiB0byBJRUVFIDc1NCBEZWNpbWFsIEFyaXRobWV0aWM8L2gyPlxuICpcbiAqIFN0YXJ0aW5nIHdpdGggaXRzIDIwMDggcmV2aXNpb24sIHRoZSA8Y2l0ZT5JRUVFIDc1NCBTdGFuZGFyZCBmb3JcbiAqIEZsb2F0aW5nLXBvaW50IEFyaXRobWV0aWM8L2NpdGU+IGhhcyBjb3ZlcmVkIGRlY2ltYWwgZm9ybWF0cyBhbmRcbiAqIG9wZXJhdGlvbnMuIFdoaWxlIHRoZXJlIGFyZSBicm9hZCBzaW1pbGFyaXRpZXMgaW4gdGhlIGRlY2ltYWxcbiAqIGFyaXRobWV0aWMgZGVmaW5lZCBieSBJRUVFIDc1NCBhbmQgYnkgdGhpcyBjbGFzcywgdGhlcmUgYXJlIG5vdGFibGVcbiAqIGRpZmZlcmVuY2VzIGFzIHdlbGwuIFRoZSBmdW5kYW1lbnRhbCBzaW1pbGFyaXR5IHNoYXJlZCBieVxuICogYEJpZ0RlY2ltYWxgIGFuZCBJRUVFIDc1NCBkZWNpbWFsIGFyaXRobWV0aWMgaXMgdGhlIGNvbmNlcHR1YWxcbiAqIG9wZXJhdGlvbiBvZiBjb21wdXRpbmcgdGhlIG1hdGhlbWF0aWNhbCBpbmZpbml0ZWx5IHByZWNpc2UgcmVhbFxuICogbnVtYmVyIHZhbHVlIG9mIGFuIG9wZXJhdGlvbiBhbmQgdGhlbiBtYXBwaW5nIHRoYXQgcmVhbCBudW1iZXIgdG8gYVxuICogcmVwcmVzZW50YWJsZSBkZWNpbWFsIGZsb2F0aW5nLXBvaW50IHZhbHVlIHVuZGVyIGEgPGVtPnJvdW5kaW5nXG4gKiBwb2xpY3k8L2VtPi4gVGhlIHJvdW5kaW5nIHBvbGljeSBpcyBjYWxsZWQgYSB7QGxpbmtcbiAqIFJvdW5kaW5nTW9kZSB8IHJvdW5kaW5nIG1vZGV9IGZvciBgQmlnRGVjaW1hbGAgYW5kIGNhbGxlZCBhXG4gKiByb3VuZGluZy1kaXJlY3Rpb24gYXR0cmlidXRlIGluIElFRUUgNzU0LTIwMTkuIFdoZW4gdGhlIGV4YWN0IHZhbHVlXG4gKiBpcyBub3QgcmVwcmVzZW50YWJsZSwgdGhlIHJvdW5kaW5nIHBvbGljeSBkZXRlcm1pbmVzIHdoaWNoIG9mIHRoZVxuICogdHdvIHJlcHJlc2VudGFibGUgZGVjaW1hbCB2YWx1ZXMgYnJhY2tldGluZyB0aGUgZXhhY3QgdmFsdWUgaXNcbiAqIHNlbGVjdGVkIGFzIHRoZSBjb21wdXRlZCByZXN1bHQuIFRoZSBub3Rpb24gb2YgYSA8ZW0+cHJlZmVycmVkXG4gKiBzY2FsZS9wcmVmZXJyZWQgZXhwb25lbnQ8L2VtPiBpcyBhbHNvIHNoYXJlZCBieSBib3RoIHN5c3RlbXMuXG4gKlxuICogRm9yIGRpZmZlcmVuY2VzLCBJRUVFIDc1NCBpbmNsdWRlcyBzZXZlcmFsIGtpbmRzIG9mIHZhbHVlcyBub3RcbiAqIG1vZGVsZWQgYnkgYEJpZ0RlY2ltYWxgIGluY2x1ZGluZyBuZWdhdGl2ZSB6ZXJvLCBzaWduZWRcbiAqIGluZmluaXRpZXMsIGFuZCBOYU4gKG5vdC1hLW51bWJlcikuIElFRUUgNzU0IGRlZmluZXMgZm9ybWF0cywgd2hpY2hcbiAqIGFyZSBwYXJhbWV0ZXJpemVkIGJ5IGJhc2UgKGJpbmFyeSBvciBkZWNpbWFsKSwgbnVtYmVyIG9mIGRpZ2l0cyBvZlxuICogcHJlY2lzaW9uLCBhbmQgZXhwb25lbnQgcmFuZ2UuIEEgZm9ybWF0IGRldGVybWluZXMgdGhlIHNldCBvZlxuICogcmVwcmVzZW50YWJsZSB2YWx1ZXMuIE1vc3Qgb3BlcmF0aW9ucyBhY2NlcHQgYXMgaW5wdXQgb25lIG9yIG1vcmVcbiAqIHZhbHVlcyBvZiBhIGdpdmVuIGZvcm1hdCBhbmQgcHJvZHVjZSBhIHJlc3VsdCBpbiB0aGUgc2FtZSBmb3JtYXQuXG4gKiBBIGBCaWdEZWNpbWFsYCdzIHtAbGluayBzY2FsZX0gaXMgZXF1aXZhbGVudCB0b1xuICogbmVnYXRpbmcgYW4gSUVFRSA3NTQgdmFsdWUncyBleHBvbmVudC4gYEJpZ0RlY2ltYWxgIHZhbHVlcyBkb1xuICogbm90IGhhdmUgYSBmb3JtYXQgaW4gdGhlIHNhbWUgc2Vuc2U7IGFsbCB2YWx1ZXMgaGF2ZSB0aGUgc2FtZVxuICogcG9zc2libGUgcmFuZ2Ugb2Ygc2NhbGUvZXhwb25lbnQgYW5kIHRoZSB7QGxpbmtcbiAqIHVuc2NhbGVkVmFsdWUgfCB1bnNjYWxlZCB2YWx1ZX0gaGFzIGFyYml0cmFyeSBwcmVjaXNpb24uIEluc3RlYWQsXG4gKiBmb3IgdGhlIGBCaWdEZWNpbWFsYCBvcGVyYXRpb25zIHRha2luZyBhIGBNYXRoQ29udGV4dGBcbiAqIHBhcmFtZXRlciwgaWYgdGhlIGBNYXRoQ29udGV4dGAgaGFzIGEgbm9uemVybyBwcmVjaXNpb24sIHRoZVxuICogc2V0IG9mIHBvc3NpYmxlIHJlcHJlc2VudGFibGUgdmFsdWVzIGZvciB0aGUgcmVzdWx0IGlzIGRldGVybWluZWRcbiAqIGJ5IHRoZSBwcmVjaXNpb24gb2YgdGhlIGBNYXRoQ29udGV4dGAgYXJndW1lbnQuIEZvciBleGFtcGxlXG4gKiBpbiBgQmlnRGVjaW1hbGAsIGlmIGEgbm9uemVybyB0aHJlZS1kaWdpdCBudW1iZXIgYW5kIGFcbiAqIG5vbnplcm8gZm91ci1kaWdpdCBudW1iZXIgYXJlIG11bHRpcGxpZWQgdG9nZXRoZXIgaW4gdGhlIGNvbnRleHQgb2ZcbiAqIGEgYE1hdGhDb250ZXh0YCBvYmplY3QgaGF2aW5nIGEgcHJlY2lzaW9uIG9mIHRocmVlLCB0aGVcbiAqIHJlc3VsdCB3aWxsIGhhdmUgdGhyZWUgZGlnaXRzIChhc3N1bWluZyBubyBvdmVyZmxvdyBvciB1bmRlcmZsb3csXG4gKiBldGMuKS5cbiAqXG4gKiBUaGUgcm91bmRpbmcgcG9saWNpZXMgaW1wbGVtZW50ZWQgYnkgYEJpZ0RlY2ltYWxgXG4gKiBvcGVyYXRpb25zIGluZGljYXRlZCBieSB7QGxpbmsgUm91bmRpbmdNb2RlIHwgcm91bmRpbmcgbW9kZXN9XG4gKiBhcmUgYSBwcm9wZXIgc3VwZXJzZXQgb2YgdGhlIElFRUUgNzU0IHJvdW5kaW5nLWRpcmVjdGlvblxuICogYXR0cmlidXRlcy5cbiAqXG4gKiBgQmlnRGVjaW1hbGAgYXJpdGhtZXRpYyB3aWxsIG1vc3QgcmVzZW1ibGUgSUVFRSA3NTRcbiAqIGRlY2ltYWwgYXJpdGhtZXRpYyBpZiBhIGBNYXRoQ29udGV4dGAgY29ycmVzcG9uZGluZyB0byBhblxuICogSUVFRSA3NTQgZGVjaW1hbCBmb3JtYXQsIHN1Y2ggYXMge0BsaW5rIE1hdGhDb250ZXh0LkRFQ0lNQUw2NCB8XG4gKiBkZWNpbWFsNjR9IG9yIHtAbGluayBNYXRoQ29udGV4dC5ERUNJTUFMMTI4IHwgZGVjaW1hbDEyOH0gaXNcbiAqIHVzZWQgdG8gcm91bmQgYWxsIHN0YXJ0aW5nIHZhbHVlcyBhbmQgaW50ZXJtZWRpYXRlIG9wZXJhdGlvbnMuIFRoZVxuICogbnVtZXJpY2FsIHZhbHVlcyBjb21wdXRlZCBjYW4gZGlmZmVyIGlmIHRoZSBleHBvbmVudCByYW5nZSBvZiB0aGVcbiAqIElFRUUgNzU0IGZvcm1hdCBiZWluZyBhcHByb3hpbWF0ZWQgaXMgZXhjZWVkZWQgc2luY2UgYVxuICogYE1hdGhDb250ZXh0YCBkb2VzIG5vdCBjb25zdHJhaW4gdGhlIHNjYWxlIG9mIGBCaWdEZWNpbWFsYFxuICogcmVzdWx0cy4gT3BlcmF0aW9ucyB0aGF0IHdvdWxkIGdlbmVyYXRlIGEgTmFOIG9yIGV4YWN0IGluZmluaXR5LFxuICogc3VjaCBhcyBkaXZpZGluZyBieSB6ZXJvLCB0aHJvdyBhIFJhbmdlRXJyb3IgaW5cbiAqIGBCaWdEZWNpbWFsYCBhcml0aG1ldGljLlxuICpcbiAqL1xuY2xhc3MgQmlnRGVjaW1hbCB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBhZGp1c3RTY2FsZShzY2wsIGV4cCkge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFNjYWxlID0gc2NsIC0gZXhwO1xuICAgICAgICBpZiAoYWRqdXN0ZWRTY2FsZSA+IEJpZ0RlY2ltYWwuTUFYX0lOVF9WQUxVRSB8fCBhZGp1c3RlZFNjYWxlIDwgQmlnRGVjaW1hbC5NSU5fSU5UX1ZBTFVFKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1NjYWxlIG91dCBvZiByYW5nZS4nKTtcbiAgICAgICAgc2NsID0gYWRqdXN0ZWRTY2FsZTtcbiAgICAgICAgcmV0dXJuIHNjbDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKGJpZ0ludFZhbHVlLCBpbnRDb21wYWN0LCBzY2FsZSwgcHJlY2lzaW9uKSB7XG4gICAgICAgIHRoaXMuaW50VmFsID0gYmlnSW50VmFsdWU7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgICAgdGhpcy5pbnRDb21wYWN0ID0gaW50Q29tcGFjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhIGNoYXJhY3RlciBhcnJheSByZXByZXNlbnRhdGlvbiBvZiBhXG4gICAgICogYEJpZ0RlY2ltYWxgIGludG8gYSBgQmlnRGVjaW1hbGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgaW5wdXQgc3RyaW5nXG4gICAgICogQHBhcmFtIG9mZnNldCBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSBsZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gY29uc2lkZXIuXG4gICAgICogQHBhcmFtIHNjYWxlIHNjYWxlIHZhbHVlXG4gICAgICogQHBhcmFtIG1jIHRoZSBjb250ZXh0IHRvIHVzZS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYGlucHV0YCBpcyBub3QgYSB2YWxpZFxuICAgICAqIHJlcHJlc2VudGF0aW9uIG9mIGEgYEJpZ0RlY2ltYWxgIG9yIHRoZSBkZWZpbmVkIHN1YmFycmF5XG4gICAgICogaXMgbm90IHdob2xseSB3aXRoaW4gYGlucHV0YC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhpbnB1dCwgb2Zmc2V0LCBsZW4sIHNjYWxlLCBtYyA9IE1hdGhDb250ZXh0LlVOTElNSVRFRCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBwcmltYXJ5IHN0cmluZyB0byBCaWdEZWNpbWFsIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIFVzZSBsb2NhbHMgZm9yIGFsbCBmaWVsZHMgdmFsdWVzIHVudGlsIGNvbXBsZXRpb25cbiAgICAgICAgbGV0IHByZWMgPSAwOyAvLyByZWNvcmQgcHJlY2lzaW9uIHZhbHVlXG4gICAgICAgIGxldCBzY2wgPSBzY2FsZSB8fCAwOyAvLyByZWNvcmQgc2NhbGUgdmFsdWVcbiAgICAgICAgbGV0IHJzID0gMDsgLy8gdGhlIGNvbXBhY3QgdmFsdWUgaW4gbG9uZ1xuICAgICAgICBsZXQgcmIgPSBudWxsOyAvLyB0aGUgaW5mbGF0ZWQgdmFsdWUgaW4gQmlnSW50XG4gICAgICAgIC8vIHVzZSBhcnJheSBib3VuZHMgY2hlY2tpbmcgdG8gaGFuZGxlIHRvby1sb25nLCBsZW4gPT0gMCxcbiAgICAgICAgLy8gYmFkIG9mZnNldCwgZXRjLlxuICAgICAgICAvLyBoYW5kbGUgdGhlIHNpZ25cbiAgICAgICAgbGV0IGlzbmVnID0gZmFsc2U7IC8vIGFzc3VtZSBwb3NpdGl2ZVxuICAgICAgICBpZiAoaW5wdXRbb2Zmc2V0XSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBpc25lZyA9IHRydWU7IC8vIGxlYWRpbmcgbWludXMgbWVhbnMgbmVnYXRpdmVcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgbGVuLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXRbb2Zmc2V0XSA9PT0gJysnKSB7IC8vIGxlYWRpbmcgKyBhbGxvd2VkXG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNob3VsZCBub3cgYmUgYXQgbnVtZXJpYyBwYXJ0IG9mIHRoZSBzaWduaWZpY2FuZFxuICAgICAgICBsZXQgZG90ID0gZmFsc2U7IC8vIHRydWUgd2hlbiB0aGVyZSBpcyBhICcuJ1xuICAgICAgICBsZXQgZXhwID0gMDsgLy8gZXhwb25lbnRcbiAgICAgICAgbGV0IGM7IC8vIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGNvbnN0IGlzQ29tcGFjdCA9IGxlbiA8PSB0aGlzLk1BWF9DT01QQUNUX0RJR0lUUztcbiAgICAgICAgLy8gaW50ZWdlciBzaWduaWZpY2FuZCBhcnJheSAmIGlkeCBpcyB0aGUgaW5kZXggdG8gaXQuIFRoZSBhcnJheVxuICAgICAgICAvLyBpcyBPTkxZIHVzZWQgd2hlbiB3ZSBjYW4ndCB1c2UgYSBjb21wYWN0IHJlcHJlc2VudGF0aW9uLlxuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgaWYgKGlzQ29tcGFjdCkge1xuICAgICAgICAgICAgLy8gRmlyc3QgY29tcGFjdCBjYXNlLCB3ZSBuZWVkIG5vdCB0byBwcmVzZXJ2ZSB0aGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAvLyBhbmQgd2UgY2FuIGp1c3QgY29tcHV0ZSB0aGUgdmFsdWUgaW4gcGxhY2UuXG4gICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgb2Zmc2V0KyssIGxlbi0tKSB7XG4gICAgICAgICAgICAgICAgYyA9IGlucHV0W29mZnNldF07XG4gICAgICAgICAgICAgICAgaWYgKChjID09PSAnMCcpKSB7IC8vIGhhdmUgemVyb1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlYyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWMgPSAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChycyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnMgKj0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3ByZWM7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBkaWdpdCBpcyBhIHJlZHVuZGFudCBsZWFkaW5nIHplcm9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvdClcbiAgICAgICAgICAgICAgICAgICAgICAgICsrc2NsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYyA+PSAnMScgJiYgYyA8PSAnOScpKSB7IC8vIGhhdmUgZGlnaXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnaXQgPSArYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWMgIT09IDEgfHwgcnMgIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICArK3ByZWM7IC8vIHByZWMgdW5jaGFuZ2VkIGlmIHByZWNlZGVkIGJ5IDBzXG4gICAgICAgICAgICAgICAgICAgIHJzID0gcnMgKiAxMCArIGRpZ2l0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG90KVxuICAgICAgICAgICAgICAgICAgICAgICAgKytzY2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcuJykgeyAvLyBoYXZlIGRvdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZG90KSAvLyB0d28gZG90c1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NoYXJhY3RlciBhcnJheSBjb250YWlucyBtb3JlIHRoYW4gb25lIGRlY2ltYWwgcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgICAgIGRvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjID09PSAnZScpIHx8IChjID09PSAnRScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cCA9IEJpZ0RlY2ltYWwucGFyc2VFeHAoaW5wdXQsIG9mZnNldCwgbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV4dCB0ZXN0IGlzIHJlcXVpcmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwID4gQmlnRGVjaW1hbC5NQVhfSU5UX1ZBTFVFIHx8IGV4cCA8IEJpZ0RlY2ltYWwuTUlOX0lOVF9WQUxVRSkgLy8gb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdFeHBvbmVudCBvdmVyZmxvdy4nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFtzYXZlcyBhIHRlc3RdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2hhcmFjdGVyICcgKyBjXG4gICAgICAgICAgICAgICAgICAgICAgICArICcgaXMgbmVpdGhlciBhIGRlY2ltYWwgZGlnaXQgbnVtYmVyLCBkZWNpbWFsIHBvaW50LCBub3InXG4gICAgICAgICAgICAgICAgICAgICAgICArICcgXCJlXCIgbm90YXRpb24gZXhwb25lbnRpYWwgbWFyay4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlYyA9PT0gMCkgLy8gbm8gZGlnaXRzIGZvdW5kXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vIGRpZ2l0cyBmb3VuZC4nKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCBzY2FsZSBpZiBleHAgaXMgbm90IHplcm8uXG4gICAgICAgICAgICBpZiAoZXhwICE9PSAwKSB7IC8vIGhhZCBzaWduaWZpY2FudCBleHBvbmVudFxuICAgICAgICAgICAgICAgIHNjbCA9IEJpZ0RlY2ltYWwuYWRqdXN0U2NhbGUoc2NsLCBleHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnMgPSBpc25lZyA/IC1ycyA6IHJzO1xuICAgICAgICAgICAgY29uc3QgbWNwID0gbWMucHJlY2lzaW9uO1xuICAgICAgICAgICAgbGV0IGRyb3AgPSBwcmVjIC0gbWNwOyAvLyBwcmVjIGhhcyByYW5nZSBbMSwgTUFYX0lOVF0sIG1jcCBoYXMgcmFuZ2UgWzAsIE1BWF9JTlRdO1xuICAgICAgICAgICAgLy8gdGhlcmVmb3JlLCB0aGlzIHN1YnRyYWN0IGNhbm5vdCBvdmVyZmxvd1xuICAgICAgICAgICAgaWYgKG1jcCA+IDAgJiYgZHJvcCA+IDApIHsgLy8gZG8gcm91bmRpbmdcbiAgICAgICAgICAgICAgICB3aGlsZSAoZHJvcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NsID0gQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhzY2wgLSBkcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kKHJzLCBCaWdEZWNpbWFsLlRFTl9QT1dFUlNfVEFCTEVbZHJvcF0sIG1jLnJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSBCaWdEZWNpbWFsLmludGVnZXJEaWdpdExlbmd0aChycyk7XG4gICAgICAgICAgICAgICAgICAgIGRyb3AgPSBwcmVjIC0gbWNwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZWZmID0gW107XG4gICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgb2Zmc2V0KyssIGxlbi0tKSB7XG4gICAgICAgICAgICAgICAgYyA9IGlucHV0W29mZnNldF07XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBkaWdpdFxuICAgICAgICAgICAgICAgIGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBjb21wYWN0IGNhc2UsIHdlIG5lZWQgbm90IHRvIHByZXNlcnZlIHRoZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlIGNhbiBqdXN0IGNvbXB1dGUgdGhlIHZhbHVlIGluIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmW2lkeF0gPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaWR4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZbaWR4KytdID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2UgYyBtdXN0IGJlIGEgcmVkdW5kYW50IGxlYWRpbmcgemVyb1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWMgIT09IDEgfHwgaWR4ICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWMrKzsgLy8gcHJlYyB1bmNoYW5nZWQgaWYgcHJlY2VkZWQgYnkgMHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmW2lkeCsrXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjbCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBkb3RcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb3QpIHsgLy8gdHdvIGRvdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTdHJpbmcgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBkZWNpbWFsIHBvaW50LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBleHBvbmVudCBleHBlY3RlZFxuICAgICAgICAgICAgICAgIGlmICgoYyAhPT0gJ2UnKSAmJiAoYyAhPT0gJ0UnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU3RyaW5nIGlzIG1pc3NpbmcgXCJlXCIgbm90YXRpb24gZXhwb25lbnRpYWwgbWFyay4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwID0gQmlnRGVjaW1hbC5wYXJzZUV4cChpbnB1dCwgb2Zmc2V0LCBsZW4pO1xuICAgICAgICAgICAgICAgIC8vIE5leHQgdGVzdCBpcyByZXF1aXJlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBpZiAoZXhwID4gQmlnRGVjaW1hbC5NQVhfSU5UX1ZBTFVFIHx8IGV4cCA8IEJpZ0RlY2ltYWwuTUlOX0lOVF9WQUxVRSkgLy8gb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0V4cG9uZW50IG92ZXJmbG93LicpO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBbc2F2ZXMgYSB0ZXN0XVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGVyZSB3aGVuIG5vIGNoYXJhY3RlcnMgbGVmdFxuICAgICAgICAgICAgaWYgKHByZWMgPT09IDApIHsgLy8gbm8gZGlnaXRzIGZvdW5kXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vIGRpZ2l0cyBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkanVzdCBzY2FsZSBpZiBleHAgaXMgbm90IHplcm8uXG4gICAgICAgICAgICBpZiAoZXhwICE9PSAwKSB7IC8vIGhhZCBzaWduaWZpY2FudCBleHBvbmVudFxuICAgICAgICAgICAgICAgIHNjbCA9IEJpZ0RlY2ltYWwuYWRqdXN0U2NhbGUoc2NsLCBleHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5nVmFsdWUgPSBjb2VmZi5qb2luKCcnKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGZyb20gcHJlY2lzaW9uIChkaWdpdHMgY291bnQpXG4gICAgICAgICAgICBpZiAoaXNuZWcpXG4gICAgICAgICAgICAgICAgcmIgPSBCaWdJbnQoJy0nICsgc3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJiID0gQmlnSW50KHN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIHJzID0gQmlnRGVjaW1hbC5jb21wYWN0VmFsRm9yKHJiKTtcbiAgICAgICAgICAgIGNvbnN0IG1jcCA9IG1jLnByZWNpc2lvbjtcbiAgICAgICAgICAgIGlmIChtY3AgPiAwICYmIChwcmVjID4gbWNwKSkge1xuICAgICAgICAgICAgICAgIGlmIChycyA9PT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkcm9wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NsID0gQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhzY2wgLSBkcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJiID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZEJ5VGVuUG93KHJiLCBkcm9wLCBtYy5yb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnMgPSBCaWdEZWNpbWFsLmNvbXBhY3RWYWxGb3IocmIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlYyA9IEJpZ0RlY2ltYWwuaW50ZWdlckRpZ2l0TGVuZ3RoKHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWMgPSBCaWdEZWNpbWFsLmJpZ0RpZ2l0TGVuZ3RoKHJiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3AgPSBwcmVjIC0gbWNwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChycyAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkcm9wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NsID0gQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhzY2wgLSBkcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJzID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZChycywgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFW2Ryb3BdLCBtYy5yb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlYyA9IEJpZ0RlY2ltYWwuaW50ZWdlckRpZ2l0TGVuZ3RoKHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3AgPSBwcmVjIC0gbWNwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJiID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKHJiLCBycywgc2NsLCBwcmVjKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBmcm9tQmlnSW50KHZhbHVlLCBzY2FsZSwgbWMpIHtcbiAgICAgICAgaWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUJpZ0ludDModmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUJpZ0ludDIodmFsdWUsIDAsIG1jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUJpZ0ludDQodmFsdWUsIHNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21CaWdJbnQyKHZhbHVlLCBzY2FsZSwgbWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgYSBgQmlnSW50YCB1bnNjYWxlZCB2YWx1ZSBhbmQgYSBudW1iZXJcbiAgICAgKiBzY2FsZSBpbnRvIGEgYEJpZ0RlY2ltYWxgLCB3aXRoIHJvdW5kaW5nXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBjb250ZXh0IHNldHRpbmdzLiAgVGhlIHZhbHVlIG9mIHRoZVxuICAgICAqIGBCaWdEZWNpbWFsYCBpcyA8Y29kZT4odW5zY2FsZWRWYWwgJnRpbWVzO1xuICAgICAqIDEwPHN1cD4tc2NhbGU8L3N1cD4pPC9jb2RlPiwgcm91bmRlZCBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICogYHByZWNpc2lvbmAgYW5kIHJvdW5kaW5nIG1vZGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50VmFsIHVuc2NhbGVkIHZhbHVlIG9mIHRoZSBgQmlnRGVjaW1hbGAuXG4gICAgICogQHBhcmFtIHNjYWxlICAgICAgIHNjYWxlIG9mIHRoZSBgQmlnRGVjaW1hbGAuXG4gICAgICogQHBhcmFtIG1jICAgICAgICAgIHRoZSBjb250ZXh0IHRvIHVzZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJpZ0ludDIoaW50VmFsLCBzY2FsZSwgbWMpIHtcbiAgICAgICAgbGV0IHVuc2NhbGVkVmFsID0gaW50VmFsO1xuICAgICAgICBsZXQgY29tcGFjdFZhbCA9IEJpZ0RlY2ltYWwuY29tcGFjdFZhbEZvcih1bnNjYWxlZFZhbCk7XG4gICAgICAgIGNvbnN0IG1jcCA9IG1jLnByZWNpc2lvbjtcbiAgICAgICAgbGV0IHByZWMgPSAwO1xuICAgICAgICBpZiAobWNwID4gMCkgeyAvLyBkbyByb3VuZGluZ1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IG1jLnJvdW5kaW5nTW9kZTtcbiAgICAgICAgICAgIGlmIChjb21wYWN0VmFsID09PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgcHJlYyA9IEJpZ0RlY2ltYWwuYmlnRGlnaXRMZW5ndGgodW5zY2FsZWRWYWwpO1xuICAgICAgICAgICAgICAgIGxldCBkcm9wID0gcHJlYyAtIG1jcDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZHJvcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHNjYWxlIC0gZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZEJ5VGVuUG93KHVuc2NhbGVkVmFsLCBkcm9wLCBtb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdFZhbCA9IEJpZ0RlY2ltYWwuY29tcGFjdFZhbEZvcih1bnNjYWxlZFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYWN0VmFsICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmVjID0gQmlnRGVjaW1hbC5iaWdEaWdpdExlbmd0aCh1bnNjYWxlZFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGRyb3AgPSBwcmVjIC0gbWNwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wYWN0VmFsICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgcHJlYyA9IEJpZ0RlY2ltYWwuaW50ZWdlckRpZ2l0TGVuZ3RoKGNvbXBhY3RWYWwpO1xuICAgICAgICAgICAgICAgIGxldCBkcm9wID0gcHJlYyAtIG1jcDsgLy8gZHJvcCBjYW4ndCBiZSBtb3JlIHRoYW4gMTVcbiAgICAgICAgICAgICAgICB3aGlsZSAoZHJvcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHNjYWxlIC0gZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RWYWwgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kKGNvbXBhY3RWYWwsIEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRVtkcm9wXSwgbW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSBCaWdEZWNpbWFsLmludGVnZXJEaWdpdExlbmd0aChjb21wYWN0VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuc2NhbGVkVmFsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwodW5zY2FsZWRWYWwsIGNvbXBhY3RWYWwsIHNjYWxlLCBwcmVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhIGBCaWdJbnRlZ2VyYCBpbnRvIGEgYEJpZ0RlY2ltYWxgLlxuICAgICAqIFRoZSBzY2FsZSBvZiB0aGUgYEJpZ0RlY2ltYWxgIGlzIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50VmFsIGBCaWdJbnRgIHZhbHVlIHRvIGJlIGNvbnZlcnRlZCB0b1xuICAgICAqICAgICAgICAgICAgYEJpZ0RlY2ltYWxgLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmlnSW50MyhpbnRWYWwpIHtcbiAgICAgICAgY29uc3QgaW50Q29tcGFjdCA9IEJpZ0RlY2ltYWwuY29tcGFjdFZhbEZvcihpbnRWYWwpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwoaW50VmFsLCBpbnRDb21wYWN0LCAwLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhIGBCaWdJbnRgIHVuc2NhbGVkIHZhbHVlIGFuZCBhIG51bWJlclxuICAgICAqIHNjYWxlIGludG8gYSBgQmlnRGVjaW1hbGAuICBUaGUgdmFsdWUgb2ZcbiAgICAgKiB0aGUgYEJpZ0RlY2ltYWxgIGlzXG4gICAgICogPGNvZGU+KHVuc2NhbGVkVmFsICZ0aW1lczsgMTA8c3VwPi1zY2FsZTwvc3VwPik8L2NvZGU+LlxuICAgICAqXG4gICAgICogQHBhcmFtIGludFZhbCB1bnNjYWxlZCB2YWx1ZSBvZiB0aGUgYEJpZ0RlY2ltYWxgLlxuICAgICAqIEBwYXJhbSBzY2FsZSAgICAgICBzY2FsZSBvZiB0aGUgYEJpZ0RlY2ltYWxgLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmlnSW50NChpbnRWYWwsIHNjYWxlKSB7XG4gICAgICAgIC8vIE5lZ2F0aXZlIHNjYWxlcyBhcmUgbm93IGFsbG93ZWRcbiAgICAgICAgY29uc3QgaW50Q29tcGFjdCA9IEJpZ0RlY2ltYWwuY29tcGFjdFZhbEZvcihpbnRWYWwpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwoaW50VmFsLCBpbnRDb21wYWN0LCBzY2FsZSwgMCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgZnJvbUJpZ0ludDUoaW50VmFsLCBzY2FsZSwgcHJlYykge1xuICAgICAgICBjb25zdCBpbnRDb21wYWN0ID0gQmlnRGVjaW1hbC5jb21wYWN0VmFsRm9yKGludFZhbCk7XG4gICAgICAgIGlmIChpbnRDb21wYWN0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC56ZXJvVmFsdWVPZihzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NhbGUgPT09IDAgJiYgaW50Q29tcGFjdCA+PSAwICYmIGludENvbXBhY3QgPCBCaWdEZWNpbWFsLlpFUk9fVEhST1VHSF9URU4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5aRVJPX1RIUk9VR0hfVEVOW2ludENvbXBhY3RdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbChpbnRWYWwsIGludENvbXBhY3QsIHNjYWxlLCBwcmVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhIGBkb3VibGVgIGludG8gYSBgQmlnRGVjaW1hbGAsIHVzaW5nXG4gICAgICogdGhlIGBkb3VibGVgJ3MgY2Fub25pY2FsIHN0cmluZyByZXByZXNlbnRhdGlvbiBwcm92aWRlZFxuICAgICAqIGJ5IHRoZSBTdHJpbmcgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG91YmxlIGBkb3VibGVgIHRvIGNvbnZlcnQgdG8gYSBgQmlnRGVjaW1hbGAuXG4gICAgICogQHBhcmFtIG1jIG1hdGggY29udGV4dCB0byB1c2VcbiAgICAgKiBAcmV0dXJuIGEgYEJpZ0RlY2ltYWxgIHdob3NlIHZhbHVlIGlzIGVxdWFsIHRvIG9yIGFwcHJveGltYXRlbHlcbiAgICAgKiBlcXVhbCB0byB0aGUgdmFsdWUgb2YgYGRvdWJsZWAuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIGBkb3VibGVgIGlzIG5vdCBhIHZhbGlkIGBCaWdEZWNpbWFsYFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRG91YmxlKGRvdWJsZSwgbWMpIHtcbiAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSBTdHJpbmcoZG91YmxlKTtcbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbVN0cmluZyhzdHJWYWx1ZSwgMCwgc3RyVmFsdWUubGVuZ3RoLCAwLCBtYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBCaWdEZWNpbWFsIGZyb20gYSBudW1iZXIgd2l0aCBnaXZlbiBzY2FsZSBhbmQgcHJlY2lzaW9uXG4gICAgICogQHBhcmFtIHZhbHVlIGludGVnZXIgdmFsdWVcbiAgICAgKiBAcGFyYW0gc2NhbGUgc2NhbGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gbWMgbWF0aCBjb250ZXh0IHZhbHVlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGZyb21JbnRlZ2VyKHZhbHVlLCBzY2FsZSwgbWMpIHtcbiAgICAgICAgaWYgKG1jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21OdW1iZXI1KHZhbHVlLCBtYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMyh2YWx1ZSwgc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUludGVnZXI0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGZyb21JbnRlZ2VyMih2YWx1ZSwgc2NhbGUsIHByZWMpIHtcbiAgICAgICAgaWYgKHNjYWxlID09PSAwICYmIHZhbHVlID49IDAgJiYgdmFsdWUgPCBCaWdEZWNpbWFsLlpFUk9fVEhST1VHSF9URU4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5aRVJPX1RIUk9VR0hfVEVOW3ZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuemVyb1ZhbHVlT2Yoc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbCh2YWx1ZSA9PT0gQmlnRGVjaW1hbC5JTkZMQVRFRCA/IEJpZ0RlY2ltYWwuSU5GTEFURURfQklHSU5UIDogbnVsbCwgdmFsdWUsIHNjYWxlLCBwcmVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhIGBudW1iZXJgIHVuc2NhbGVkIHZhbHVlIGFuZCBhIGBudW1iZXJgXG4gICAgICogc2NhbGUgaW50byBhIGBCaWdEZWNpbWFsYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB1bnNjYWxlZCB2YWx1ZSBvZiB0aGUgYEJpZ0RlY2ltYWxgLlxuICAgICAqIEBwYXJhbSBzY2FsZSAgICAgICBzY2FsZSBvZiB0aGUgYEJpZ0RlY2ltYWxgLlxuICAgICAqIEByZXR1cm4gYSBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXNcbiAgICAgKiA8Y29kZT4odW5zY2FsZWRWYWwgJnRpbWVzOyAxMDxzdXA+LXNjYWxlPC9zdXA+KTwvY29kZT4uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGZyb21JbnRlZ2VyMyh2YWx1ZSwgc2NhbGUpIHtcbiAgICAgICAgaWYgKHNjYWxlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tSW50ZWdlcjQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC56ZXJvVmFsdWVPZihzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKHZhbHVlID09PSBCaWdEZWNpbWFsLklORkxBVEVEID8gQmlnRGVjaW1hbC5JTkZMQVRFRF9CSUdJTlQgOiBudWxsLCB2YWx1ZSwgc2NhbGUsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGFuIGludGVnZXIgdmFsdWUgaW50byBhIGBCaWdEZWNpbWFsYFxuICAgICAqIHdpdGggYSBzY2FsZSBvZiB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIHRoZSBgQmlnRGVjaW1hbGAuXG4gICAgICogQHJldHVybiBhIGBCaWdEZWNpbWFsYCB3aG9zZSB2YWx1ZSBpcyBgdmFsdWVgLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSW50ZWdlcjQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuWkVST19USFJPVUdIX1RFTlt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk9fVEhST1VHSF9URU5bdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwobnVsbCwgdmFsdWUsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKHRoaXMuSU5GTEFURURfQklHSU5ULCB2YWx1ZSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhbiBpbnRlZ2VyIGludG8gYSBgQmlnRGVjaW1hbGAsIHdpdGhcbiAgICAgKiByb3VuZGluZyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRleHQgc2V0dGluZ3MuICBUaGUgc2NhbGUgb2YgdGhlXG4gICAgICogYEJpZ0RlY2ltYWxgLCBiZWZvcmUgYW55IHJvdW5kaW5nLCBpcyB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIG51bWJlciB2YWx1ZSB0byBiZSBjb252ZXJ0ZWQgdG8gYEJpZ0RlY2ltYWxgLlxuICAgICAqIEBwYXJhbSBtYyAgdGhlIGNvbnRleHQgdG8gdXNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTnVtYmVyNSh2YWx1ZSwgbWMpIHtcbiAgICAgICAgY29uc3QgbWNwID0gbWMucHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBtb2RlID0gbWMucm91bmRpbmdNb2RlO1xuICAgICAgICBsZXQgcHJlYyA9IDA7XG4gICAgICAgIGxldCBzY2wgPSAwO1xuICAgICAgICBsZXQgcmIgPSAodmFsdWUgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpID8gQmlnRGVjaW1hbC5JTkZMQVRFRF9CSUdJTlQgOiBudWxsO1xuICAgICAgICBpZiAobWNwID4gMCkgeyAvLyBkbyByb3VuZGluZ1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgcHJlYyA9IDE2OyAvLyBudW1iZXIgbWF4IGRpZ2l0cyArIDFcbiAgICAgICAgICAgICAgICBsZXQgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRyb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjbCA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8oc2NsIC0gZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHJiID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZEJ5VGVuUG93KHJiLCBkcm9wLCBtb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCaWdEZWNpbWFsLmNvbXBhY3RWYWxGb3IocmIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSBCaWdEZWNpbWFsLmJpZ0RpZ2l0TGVuZ3RoKHJiKTtcbiAgICAgICAgICAgICAgICAgICAgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgcHJlYyA9IEJpZ0RlY2ltYWwuaW50ZWdlckRpZ2l0TGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRyb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjbCA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8oc2NsIC0gZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZCh2YWx1ZSwgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFW2Ryb3BdLCBtYy5yb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgICAgICAgICBwcmVjID0gQmlnRGVjaW1hbC5pbnRlZ2VyRGlnaXRMZW5ndGgodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBkcm9wID0gcHJlYyAtIG1jcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbChyYiwgdmFsdWUsIHNjbCwgcHJlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIG9mIGRpZ2l0cyBpbiBhIGludGVnZXJcbiAgICAgKiBAcGFyYW0gdmFsdWUgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBpbnRlZ2VyRGlnaXRMZW5ndGgodmFsdWUpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBuID0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBuIC89IDEwO1xuICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH0gd2hpbGUgKG4gPj0gMSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBhcnNlIGV4cG9uZW50XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlRXhwKGlucHV0LCBvZmZzZXQsIGxlbikge1xuICAgICAgICBsZXQgZXhwID0gMDtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGxldCBjID0gaW5wdXRbb2Zmc2V0XTtcbiAgICAgICAgbGVuLS07XG4gICAgICAgIGNvbnN0IG5lZ2V4cCA9IChjID09PSAnLScpO1xuICAgICAgICAvLyBvcHRpb25hbCBzaWduXG4gICAgICAgIGlmIChuZWdleHAgfHwgYyA9PT0gJysnKSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGMgPSBpbnB1dFtvZmZzZXRdO1xuICAgICAgICAgICAgbGVuLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA8PSAwKSB7IC8vIG5vIGV4cG9uZW50IGRpZ2l0c1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vIGV4cG9uZW50IGRpZ2l0cycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgbGVhZGluZyB6ZXJvcyBpbiB0aGUgZXhwb25lbnRcbiAgICAgICAgd2hpbGUgKGxlbiA+IDEwICYmIGMgPT09ICcwJykge1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBjID0gaW5wdXRbb2Zmc2V0XTtcbiAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAxMCkgeyAvLyB0b28gbWFueSBub256ZXJvIGV4cG9uZW50IGRpZ2l0c1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RvbyBtYW55IG5vbnplcm8gZXhwb25lbnQgZGlnaXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYyBub3cgaG9sZHMgZmlyc3QgZGlnaXQgb2YgZXhwb25lbnRcbiAgICAgICAgZm9yICg7OyBsZW4tLSkge1xuICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICBpZiAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICB2ID0gK2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBkaWdpdFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOb3QgYSBkaWdpdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cCA9IGV4cCAqIDEwICsgdjtcbiAgICAgICAgICAgIGlmIChsZW4gPT09IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIHRoYXQgd2FzIGZpbmFsIGNoYXJhY3RlclxuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBjID0gaW5wdXRbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVnZXhwKSAvLyBhcHBseSBzaWduXG4gICAgICAgICAgICBleHAgPSAtZXhwO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGZyb21WYWx1ZSh2YWx1ZSwgc2NhbGUsIG1jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBOdW1iZXIuTUFYX1ZBTFVFIHx8IHZhbHVlIDwgLU51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTnVtYmVyIG11c3QgYmUgaW4gdGhlIHJhbmdlIFstTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRV0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gdW5kZWZpbmVkICYmIG1jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignV2hlbiBjb25zdHJ1Y3RpbmcgZnJvbSBhIG51bWJlciwgeW91IGNhbm5vdCBnaXZlIGJvdGggc2NhbGUgYW5kIE1hdGhDb250ZXh0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdZb3Ugc2hvdWxkIG5vdCBnaXZlIHNjYWxlIHdoZW4gbnVtYmVyIGlzIGEgZG91YmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21Eb3VibGUodmFsdWUsIG1jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHZhbHVlID4gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5zYWZlIHJhbmdlLCBidWlsZCBmcm9tIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tU3RyaW5nKHZhbHVlLCAwLCB2YWx1ZS5sZW5ndGgsIHNjYWxlLCBtYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tSW50ZWdlcih2YWx1ZSwgc2NhbGUsIG1jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUJpZ0ludCh2YWx1ZSwgc2NhbGUsIG1jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdEZWNpbWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwodmFsdWUuaW50VmFsLCB2YWx1ZS5pbnRDb21wYWN0LCB2YWx1ZS5zY2FsZSgpLCB2YWx1ZS5fcHJlY2lzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1lvdSBzaG91bGQgZ2l2ZSBzY2FsZSBvbmx5IHdpdGggQmlnSW50cyBvciBpbnRlZ2VycycpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbVN0cmluZyh2YWx1ZSwgMCwgdmFsdWUubGVuZ3RoLCAwLCBtYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdmFsdWUgdG8gQmlnRGVjaW1hbCBpZiBpdCBpcyBub3QgYWxyZWFkeS5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydFRvQmlnRGVjaW1hbCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdEZWNpbWFsKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGFkZDEoZnN0LCBzY2FsZTEsIHNuZCwgc2NhbGUyKSB7XG4gICAgICAgIGxldCByc2NhbGUgPSBzY2FsZTE7XG4gICAgICAgIGNvbnN0IHNkaWZmID0gcnNjYWxlIC0gc2NhbGUyO1xuICAgICAgICBpZiAoc2RpZmYgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChzZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYWlzZSA9IHRoaXMuY2hlY2tTY2FsZTMoZnN0LCAtc2RpZmYpO1xuICAgICAgICAgICAgICAgIHJzY2FsZSA9IHNjYWxlMjtcbiAgICAgICAgICAgICAgICBmc3QgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4zKGZzdCwgcmFpc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFpc2UgPSB0aGlzLmNoZWNrU2NhbGUzKHNuZCwgc2RpZmYpO1xuICAgICAgICAgICAgICAgIHNuZCA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjMoc25kLCByYWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VtID0gZnN0LnZhbHVlT2YoKSArIHNuZC52YWx1ZU9mKCk7XG4gICAgICAgIGNvbnN0IHNhbWVTaWdudW0gPSAoZnN0ID09PSBCaWdEZWNpbWFsLnplcm9CaWdJbnQgJiYgc25kID09PSBCaWdEZWNpbWFsLnplcm9CaWdJbnQpIHx8XG4gICAgICAgICAgICAoZnN0ID4gQmlnRGVjaW1hbC56ZXJvQmlnSW50ICYmIHNuZCA+IEJpZ0RlY2ltYWwuemVyb0JpZ0ludCkgfHxcbiAgICAgICAgICAgIChmc3QgPCBCaWdEZWNpbWFsLnplcm9CaWdJbnQgJiYgc25kIDwgQmlnRGVjaW1hbC56ZXJvQmlnSW50KTtcbiAgICAgICAgcmV0dXJuIHNhbWVTaWdudW0gPyBuZXcgQmlnRGVjaW1hbChzdW0sIEJpZ0RlY2ltYWwuSU5GTEFURUQsIHJzY2FsZSwgMCkgOiBCaWdEZWNpbWFsLmZyb21CaWdJbnQ1KHN1bSwgcnNjYWxlLCAwKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBhZGQyKHhzLCBzY2FsZTEsIHNuZCwgc2NhbGUyKSB7XG4gICAgICAgIGxldCByc2NhbGUgPSBzY2FsZTE7XG4gICAgICAgIGNvbnN0IHNkaWZmID0gcnNjYWxlIC0gc2NhbGUyO1xuICAgICAgICBjb25zdCBzYW1lU2lnbnMgPSAoc25kID09PSBCaWdEZWNpbWFsLnplcm9CaWdJbnQgJiYgeHMgPT09IDApIHx8XG4gICAgICAgICAgICAoc25kID4gQmlnRGVjaW1hbC56ZXJvQmlnSW50ICYmIHhzID4gMCkgfHxcbiAgICAgICAgICAgIChzbmQgPCBCaWdEZWNpbWFsLnplcm9CaWdJbnQgJiYgeHMgPCAwKTtcbiAgICAgICAgbGV0IHN1bTtcbiAgICAgICAgaWYgKHNkaWZmIDwgMCkge1xuICAgICAgICAgICAgY29uc3QgcmFpc2UgPSB0aGlzLmNoZWNrU2NhbGUyKHhzLCAtc2RpZmYpO1xuICAgICAgICAgICAgcnNjYWxlID0gc2NhbGUyO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkWCA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeHMsIHJhaXNlKTtcbiAgICAgICAgICAgIGlmIChzY2FsZWRYID09PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc25kLnZhbHVlT2YoKSArIEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjIoeHMsIHJhaXNlKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdW0gPSBzbmQudmFsdWVPZigpICsgQmlnSW50KHNjYWxlZFgpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gaWYgKHNkaWZmID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmFpc2UgPSB0aGlzLmNoZWNrU2NhbGUzKHNuZCwgc2RpZmYpO1xuICAgICAgICAgICAgc25kID0gQmlnRGVjaW1hbC5iaWdNdWx0aXBseVBvd2VyVGVuMyhzbmQsIHJhaXNlKTtcbiAgICAgICAgICAgIHN1bSA9IHNuZC52YWx1ZU9mKCkgKyBCaWdJbnQoeHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2FtZVNpZ25zKSA/XG4gICAgICAgICAgICBuZXcgQmlnRGVjaW1hbChzdW0sIEJpZ0RlY2ltYWwuSU5GTEFURUQsIHJzY2FsZSwgMCkgOiBCaWdEZWNpbWFsLmZyb21CaWdJbnQ1KHN1bSwgcnNjYWxlLCAwKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBhZGQzKHhzLCBzY2FsZTEsIHlzLCBzY2FsZTIpIHtcbiAgICAgICAgY29uc3Qgc2RpZmYgPSBzY2FsZTEgLSBzY2FsZTI7XG4gICAgICAgIGlmIChzZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuYWRkNCh4cywgeXMsIHNjYWxlMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2RpZmYgPCAwKSB7XG4gICAgICAgICAgICBjb25zdCByYWlzZSA9IHRoaXMuY2hlY2tTY2FsZTIoeHMsIC1zZGlmZik7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRYID0gQmlnRGVjaW1hbC5pbnRlZ2VyTXVsdGlwbHlQb3dlclRlbih4cywgcmFpc2UpO1xuICAgICAgICAgICAgaWYgKHNjYWxlZFggIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5hZGQ0KHNjYWxlZFgsIHlzLCBzY2FsZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmlnc3VtID0gQmlnRGVjaW1hbC5iaWdNdWx0aXBseVBvd2VyVGVuMih4cywgcmFpc2UpLnZhbHVlT2YoKSArIEJpZ0ludCh5cykudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKHhzIF4geXMpID49IDApID9cbiAgICAgICAgICAgICAgICAgICAgbmV3IEJpZ0RlY2ltYWwoYmlnc3VtLCBCaWdEZWNpbWFsLklORkxBVEVELCBzY2FsZTIsIDApIDogQmlnRGVjaW1hbC5mcm9tQmlnSW50NShiaWdzdW0sIHNjYWxlMiwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYWlzZSA9IHRoaXMuY2hlY2tTY2FsZTIoeXMsIHNkaWZmKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZFkgPSBCaWdEZWNpbWFsLmludGVnZXJNdWx0aXBseVBvd2VyVGVuKHlzLCByYWlzZSk7XG4gICAgICAgICAgICBpZiAoc2NhbGVkWSAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmFkZDQoeHMsIHNjYWxlZFksIHNjYWxlMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWdzdW0gPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4yKHlzLCByYWlzZSkudmFsdWVPZigpICsgQmlnSW50KHhzKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeHMgXiB5cykgPj0gMCkgP1xuICAgICAgICAgICAgICAgICAgICBuZXcgQmlnRGVjaW1hbChiaWdzdW0sIEJpZ0RlY2ltYWwuSU5GTEFURUQsIHNjYWxlMSwgMCkgOiBCaWdEZWNpbWFsLmZyb21CaWdJbnQ1KGJpZ3N1bSwgc2NhbGUxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGFkZDQoeHMsIHlzLCBzY2FsZSkge1xuICAgICAgICBjb25zdCBzdW0gPSBCaWdEZWNpbWFsLmFkZDUoeHMsIHlzKTtcbiAgICAgICAgaWYgKHN1bSAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRClcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMyhzdW0sIHNjYWxlKTtcbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUJpZ0ludDUoQmlnSW50KHhzKSArIEJpZ0ludCh5cyksIHNjYWxlLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJucyBJTkZMQVRFRCBpZiBvdmVyZmxvd3NcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkNSh4cywgeXMpIHtcbiAgICAgICAgY29uc3Qgc3VtID0geHMgKyB5cztcbiAgICAgICAgaWYgKHN1bSA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLklORkxBVEVEO1xuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHZhbCAqIDEwIF4gbjsgcmV0dXJuIHRoaXMgcHJvZHVjdCBpZiBpdCBpc1xuICAgICAqIHJlcHJlc2VudGFibGUgYXMgYSBsb25nLCBJTkZMQVRFRCBvdGhlcndpc2UuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGludGVnZXJNdWx0aXBseVBvd2VyVGVuKHZhbCwgbikge1xuICAgICAgICBpZiAodmFsID09PSAwIHx8IG4gPD0gMClcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIGNvbnN0IHRhYiA9IEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRTtcbiAgICAgICAgY29uc3QgYm91bmRzID0gQmlnRGVjaW1hbC5USFJFU0hPTERTX1RBQkxFO1xuICAgICAgICBpZiAobiA8IHRhYi5sZW5ndGggJiYgbiA8IGJvdW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbnBvd2VyID0gdGFiW25dO1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVucG93ZXI7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModmFsKSA8PSBib3VuZHNbbl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCAqIHRlbnBvd2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdEZWNpbWFsLklORkxBVEVEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWdudW0gZnVuY3Rpb24gb2YgdGhpcyBgQmlnRGVjaW1hbGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIC0xLCAwLCBvciAxIGFzIHRoZSB2YWx1ZSBvZiB0aGlzIGBCaWdEZWNpbWFsYFxuICAgICAqICAgICAgICAgaXMgbmVnYXRpdmUsIHplcm8sIG9yIHBvc2l0aXZlLlxuICAgICAqL1xuICAgIHNpZ251bSgpIHtcbiAgICAgICAgY29uc3QgaW50Q29tcGFjdFNpZ251bSA9IHRoaXMuaW50Q29tcGFjdCA+IDAgPyAxIDogKHRoaXMuaW50Q29tcGFjdCA8IDAgPyAtMSA6IDApO1xuICAgICAgICBjb25zdCBpbnRWYWxTaWdudW0gPSBCaWdEZWNpbWFsLmJpZ0ludFNpZ251bSh0aGlzLmludFZhbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmludENvbXBhY3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQgPyBpbnRDb21wYWN0U2lnbnVtIDogaW50VmFsU2lnbnVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHVuc2NhbGVkIHZhbHVlIG9mIHRoaXMgYEJpZ0RlY2ltYWxgIGFzIGBCaWdJbnRgXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgaW5mbGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludFZhbCA9PT0gbnVsbCA/IEJpZ0ludCh0aGlzLmludENvbXBhY3QpIDogdGhpcy5pbnRWYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXBhY3QgdmFsdWUgZm9yIGdpdmVuIGBCaWdJbnRgLCBvclxuICAgICAqIElORkxBVEVEIGlmIHRvbyBiaWcuIFJlbGllcyBvbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZlxuICAgICAqIGBCaWdJbnRgLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYWN0VmFsRm9yKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS52YWx1ZU9mKCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCB2YWx1ZS52YWx1ZU9mKCkgPCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuSU5GTEFURUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjaGVja1NjYWxlKHZhbCkge1xuICAgICAgICBpZiAodmFsID4gQmlnRGVjaW1hbC5NQVhfSU5UX1ZBTFVFIHx8IHZhbCA8IEJpZ0RlY2ltYWwuTUlOX0lOVF9WQUxVRSkge1xuICAgICAgICAgICAgdmFsID0gdmFsID4gQmlnRGVjaW1hbC5NQVhfSU5UX1ZBTFVFID8gQmlnRGVjaW1hbC5NQVhfSU5UX1ZBTFVFIDogQmlnRGVjaW1hbC5NSU5fSU5UX1ZBTFVFO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50Q29tcGFjdCAhPT0gMCAmJiAodGhpcy5pbnRWYWwgPT09IG51bGwgfHwgQmlnRGVjaW1hbC5iaWdJbnRTaWdudW0odGhpcy5pbnRWYWwpICE9PSAwKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih2YWwgPiAwID8gJ1NjYWxlIHRvbyBoaWdoJyA6ICdTY2FsZSB0b28gbGVzcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgY2hlY2tTY2FsZTIoaW50Q29tcGFjdCwgdmFsKSB7XG4gICAgICAgIGlmICh2YWwgPiBCaWdEZWNpbWFsLk1BWF9JTlRfVkFMVUUgfHwgdmFsIDwgQmlnRGVjaW1hbC5NSU5fSU5UX1ZBTFVFKSB7XG4gICAgICAgICAgICB2YWwgPSAodmFsID4gQmlnRGVjaW1hbC5NQVhfSU5UX1ZBTFVFKSA/IEJpZ0RlY2ltYWwuTUFYX0lOVF9WQUxVRSA6IEJpZ0RlY2ltYWwuTUlOX0lOVF9WQUxVRTtcbiAgICAgICAgICAgIGlmIChpbnRDb21wYWN0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IodmFsID4gMCA/ICdTY2FsZSB0b28gaGlnaCcgOiAnU2NhbGUgdG9vIGxlc3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGNoZWNrU2NhbGUzKGludFZhbCwgdmFsKSB7XG4gICAgICAgIGlmICh2YWwgPiBCaWdEZWNpbWFsLk1BWF9JTlRfVkFMVUUgfHwgdmFsIDwgQmlnRGVjaW1hbC5NSU5fSU5UX1ZBTFVFKSB7XG4gICAgICAgICAgICB2YWwgPSAodmFsID4gQmlnRGVjaW1hbC5NQVhfSU5UX1ZBTFVFKSA/IEJpZ0RlY2ltYWwuTUFYX0lOVF9WQUxVRSA6IEJpZ0RlY2ltYWwuTUlOX0lOVF9WQUxVRTtcbiAgICAgICAgICAgIGlmIChpbnRWYWwgIT09IEJpZ0RlY2ltYWwuemVyb0JpZ0ludCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHZhbCA+IDAgPyAnU2NhbGUgdG9vIGhpZ2gnIDogJ1NjYWxlIHRvbyBsZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIHNhbWUgYXMgY2hlY2tTY2FsZSB3aGVyZSB2YWx1ZSE9MFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBjaGVja1NjYWxlTm9uWmVybyh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA+IEJpZ0RlY2ltYWwuTUFYX0lOVF9WQUxVRSB8fCB2YWwgPCBCaWdEZWNpbWFsLk1JTl9JTlRfVkFMVUUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHZhbCA+IDAgPyAnU2NhbGUgdG9vIGhpZ2gnIDogJ1NjYWxlIHRvbyBsZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBgQmlnSW50YCB2YWx1ZSBieSB0ZW4gcG93ZXIuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGRpdmlkZUFuZFJvdW5kQnlUZW5Qb3coaW50VmFsLCB0ZW5Qb3csIHJvdW5kaW5nTW9kZSkge1xuICAgICAgICBpZiAodGVuUG93IDwgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFLmxlbmd0aClcbiAgICAgICAgICAgIGludFZhbCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQ1KGludFZhbCwgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFW3RlblBvd10sIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGludFZhbCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQ2KGludFZhbCwgQmlnSW50KDEwKSAqKiBCaWdJbnQodGVuUG93KSwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgcmV0dXJuIGludFZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBgbnVtYmVyIGJ5IGBudW1iZXIgYW5kIGRvIHJvdW5kaW5nIGJhc2VkIG9uIHRoZVxuICAgICAqIHBhc3NlZCBpbiByb3VuZGluZ01vZGUuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGRpdmlkZUFuZFJvdW5kKGxkaXZpZGVuZCwgbGRpdmlzb3IsIHJvdW5kaW5nTW9kZSkge1xuICAgICAgICBjb25zdCBxID0gTWF0aC50cnVuYyhsZGl2aWRlbmQgLyBsZGl2aXNvcik7XG4gICAgICAgIGlmIChyb3VuZGluZ01vZGUgPT09IFJvdW5kaW5nTW9kZS5ET1dOKVxuICAgICAgICAgICAgcmV0dXJuIHE7XG4gICAgICAgIGNvbnN0IHIgPSBsZGl2aWRlbmQgJSBsZGl2aXNvcjtcbiAgICAgICAgY29uc3QgcXNpZ24gPSAoKGxkaXZpZGVuZCA8IDApID09PSAobGRpdmlzb3IgPCAwKSkgPyAxIDogLTE7XG4gICAgICAgIGlmIChyICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBCaWdEZWNpbWFsLm5lZWRJbmNyZW1lbnQobGRpdmlzb3IsIHJvdW5kaW5nTW9kZSwgcXNpZ24sIHEsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIGluY3JlbWVudCA/IHEgKyBxc2lnbiA6IHE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoaXMgKiAxMCBeIG4uXG4gICAgICogTmVlZGVkIG1haW5seSB0byBhbGxvdyBzcGVjaWFsIGNhc2luZyB0byB0cmFwIHplcm8gdmFsdWVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBiaWdNdWx0aXBseVBvd2VyVGVuKG4pIHtcbiAgICAgICAgaWYgKG4gPD0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZmxhdGVkKCk7XG4gICAgICAgIGlmICh0aGlzLmludENvbXBhY3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KDEwKSAqKiBCaWdJbnQobikgKiBCaWdJbnQodGhpcy5pbnRDb21wYWN0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50VmFsLnZhbHVlT2YoKSAqIEJpZ0ludCgxMCkgKiogQmlnSW50KG4pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGJpZ011bHRpcGx5UG93ZXJUZW4yKHZhbHVlLCBuKSB7XG4gICAgICAgIGlmIChuIDw9IDApXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCgxMCkgKiogQmlnSW50KG4pICogQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBiaWdNdWx0aXBseVBvd2VyVGVuMyh2YWx1ZSwgbikge1xuICAgICAgICBpZiAobiA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAobiA8IEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZU9mKCkgKiBCaWdJbnQoQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFW25dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KDEwKSAqKiBCaWdJbnQobikgKiB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgemVyb1ZhbHVlT2Yoc2NhbGUpIHtcbiAgICAgICAgaWYgKHNjYWxlID49IDAgJiYgc2NhbGUgPCBCaWdEZWNpbWFsLlpFUk9fU0NBTEVEX0JZLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLlpFUk9fU0NBTEVEX0JZW3NjYWxlXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgc2NhbGUsIDEpO1xuICAgIH1cbiAgICBwcmVjaXNpb24oKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLmludENvbXBhY3Q7XG4gICAgICAgICAgICBpZiAocyAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBCaWdEZWNpbWFsLmludGVnZXJEaWdpdExlbmd0aChzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBCaWdEZWNpbWFsLmJpZ0RpZ2l0TGVuZ3RoKHRoaXMuaW50VmFsKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJpZ0RlY2ltYWxgIHJvdW5kZWQgYWNjb3JkaW5nIHRvIHRoZSBNYXRoQ29udGV4dFxuICAgICAqIHNldHRpbmdzO1xuICAgICAqIElmIHJvdW5kaW5nIGlzIG5lZWRlZCBhIG5ldyBgQmlnRGVjaW1hbGAgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIHRoZSB2YWx1ZSB0byBiZSByb3VuZGVkXG4gICAgICogQHBhcmFtIG1jICB0aGUgY29udGV4dCB0byB1c2UuXG4gICAgICogQHJldHVybiBhIGBCaWdEZWNpbWFsYCByb3VuZGVkIGFjY29yZGluZyB0byB0aGUgTWF0aENvbnRleHRcbiAgICAgKiBzZXR0aW5ncy4gIE1heSByZXR1cm4gYHZhbHVlYCwgaWYgbm8gcm91bmRpbmcgbmVlZGVkLlxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgcm91bmRpbmcgbW9kZSBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgUm91bmRpbmdNb2RlLlVOTkVDRVNTQVJZYCBhbmQgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCBpcyBpbmV4YWN0LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBkb1JvdW5kKHZhbCwgbWMpIHtcbiAgICAgICAgY29uc3QgbWNwID0gbWMucHJlY2lzaW9uO1xuICAgICAgICBsZXQgd2FzRGl2aWRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobWNwID4gMCkge1xuICAgICAgICAgICAgbGV0IGludFZhbCA9IHZhbC5pbnRWYWw7XG4gICAgICAgICAgICBsZXQgY29tcGFjdFZhbCA9IHZhbC5pbnRDb21wYWN0O1xuICAgICAgICAgICAgbGV0IHNjYWxlID0gdmFsLl9zY2FsZTtcbiAgICAgICAgICAgIGxldCBwcmVjID0gdmFsLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IG1jLnJvdW5kaW5nTW9kZTtcbiAgICAgICAgICAgIGxldCBkcm9wO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3RWYWwgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICBkcm9wID0gcHJlYyAtIG1jcDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZHJvcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHNjYWxlIC0gZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGludFZhbCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmRCeVRlblBvdyhpbnRWYWwsIGRyb3AsIG1vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3YXNEaXZpZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdFZhbCA9IEJpZ0RlY2ltYWwuY29tcGFjdFZhbEZvcihpbnRWYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFjdFZhbCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlYyA9IEJpZ0RlY2ltYWwuaW50ZWdlckRpZ2l0TGVuZ3RoKGNvbXBhY3RWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJlYyA9IEJpZ0RlY2ltYWwuYmlnRGlnaXRMZW5ndGgoaW50VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBhY3RWYWwgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICBkcm9wID0gcHJlYyAtIG1jcDsgLy8gZHJvcCBjYW4ndCBiZSBtb3JlIHRoYW4gMTVcbiAgICAgICAgICAgICAgICB3aGlsZSAoZHJvcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHNjYWxlIC0gZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RWYWwgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kKGNvbXBhY3RWYWwsIEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRVtkcm9wXSwgbWMucm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd2FzRGl2aWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSBCaWdEZWNpbWFsLmludGVnZXJEaWdpdExlbmd0aChjb21wYWN0VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICAgICAgICAgIGludFZhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhc0RpdmlkZWQgPyBuZXcgQmlnRGVjaW1hbChpbnRWYWwsIGNvbXBhY3RWYWwsIHNjYWxlLCBwcmVjKSA6IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlbmd0aCBvZiBhIGJpZ2ludFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBiaWdEaWdpdExlbmd0aChiKSB7XG4gICAgICAgIGlmIChiIDwgQmlnRGVjaW1hbC56ZXJvQmlnSW50KVxuICAgICAgICAgICAgYiA9IGIudmFsdWVPZigpICogQmlnRGVjaW1hbC5taW51c09uZUJpZ0ludDtcbiAgICAgICAgcmV0dXJuIGIudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQmlnRGVjaW1hbGAgY3JlYXRlZCBmcm9tIGBCaWdJbnRgIHZhbHVlIHdpdGhcbiAgICAgKiBnaXZlbiBzY2FsZSByb3VuZGVkIGFjY29yZGluZyB0byB0aGUgTWF0aENvbnRleHQgc2V0dGluZ3NcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9Sb3VuZDIoaW50VmFsLCBzY2FsZSwgbWMpIHtcbiAgICAgICAgY29uc3QgbWNwID0gbWMucHJlY2lzaW9uO1xuICAgICAgICBsZXQgcHJlYyA9IDA7XG4gICAgICAgIGlmIChtY3AgPiAwKSB7XG4gICAgICAgICAgICBsZXQgY29tcGFjdFZhbCA9IEJpZ0RlY2ltYWwuY29tcGFjdFZhbEZvcihpbnRWYWwpO1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IG1jLnJvdW5kaW5nTW9kZTtcbiAgICAgICAgICAgIGxldCBkcm9wO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3RWYWwgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICBwcmVjID0gQmlnRGVjaW1hbC5iaWdEaWdpdExlbmd0aChpbnRWYWwpO1xuICAgICAgICAgICAgICAgIGRyb3AgPSBwcmVjIC0gbWNwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChkcm9wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8oc2NhbGUgLSBkcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaW50VmFsID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZEJ5VGVuUG93KGludFZhbCwgZHJvcCwgbW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RWYWwgPSBCaWdEZWNpbWFsLmNvbXBhY3RWYWxGb3IoaW50VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhY3RWYWwgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSBCaWdEZWNpbWFsLmJpZ0RpZ2l0TGVuZ3RoKGludFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGRyb3AgPSBwcmVjIC0gbWNwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wYWN0VmFsICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgcHJlYyA9IEJpZ0RlY2ltYWwuaW50ZWdlckRpZ2l0TGVuZ3RoKGNvbXBhY3RWYWwpO1xuICAgICAgICAgICAgICAgIGRyb3AgPSBwcmVjIC0gbWNwOyAvLyBkcm9wIGNhbid0IGJlIG1vcmUgdGhhbiAxOFxuICAgICAgICAgICAgICAgIHdoaWxlIChkcm9wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8oc2NhbGUgLSBkcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdFZhbCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQoY29tcGFjdFZhbCwgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFW2Ryb3BdLCBtYy5yb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgICAgICAgICBwcmVjID0gQmlnRGVjaW1hbC5pbnRlZ2VyRGlnaXRMZW5ndGgoY29tcGFjdFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGRyb3AgPSBwcmVjIC0gbWNwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tSW50ZWdlcjIoY29tcGFjdFZhbCwgc2NhbGUsIHByZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbChpbnRWYWwsIEJpZ0RlY2ltYWwuSU5GTEFURUQsIHNjYWxlLCBwcmVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCaWdEZWNpbWFsYCBjcmVhdGVkIGZyb20gYG51bWJlcmAgdmFsdWUgd2l0aFxuICAgICAqIGdpdmVuIHNjYWxlIHJvdW5kZWQgYWNjb3JkaW5nIHRvIHRoZSBNYXRoQ29udGV4dCBzZXR0aW5nc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBkb1JvdW5kMyhjb21wYWN0VmFsLCBzY2FsZSwgbWMpIHtcbiAgICAgICAgY29uc3QgbWNwID0gbWMucHJlY2lzaW9uO1xuICAgICAgICBpZiAobWNwID4gMCAmJiBtY3AgPCAxNikge1xuICAgICAgICAgICAgbGV0IHByZWMgPSBCaWdEZWNpbWFsLmludGVnZXJEaWdpdExlbmd0aChjb21wYWN0VmFsKTtcbiAgICAgICAgICAgIGxldCBkcm9wID0gcHJlYyAtIG1jcDsgLy8gZHJvcCBjYW4ndCBiZSBtb3JlIHRoYW4gMTVcbiAgICAgICAgICAgIHdoaWxlIChkcm9wID4gMCkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhzY2FsZSAtIGRyb3ApO1xuICAgICAgICAgICAgICAgIGNvbXBhY3RWYWwgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kKGNvbXBhY3RWYWwsIEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRVtkcm9wXSwgbWMucm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgICAgICBwcmVjID0gQmlnRGVjaW1hbC5pbnRlZ2VyRGlnaXRMZW5ndGgoY29tcGFjdFZhbCk7XG4gICAgICAgICAgICAgICAgZHJvcCA9IHByZWMgLSBtY3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tSW50ZWdlcjIoY29tcGFjdFZhbCwgc2NhbGUsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMyhjb21wYWN0VmFsLCBzY2FsZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgc3RyaXBaZXJvc1RvTWF0Y2hTY2FsZShpbnRWYWwsIGludENvbXBhY3QsIHNjYWxlLCBwcmVmZXJyZWRTY2FsZSkge1xuICAgICAgICBpZiAoaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuY3JlYXRlQW5kU3RyaXBaZXJvc1RvTWF0Y2hTY2FsZShpbnRDb21wYWN0LCBzY2FsZSwgcHJlZmVycmVkU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuY3JlYXRlQW5kU3RyaXBaZXJvc1RvTWF0Y2hTY2FsZTIoaW50VmFsID09PSBudWxsID8gQmlnRGVjaW1hbC5JTkZMQVRFRF9CSUdJTlQgOiBpbnRWYWwudmFsdWVPZigpLCBzY2FsZSwgcHJlZmVycmVkU2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBpbnNpZ25pZmljYW50IHRyYWlsaW5nIHplcm9zIGZyb20gdGhpc1xuICAgICAqIHZhbHVlIHVudGlsIHRoZSBwcmVmZXJyZWQgc2NhbGUgaXMgcmVhY2hlZCBvciBub1xuICAgICAqIG1vcmUgemVyb3MgY2FuIGJlIHJlbW92ZWQuIElmIHRoZSBwcmVmZXJyZWQgc2NhbGUgaXMgbGVzcyB0aGFuXG4gICAgICogQmlnRGVjaW1hbC5NSU5fSU5UX1ZBTFVFLCBhbGwgdGhlIHRyYWlsaW5nIHplcm9zIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gbmV3IGBCaWdEZWNpbWFsYCB3aXRoIGEgc2NhbGUgcG9zc2libHkgcmVkdWNlZFxuICAgICAqIHRvIGJlIGNsb3NlZCB0byB0aGUgcHJlZmVycmVkIHNjYWxlLlxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBzY2FsZSBvdmVyZmxvd3MuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUFuZFN0cmlwWmVyb3NUb01hdGNoU2NhbGUoY29tcGFjdFZhbCwgc2NhbGUsIHByZWZlcnJlZFNjYWxlKSB7XG4gICAgICAgIHdoaWxlIChNYXRoLmFicyhjb21wYWN0VmFsKSA+PSAxMCAmJiBzY2FsZSA+IHByZWZlcnJlZFNjYWxlKSB7XG4gICAgICAgICAgICBpZiAoKGNvbXBhY3RWYWwgJiAxKSAhPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IHIgPSBjb21wYWN0VmFsICUgMTA7XG4gICAgICAgICAgICBpZiAociAhPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbXBhY3RWYWwgLz0gMTA7XG4gICAgICAgICAgICBzY2FsZSA9IHRoaXMuY2hlY2tTY2FsZTIoY29tcGFjdFZhbCwgc2NhbGUgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tSW50ZWdlcjMoY29tcGFjdFZhbCwgc2NhbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgaW5zaWduaWZpY2FudCB0cmFpbGluZyB6ZXJvcyBmcm9tIHRoaXNcbiAgICAgKiBiaWdpbnQgdmFsdWUgdW50aWwgdGhlIHByZWZlcnJlZCBzY2FsZSBpcyByZWFjaGVkIG9yIG5vXG4gICAgICogbW9yZSB6ZXJvcyBjYW4gYmUgcmVtb3ZlZC4gSWYgdGhlIHByZWZlcnJlZCBzY2FsZSBpcyBsZXNzIHRoYW5cbiAgICAgKiBCaWdEZWNpbWFsLk1JTl9JTlRfVkFMVUUsIGFsbCB0aGUgdHJhaWxpbmcgemVyb3Mgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBuZXcgYEJpZ0RlY2ltYWxgIHdpdGggYSBzY2FsZSBwb3NzaWJseSByZWR1Y2VkXG4gICAgICogdG8gYmUgY2xvc2VkIHRvIHRoZSBwcmVmZXJyZWQgc2NhbGUuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIHNjYWxlIG92ZXJmbG93cy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQW5kU3RyaXBaZXJvc1RvTWF0Y2hTY2FsZTIoaW50VmFsLCBzY2FsZSwgcHJlZmVycmVkU2NhbGUpIHtcbiAgICAgICAgbGV0IHFyO1xuICAgICAgICB3aGlsZSAoQmlnRGVjaW1hbC5iaWdJbnRDb21wYXJlTWFnbml0dWRlKGludFZhbCwgQmlnSW50KDEwKSkgPj0gMCAmJiBzY2FsZSA+IHByZWZlcnJlZFNjYWxlKSB7XG4gICAgICAgICAgICBpZiAoaW50VmFsLnZhbHVlT2YoKSAlIEJpZ0RlY2ltYWwudHdvQmlnSW50ID09PSBCaWdEZWNpbWFsLm9uZUJpZ0ludClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHFyID0gW2ludFZhbC52YWx1ZU9mKCkgLyBCaWdJbnQoMTApLCBpbnRWYWwudmFsdWVPZigpICUgQmlnSW50KDEwKV07XG4gICAgICAgICAgICBpZiAoQmlnRGVjaW1hbC5iaWdJbnRTaWdudW0ocXJbMV0pICE9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaW50VmFsID0gcXJbMF07XG4gICAgICAgICAgICBzY2FsZSA9IHRoaXMuY2hlY2tTY2FsZTMoaW50VmFsLCBzY2FsZSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21CaWdJbnQ1KGludFZhbCwgc2NhbGUsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCB0aGUgc2NhbGVzIG9mIHR3byBgQmlnRGVjaW1hbGBzIHRvIGFsaWduIHRoZWlyXG4gICAgICogbGVhc3Qgc2lnbmlmaWNhbnQgZGlnaXRzLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNjYWxlcyBvZiB2YWxbMF0gYW5kIHZhbFsxXSBkaWZmZXIsIHJlc2NhbGVcbiAgICAgKiAobm9uLWRlc3RydWN0aXZlbHkpIHRoZSBsb3dlci1zY2FsZWQgYEJpZ0RlY2ltYWxgIHNvXG4gICAgICogdGhleSBtYXRjaC4gIFRoYXQgaXMsIHRoZSBsb3dlci1zY2FsZWQgcmVmZXJlbmNlIHdpbGwgYmVcbiAgICAgKiByZXBsYWNlZCBieSBhIHJlZmVyZW5jZSB0byBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzY2FsZSBhc1xuICAgICAqIHRoZSBvdGhlciBgQmlnRGVjaW1hbGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIGFycmF5IG9mIHR3byBlbGVtZW50cyByZWZlcnJpbmcgdG8gdGhlIHR3b1xuICAgICAqICAgICAgICAgICAgYEJpZ0RlY2ltYWxgcyB0byBiZSBhbGlnbmVkLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBtYXRjaFNjYWxlKHZhbCkge1xuICAgICAgICBpZiAodmFsWzBdLl9zY2FsZSA8IHZhbFsxXS5fc2NhbGUpIHtcbiAgICAgICAgICAgIHZhbFswXSA9IHZhbFswXS5zZXRTY2FsZSh2YWxbMV0uX3NjYWxlLCBSb3VuZGluZ01vZGUuVU5ORUNFU1NBUlkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbFsxXS5fc2NhbGUgPCB2YWxbMF0uX3NjYWxlKSB7XG4gICAgICAgICAgICB2YWxbMV0gPSB2YWxbMV0uc2V0U2NhbGUodmFsWzBdLl9zY2FsZSwgUm91bmRpbmdNb2RlLlVOTkVDRVNTQVJZKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxlbmd0aCB0d28sIHRoZSBzdW0gb2Ygd2hvc2UgZW50cmllcyBpc1xuICAgICAqIGVxdWFsIHRvIHRoZSByb3VuZGVkIHN1bSBvZiB0aGUgYEJpZ0RlY2ltYWxgIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBkaWdpdCBwb3NpdGlvbnMgb2YgdGhlIGFyZ3VtZW50cyBoYXZlIGEgc3VmZmljaWVudFxuICAgICAqIGdhcCBiZXR3ZWVuIHRoZW0sIHRoZSB2YWx1ZSBzbWFsbGVyIGluIG1hZ25pdHVkZSBjYW4gYmVcbiAgICAgKiBjb25kZW5zZWQgaW50byBhIFwic3RpY2t5IGJpdFwiIGFuZCB0aGUgZW5kIHJlc3VsdCB3aWxsXG4gICAgICogcm91bmQgdGhlIHNhbWUgd2F5IDxlbT5pZjwvZW0+IHRoZSBwcmVjaXNpb24gb2YgdGhlIGZpbmFsXG4gICAgICogcmVzdWx0IGRvZXMgbm90IGluY2x1ZGUgdGhlIGhpZ2ggb3JkZXIgZGlnaXQgb2YgdGhlIHNtYWxsXG4gICAgICogbWFnbml0dWRlIG9wZXJhbmQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2hpbGUgc3RyaWN0bHkgc3BlYWtpbmcgdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24sXG4gICAgICogaXQgbWFrZXMgYSBtdWNoIHdpZGVyIHJhbmdlIG9mIGFkZGl0aW9ucyBwcmFjdGljYWwuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvcnJlc3BvbmRzIHRvIGEgcHJlLXNoaWZ0IG9wZXJhdGlvbiBpbiBhIGZpeGVkXG4gICAgICogcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IGFkZGVyOyB0aGlzIG1ldGhvZCBpcyBjb21wbGljYXRlZCBieVxuICAgICAqIHZhcmlhYmxlIHByZWNpc2lvbiBvZiB0aGUgcmVzdWx0IGFzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogTWF0aENvbnRleHQuICBBIG1vcmUgbnVhbmNlZCBvcGVyYXRpb24gY291bGQgaW1wbGVtZW50IGFcbiAgICAgKiBcInJpZ2h0IHNoaWZ0XCIgb24gdGhlIHNtYWxsZXIgbWFnbml0dWRlIG9wZXJhbmQgc29cbiAgICAgKiB0aGF0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBzbWFsbGVyIG9wZXJhbmQgY291bGQgYmVcbiAgICAgKiByZWR1Y2VkIGV2ZW4gdGhvdWdoIHRoZSBzaWduaWZpY2FuZHMgcGFydGlhbGx5IG92ZXJsYXBwZWQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHJlQWxpZ24oYXVnZW5kLCBwYWRkaW5nLCBtYykge1xuICAgICAgICBsZXQgYmlnO1xuICAgICAgICBsZXQgc21hbGw7XG4gICAgICAgIGlmIChwYWRkaW5nIDwgMCkge1xuICAgICAgICAgICAgYmlnID0gdGhpcztcbiAgICAgICAgICAgIHNtYWxsID0gYXVnZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmlnID0gYXVnZW5kO1xuICAgICAgICAgICAgc21hbGwgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVzdFJlc3VsdFVscFNjYWxlID0gYmlnLl9zY2FsZSAtIGJpZy5wcmVjaXNpb24oKSArIG1jLnByZWNpc2lvbjtcbiAgICAgICAgY29uc3Qgc21hbGxIaWdoRGlnaXRQb3MgPSBzbWFsbC5fc2NhbGUgLSBzbWFsbC5wcmVjaXNpb24oKSArIDE7XG4gICAgICAgIGlmIChzbWFsbEhpZ2hEaWdpdFBvcyA+IGJpZy5fc2NhbGUgKyAyICYmXG4gICAgICAgICAgICBzbWFsbEhpZ2hEaWdpdFBvcyA+IGVzdFJlc3VsdFVscFNjYWxlICsgMikge1xuICAgICAgICAgICAgc21hbGwgPSBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMyhzbWFsbC5zaWdudW0oKSwgdGhpcy5jaGVja1NjYWxlKE1hdGgubWF4KGJpZy5fc2NhbGUsIGVzdFJlc3VsdFVscFNjYWxlKSArIDMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2JpZywgc21hbGxdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJpZ0RlY2ltYWxgIHdob3NlIHZhbHVlIGlzIGAoLXRoaXMpYCxcbiAgICAgKiB3aXRoIHJvdW5kaW5nIGFjY29yZGluZyB0byB0aGUgY29udGV4dCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYyB0aGUgY29udGV4dCB0byB1c2UuXG4gICAgICogQHJldHVybiBgLXRoaXNgLCByb3VuZGVkIGFzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBuZWdhdGUobWMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuaW50Q29tcGFjdCA9PT0gQmlnRGVjaW1hbC5JTkZMQVRFRCA/XG4gICAgICAgICAgICBuZXcgQmlnRGVjaW1hbChCaWdEZWNpbWFsLm1pbnVzT25lQmlnSW50ICogdGhpcy5pbnRWYWwudmFsdWVPZigpLCBCaWdEZWNpbWFsLklORkxBVEVELCB0aGlzLl9zY2FsZSwgdGhpcy5fcHJlY2lzaW9uKSA6XG4gICAgICAgICAgICBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMigtdGhpcy5pbnRDb21wYWN0LCB0aGlzLl9zY2FsZSwgdGhpcy5fcHJlY2lzaW9uKTtcbiAgICAgICAgaWYgKG1jKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGx1cyhtYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCaWdEZWNpbWFsYCB3aG9zZSB2YWx1ZSBpcyBgKHRoaXMgKyBhdWdlbmQpYCxcbiAgICAgKiB3aXRoIHJvdW5kaW5nIGFjY29yZGluZyB0byB0aGUgY29udGV4dCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIElmIGVpdGhlciBudW1iZXIgaXMgemVybyBhbmQgdGhlIHByZWNpc2lvbiBzZXR0aW5nIGlzIG5vbnplcm8gdGhlblxuICAgICAqIHRoZSBvdGhlciBudW1iZXIsIHJvdW5kZWQgaWYgbmVjZXNzYXJ5LCBpcyB1c2VkIGFzIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXVnZW5kIHZhbHVlIHRvIGJlIGFkZGVkIHRvIHRoaXMgYEJpZ0RlY2ltYWxgLiBUaGlzIHZhbHVlIHdpbGxcbiAgICAgKiBiZSBjb252ZXJ0ZWQgdG8gYSBgQmlnRGVjaW1hbGAgYmVmb3JlIHRoZSBvcGVyYXRpb24uXG4gICAgICogU2VlIHRoZSB7QGxpbmsgQmlnIHwgY29uc3RydWN0b3J9IHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIGNvbnZlcnNpb24uXG4gICAgICogQHBhcmFtIG1jIHRoZSBjb250ZXh0IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIGB0aGlzICsgYXVnZW5kYCwgcm91bmRlZCBhcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgYWRkKGF1Z2VuZCwgbWMpIHtcbiAgICAgICAgYXVnZW5kID0gQmlnRGVjaW1hbC5jb252ZXJ0VG9CaWdEZWNpbWFsKGF1Z2VuZCk7XG4gICAgICAgIGlmICghbWMgfHwgKG1jICYmIG1jLnByZWNpc2lvbiA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludENvbXBhY3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXVnZW5kLmludENvbXBhY3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuYWRkMyh0aGlzLmludENvbXBhY3QsIHRoaXMuX3NjYWxlLCBhdWdlbmQuaW50Q29tcGFjdCwgYXVnZW5kLl9zY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5hZGQyKHRoaXMuaW50Q29tcGFjdCwgdGhpcy5fc2NhbGUsIGF1Z2VuZC5pbnRWYWwsIGF1Z2VuZC5fc2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhdWdlbmQuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5hZGQyKGF1Z2VuZC5pbnRDb21wYWN0LCBhdWdlbmQuX3NjYWxlLCB0aGlzLmludFZhbCwgdGhpcy5fc2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuYWRkMSh0aGlzLmludFZhbCwgdGhpcy5fc2NhbGUsIGF1Z2VuZC5pbnRWYWwsIGF1Z2VuZC5fc2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBlaXRoZXIgbnVtYmVyIGlzIHplcm8gdGhlbiB0aGUgb3RoZXIgbnVtYmVyLCByb3VuZGVkIGFuZFxuICAgICAgICAvLyBzY2FsZWQgaWYgbmVjZXNzYXJ5LCBpcyB1c2VkIGFzIHRoZSByZXN1bHQuXG4gICAgICAgIGxldCBsaHMgPSB0aGlzO1xuICAgICAgICBjb25zdCBsaHNJc1plcm8gPSBsaHMuc2lnbnVtKCkgPT09IDA7XG4gICAgICAgIGNvbnN0IGF1Z2VuZElzWmVybyA9IGF1Z2VuZC5zaWdudW0oKSA9PT0gMDtcbiAgICAgICAgaWYgKGxoc0lzWmVybyB8fCBhdWdlbmRJc1plcm8pIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZlcnJlZFNjYWxlID0gTWF0aC5tYXgobGhzLl9zY2FsZSwgYXVnZW5kLl9zY2FsZSk7XG4gICAgICAgICAgICBpZiAobGhzSXNaZXJvICYmIGF1Z2VuZElzWmVybylcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC56ZXJvVmFsdWVPZihwcmVmZXJyZWRTY2FsZSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBsaHNJc1plcm8gPyBCaWdEZWNpbWFsLmRvUm91bmQoYXVnZW5kLCBtYykgOiBCaWdEZWNpbWFsLmRvUm91bmQobGhzLCBtYyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Ll9zY2FsZSA9PT0gcHJlZmVycmVkU2NhbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5fc2NhbGUgPiBwcmVmZXJyZWRTY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLnN0cmlwWmVyb3NUb01hdGNoU2NhbGUocmVzdWx0LmludFZhbCwgcmVzdWx0LmludENvbXBhY3QsIHJlc3VsdC5fc2NhbGUsIHByZWZlcnJlZFNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyByZXN1bHQuc2NhbGUgPCBwcmVmZXJyZWRTY2FsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbkRpZmYgPSBtYy5wcmVjaXNpb24gLSByZXN1bHQucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVEaWZmID0gcHJlZmVycmVkU2NhbGUgLSByZXN1bHQuX3NjYWxlO1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNpb25EaWZmID49IHNjYWxlRGlmZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXRTY2FsZShwcmVmZXJyZWRTY2FsZSk7IC8vIGNhbiBhY2hpZXZlIHRhcmdldCBzY2FsZVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXRTY2FsZShyZXN1bHQuX3NjYWxlICsgcHJlY2lzaW9uRGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IGxocy5fc2NhbGUgLSBhdWdlbmQuX3NjYWxlO1xuICAgICAgICBpZiAocGFkZGluZyAhPT0gMCkgeyAvLyBzY2FsZXMgZGlmZmVyOyBhbGlnbm1lbnQgbmVlZGVkXG4gICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLnByZUFsaWduKGF1Z2VuZCwgcGFkZGluZywgbWMpO1xuICAgICAgICAgICAgQmlnRGVjaW1hbC5tYXRjaFNjYWxlKGFyZyk7XG4gICAgICAgICAgICBsaHMgPSBhcmdbMF07XG4gICAgICAgICAgICBhdWdlbmQgPSBhcmdbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZG9Sb3VuZDIobGhzLmluZmxhdGVkKCkudmFsdWVPZigpICsgYXVnZW5kLmluZmxhdGVkKCkudmFsdWVPZigpLCBsaHMuX3NjYWxlLCBtYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXMgYCh0aGlzIC0gc3VidHJhaGVuZClgLFxuICAgICAqIHdpdGggcm91bmRpbmcgYWNjb3JkaW5nIHRvIHRoZSBjb250ZXh0IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogSWYgYHN1YnRyYWhlbmRgIGlzIHplcm8gdGhlbiB0aGlzLCByb3VuZGVkIGlmIG5lY2Vzc2FyeSwgaXMgdXNlZCBhcyB0aGVcbiAgICAgKiByZXN1bHQuICBJZiB0aGlzIGlzIHplcm8gdGhlbiB0aGUgcmVzdWx0IGlzIGBzdWJ0cmFoZW5kLm5lZ2F0ZShtYylgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1YnRyYWhlbmQgdmFsdWUgdG8gYmUgc3VidHJhY3RlZCBmcm9tIHRoaXMgYEJpZ0RlY2ltYWxgLiBUaGlzIHZhbHVlXG4gICAgICogd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQmlnRGVjaW1hbGAgYmVmb3JlIHRoZSBvcGVyYXRpb24uXG4gICAgICogU2VlIHRoZSB7QGxpbmsgQmlnIHwgY29uc3RydWN0b3J9IHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIGNvbnZlcnNpb24uXG4gICAgICogQHBhcmFtIG1jIHRoZSBjb250ZXh0IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIGB0aGlzIC0gc3VidHJhaGVuZGAsIHJvdW5kZWQgYXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHN1YnRyYWN0KHN1YnRyYWhlbmQsIG1jKSB7XG4gICAgICAgIHN1YnRyYWhlbmQgPSBCaWdEZWNpbWFsLmNvbnZlcnRUb0JpZ0RlY2ltYWwoc3VidHJhaGVuZCk7XG4gICAgICAgIGlmICghbWMgfHwgKG1jICYmIG1jLnByZWNpc2lvbiA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludENvbXBhY3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHN1YnRyYWhlbmQuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuYWRkMyh0aGlzLmludENvbXBhY3QsIHRoaXMuX3NjYWxlLCAtc3VidHJhaGVuZC5pbnRDb21wYWN0LCBzdWJ0cmFoZW5kLl9zY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5hZGQyKHRoaXMuaW50Q29tcGFjdCwgdGhpcy5fc2NhbGUsIEJpZ0RlY2ltYWwubWludXNPbmVCaWdJbnQgKiBzdWJ0cmFoZW5kLmludFZhbC52YWx1ZU9mKCksIHN1YnRyYWhlbmQuX3NjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHN1YnRyYWhlbmQuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFpciBvZiBzdWJ0cmFoZW5kIHZhbHVlcyBnaXZlbiBiZWZvcmUgcGFpciBvZlxuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgZnJvbSB0aGlzIEJpZ0RlY2ltYWwgdG8gYXZvaWQgbmVlZCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kIG92ZXJsb2FkaW5nIG9uIHRoZSBzcGVjaWFsaXplZCBhZGQgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmFkZDIoLXN1YnRyYWhlbmQuaW50Q29tcGFjdCwgc3VidHJhaGVuZC5fc2NhbGUsIHRoaXMuaW50VmFsLCB0aGlzLl9zY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5hZGQxKHRoaXMuaW50VmFsLCB0aGlzLl9zY2FsZSwgQmlnRGVjaW1hbC5taW51c09uZUJpZ0ludCAqIHN1YnRyYWhlbmQuaW50VmFsLnZhbHVlT2YoKSwgc3VidHJhaGVuZC5fc2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzaGFyZSB0aGUgc3BlY2lhbCByb3VuZGluZyBjb2RlIGluIGFkZCgpXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZ2F0ZSgpLCBtYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXMgPGNvZGU+KHRoaXMgJnRpbWVzO1xuICAgICAqIG11bHRpcGxpY2FuZCk8L2NvZGU+LCB3aXRoIHJvdW5kaW5nIGFjY29yZGluZyB0byB0aGUgY29udGV4dCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtdWx0aXBsaWNhbmQgdmFsdWUgdG8gYmUgbXVsdGlwbGllZCBieSB0aGlzIGBCaWdEZWNpbWFsYC4gVGhpc1xuICAgICAqIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYEJpZ0RlY2ltYWxgIGJlZm9yZSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIFNlZSB0aGUge0BsaW5rIEJpZyB8IGNvbnN0cnVjdG9yfSB0byBsZWFybiBtb3JlIGFib3V0IHRoZSBjb252ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBtYyB0aGUgY29udGV4dCB0byB1c2UuXG4gICAgICogQHJldHVybiBgdGhpcyAqIG11bHRpcGxpY2FuZGAsIHJvdW5kZWQgYXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIG11bHRpcGx5KG11bHRpcGxpY2FuZCwgbWMpIHtcbiAgICAgICAgbXVsdGlwbGljYW5kID0gQmlnRGVjaW1hbC5jb252ZXJ0VG9CaWdEZWNpbWFsKG11bHRpcGxpY2FuZCk7XG4gICAgICAgIGlmICghbWMgfHwgKG1jICYmIG1jLnByZWNpc2lvbiA9PT0gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RTY2FsZSA9IHRoaXMuY2hlY2tTY2FsZSh0aGlzLl9zY2FsZSArIG11bHRpcGxpY2FuZC5fc2NhbGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgIGlmICgobXVsdGlwbGljYW5kLmludENvbXBhY3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLm11bHRpcGx5Mih0aGlzLmludENvbXBhY3QsIG11bHRpcGxpY2FuZC5pbnRDb21wYWN0LCBwcm9kdWN0U2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwubXVsdGlwbHkzKHRoaXMuaW50Q29tcGFjdCwgbXVsdGlwbGljYW5kLmludFZhbCwgcHJvZHVjdFNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKG11bHRpcGxpY2FuZC5pbnRDb21wYWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5tdWx0aXBseTMobXVsdGlwbGljYW5kLmludENvbXBhY3QsIHRoaXMuaW50VmFsLCBwcm9kdWN0U2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwubXVsdGlwbHk0KHRoaXMuaW50VmFsLCBtdWx0aXBsaWNhbmQuaW50VmFsLCBwcm9kdWN0U2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9kdWN0U2NhbGUgPSB0aGlzLmNoZWNrU2NhbGUodGhpcy5fc2NhbGUgKyBtdWx0aXBsaWNhbmQuX3NjYWxlKTtcbiAgICAgICAgaWYgKHRoaXMuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgaWYgKChtdWx0aXBsaWNhbmQuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5tdWx0aXBseUFuZFJvdW5kMSh0aGlzLmludENvbXBhY3QsIG11bHRpcGxpY2FuZC5pbnRDb21wYWN0LCBwcm9kdWN0U2NhbGUsIG1jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLm11bHRpcGx5QW5kUm91bmQyKHRoaXMuaW50Q29tcGFjdCwgbXVsdGlwbGljYW5kLmludFZhbCwgcHJvZHVjdFNjYWxlLCBtYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKG11bHRpcGxpY2FuZC5pbnRDb21wYWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLm11bHRpcGx5QW5kUm91bmQyKG11bHRpcGxpY2FuZC5pbnRDb21wYWN0LCB0aGlzLmludFZhbCwgcHJvZHVjdFNjYWxlLCBtYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5tdWx0aXBseUFuZFJvdW5kMyh0aGlzLmludFZhbCwgbXVsdGlwbGljYW5kLmludFZhbCwgcHJvZHVjdFNjYWxlLCBtYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCaWdEZWNpbWFsYCB3aG9zZSB2YWx1ZSBpcyBgKHRoaXMgLyBkaXZpc29yKWAsXG4gICAgICogYW5kIHdob3NlIHNjYWxlIGlzIGFzIHNwZWNpZmllZC4gIElmIHJvdW5kaW5nIG11c3RcbiAgICAgKiBiZSBwZXJmb3JtZWQgdG8gZ2VuZXJhdGUgYSByZXN1bHQgd2l0aCB0aGUgc3BlY2lmaWVkIHNjYWxlLCB0aGVcbiAgICAgKiBzcGVjaWZpZWQgcm91bmRpbmcgbW9kZSBpcyBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpdmlzb3IgdmFsdWUgYnkgd2hpY2ggdGhpcyBgQmlnRGVjaW1hbGAgaXMgdG8gYmUgZGl2aWRlZC5cbiAgICAgKiBUaGlzIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYEJpZ0RlY2ltYWxgIGJlZm9yZSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIFNlZSB0aGUge0BsaW5rIEJpZyB8IGNvbnN0cnVjdG9yfSB0byBsZWFybiBtb3JlIGFib3V0IHRoZSBjb252ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBzY2FsZSBzY2FsZSBvZiB0aGUgYEJpZ0RlY2ltYWxgIHF1b3RpZW50IHRvIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSByb3VuZGluZ01vZGUgcm91bmRpbmcgbW9kZSB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIGB0aGlzIC8gZGl2aXNvcmBcbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3JcbiAgICAgKiAqIElmIGBkaXZpc29yYCBpcyB6ZXJvXG4gICAgICogKiBJZiBgcm91bmRpbmdNb2RlPT1Sb3VuZGluZ01vZGUuVU5ORUNFU1NBUllgIGFuZCB0aGUgc3BlY2lmaWVkIHNjYWxlIGlzIGluc3VmZmljaWVudCB0byByZXByZXNlbnQgdGhlIHJlc3VsdFxuICAgICAqICAgb2YgdGhlIGRpdmlzaW9uIGV4YWN0bHkuXG4gICAgICogKiBJZiBzY2FsZSBpcyBnaXZlbiBidXQgcm91bmRpbmcgbW9kZSBpcyBub3QgZ2l2ZW4uXG4gICAgICovXG4gICAgZGl2aWRlKGRpdmlzb3IsIHNjYWxlLCByb3VuZGluZ01vZGUpIHtcbiAgICAgICAgZGl2aXNvciA9IEJpZ0RlY2ltYWwuY29udmVydFRvQmlnRGVjaW1hbChkaXZpc29yKTtcbiAgICAgICAgLypcbiAgICAgICAgICogSGFuZGxlIHplcm8gY2FzZXMgZmlyc3QuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZGl2aXNvci5zaWdudW0oKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpdmlzaW9uIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpdmlzaW9uIGJ5IHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91bmRpbmdNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1JvdW5kaW5nIG1vZGUgaXMgbmVjZXNzYXJ5IGlmIHNjYWxlIGlzIGdpdmVuLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlNihkaXZpc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3VuZGluZ01vZGUgPCBSb3VuZGluZ01vZGUuVVAgfHwgcm91bmRpbmdNb2RlID4gUm91bmRpbmdNb2RlLlVOTkVDRVNTQVJZKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHJvdW5kaW5nIG1vZGUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmludENvbXBhY3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRpdmlzb3IuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZGl2aWRlNyh0aGlzLmludENvbXBhY3QsIHRoaXMuX3NjYWxlLCBkaXZpc29yLmludENvbXBhY3QsIGRpdmlzb3IuX3NjYWxlLCBzY2FsZSwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZTgodGhpcy5pbnRDb21wYWN0LCB0aGlzLl9zY2FsZSwgZGl2aXNvci5pbnRWYWwsIGRpdmlzb3IuX3NjYWxlLCBzY2FsZSwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRpdmlzb3IuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZGl2aWRlOSh0aGlzLmludFZhbCwgdGhpcy5fc2NhbGUsIGRpdmlzb3IuaW50Q29tcGFjdCwgZGl2aXNvci5fc2NhbGUsIHNjYWxlLCByb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZGl2aWRlMTAodGhpcy5pbnRWYWwsIHRoaXMuX3NjYWxlLCBkaXZpc29yLmludFZhbCwgZGl2aXNvci5fc2NhbGUsIHNjYWxlLCByb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIHNhdHVyYXRlU2NhbGUoc2NhbGUpIHtcbiAgICAgICAgaWYgKHNjYWxlIDw9IEJpZ0RlY2ltYWwuTUFYX0lOVF9WQUxVRSAmJiBzY2FsZSA+PSBCaWdEZWNpbWFsLk1JTl9JTlRfVkFMVUUpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoc2NhbGUgPCAwID8gQmlnRGVjaW1hbC5NSU5fSU5UX1ZBTFVFIDogQmlnRGVjaW1hbC5NQVhfSU5UX1ZBTFVFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZGl2aWRlNihkaXZpc29yKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBwcmVmZXJyZWQgc2NhbGVcbiAgICAgICAgY29uc3QgcHJlZmVycmVkU2NhbGUgPSBCaWdEZWNpbWFsLnNhdHVyYXRlU2NhbGUodGhpcy5fc2NhbGUgLSBkaXZpc29yLl9zY2FsZSk7XG4gICAgICAgIGlmICh0aGlzLnNpZ251bSgpID09PSAwKSAvLyAwL3lcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLnplcm9WYWx1ZU9mKHByZWZlcnJlZFNjYWxlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgdGhlIHF1b3RpZW50IHRoaXMvZGl2aXNvciBoYXMgYSB0ZXJtaW5hdGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgKiBleHBhbnNpb24sIHRoZSBleHBhbnNpb24gY2FuIGhhdmUgbm8gbW9yZSB0aGFuXG4gICAgICAgICAgICAgKiAoYS5wcmVjaXNpb24oKSArIGNlaWwoMTAqYi5wcmVjaXNpb24pLzMpIGRpZ2l0cy5cbiAgICAgICAgICAgICAqIFRoZXJlZm9yZSwgY3JlYXRlIGEgTWF0aENvbnRleHQgb2JqZWN0IHdpdGggdGhpc1xuICAgICAgICAgICAgICogcHJlY2lzaW9uIGFuZCBkbyBhIGRpdmlkZSB3aXRoIHRoZSBVTk5FQ0VTU0FSWSByb3VuZGluZ1xuICAgICAgICAgICAgICogbW9kZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgbWMgPSBuZXcgTWF0aENvbnRleHQoTWF0aC5taW4odGhpcy5wcmVjaXNpb24oKSArIE1hdGguY2VpbCgxMC4wICogZGl2aXNvci5wcmVjaXNpb24oKSAvIDMuMCksIEJpZ0RlY2ltYWwuTUFYX0lOVF9WQUxVRSksIFJvdW5kaW5nTW9kZS5VTk5FQ0VTU0FSWSk7XG4gICAgICAgICAgICBsZXQgcXVvdGllbnQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gdGhpcy5kaXZpZGVXaXRoTWF0aENvbnRleHQoZGl2aXNvciwgbWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTm9uLXRlcm1pbmF0aW5nIGRlY2ltYWwgZXhwYW5zaW9uOyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ25vIGV4YWN0IHJlcHJlc2VudGFibGUgZGVjaW1hbCByZXN1bHQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdW90aWVudFNjYWxlID0gcXVvdGllbnQuc2NhbGUoKTtcbiAgICAgICAgICAgIC8vIGRpdmlkZShCaWdEZWNpbWFsLCBtYykgdHJpZXMgdG8gYWRqdXN0IHRoZSBxdW90aWVudCB0b1xuICAgICAgICAgICAgLy8gdGhlIGRlc2lyZWQgb25lIGJ5IHJlbW92aW5nIHRyYWlsaW5nIHplcm9zOyBzaW5jZSB0aGVcbiAgICAgICAgICAgIC8vIGV4YWN0IGRpdmlkZSBtZXRob2QgZG9lcyBub3QgaGF2ZSBhbiBleHBsaWNpdCBkaWdpdFxuICAgICAgICAgICAgLy8gbGltaXQsIHdlIGNhbiBhZGQgemVyb3MgdG9vLlxuICAgICAgICAgICAgaWYgKHByZWZlcnJlZFNjYWxlID4gcXVvdGllbnRTY2FsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGllbnQuc2V0U2NhbGUocHJlZmVycmVkU2NhbGUsIFJvdW5kaW5nTW9kZS5VTk5FQ0VTU0FSWSk7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGllbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCaWdEZWNpbWFsYCB3aG9zZSB2YWx1ZSBpcyBgKHRoaXMgL1xuICAgICAqIGRpdmlzb3IpYCwgd2l0aCByb3VuZGluZyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRleHQgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGl2aXNvciB2YWx1ZSBieSB3aGljaCB0aGlzIGBCaWdEZWNpbWFsYCBpcyB0byBiZSBkaXZpZGVkLlxuICAgICAqIFRoaXMgdmFsdWUgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQmlnRGVjaW1hbGAgYmVmb3JlIHRoZSBvcGVyYXRpb24uXG4gICAgICogU2VlIHRoZSB7QGxpbmsgQmlnIHwgY29uc3RydWN0b3J9IHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIGNvbnZlcnNpb24uXG4gICAgICogQHBhcmFtIG1jIHRoZSBjb250ZXh0IHRvIHVzZS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgdGhlIGV4YWN0IHF1b3RpZW50IGRvZXMgbm90IGhhdmUgYVxuICAgICAqICAgICAgICAgdGVybWluYXRpbmcgZGVjaW1hbCBleHBhbnNpb24sIGluY2x1ZGluZyBkaXZpZGluZyBieSB6ZXJvXG4gICAgICogQHJldHVybiBgdGhpcyAvIGRpdmlzb3JgXG4gICAgICovXG4gICAgZGl2aWRlV2l0aE1hdGhDb250ZXh0KGRpdmlzb3IsIG1jKSB7XG4gICAgICAgIGRpdmlzb3IgPSBCaWdEZWNpbWFsLmNvbnZlcnRUb0JpZ0RlY2ltYWwoZGl2aXNvcik7XG4gICAgICAgIGlmIChkaXZpc29yLnNpZ251bSgpID09PSAwKSB7IC8vIHgvMFxuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT09IDApIC8vIDAvMFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaXZpc2lvbiB1bmRlZmluZWQnKTsgLy8gTmFOXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGl2aXNpb24gYnkgemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWMgfHwgKG1jICYmIG1jLnByZWNpc2lvbiA9PT0gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZlcnJlZFNjYWxlID0gQmlnRGVjaW1hbC5zYXR1cmF0ZVNjYWxlKHRoaXMuX3NjYWxlIC0gZGl2aXNvci5fc2NhbGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuemVyb1ZhbHVlT2YocHJlZmVycmVkU2NhbGUpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWMgPSBuZXcgTWF0aENvbnRleHQoTWF0aC5taW4odGhpcy5wcmVjaXNpb24oKSArIE1hdGguY2VpbCgxMC4wICogZGl2aXNvci5wcmVjaXNpb24oKSAvIDMuMCksIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgUm91bmRpbmdNb2RlLlVOTkVDRVNTQVJZKTtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGllbnQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGllbnQgPSB0aGlzLmRpdmlkZVdpdGhNYXRoQ29udGV4dChkaXZpc29yLCBtYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOb24tdGVybWluYXRpbmcgZGVjaW1hbCBleHBhbnNpb247IG5vIGV4YWN0IHJlcHJlc2VudGFibGUgZGVjaW1hbCByZXN1bHQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHF1b3RpZW50U2NhbGUgPSBxdW90aWVudC5fc2NhbGU7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZlcnJlZFNjYWxlID4gcXVvdGllbnRTY2FsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1b3RpZW50LnNldFNjYWxlKHByZWZlcnJlZFNjYWxlLCBSb3VuZGluZ01vZGUuVU5ORUNFU1NBUlkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBxdW90aWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVmZXJyZWRTY2FsZSA9IHRoaXMuX3NjYWxlIC0gZGl2aXNvci5fc2NhbGU7XG4gICAgICAgIC8vIE5vdyBjYWxjdWxhdGUgdGhlIGFuc3dlci4gIFdlIHVzZSB0aGUgZXhpc3RpbmdcbiAgICAgICAgLy8gZGl2aWRlLWFuZC1yb3VuZCBtZXRob2QsIGJ1dCBhcyB0aGlzIHJvdW5kcyB0byBzY2FsZSB3ZSBoYXZlXG4gICAgICAgIC8vIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWVzIGhlcmUgdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCByZXN1bHQuXG4gICAgICAgIC8vIEZvciB4L3kgd2UgZmlyc3QgaGFuZGxlIHk9MCBhbmQgeD0wLCBhbmQgdGhlbiBub3JtYWxpemUgeCBhbmRcbiAgICAgICAgLy8geSB0byBnaXZlIHgnIGFuZCB5JyB3aXRoIHRoZSBmb2xsb3dpbmcgY29uc3RyYWludHM6XG4gICAgICAgIC8vICAgKGEpIDAuMSA8PSB4JyA8IDFcbiAgICAgICAgLy8gICAoYikgIHgnIDw9IHknIDwgMTAqeCdcbiAgICAgICAgLy8gRGl2aWRpbmcgeCcveScgd2l0aCB0aGUgcmVxdWlyZWQgc2NhbGUgc2V0IHRvIG1jLnByZWNpc2lvbiB0aGVuXG4gICAgICAgIC8vIHdpbGwgZ2l2ZSBhIHJlc3VsdCBpbiB0aGUgcmFuZ2UgMC4xIHRvIDEgcm91bmRlZCB0byBleGFjdGx5XG4gICAgICAgIC8vIHRoZSByaWdodCBudW1iZXIgb2YgZGlnaXRzIChleGNlcHQgaW4gdGhlIGNhc2Ugb2YgYSByZXN1bHQgb2ZcbiAgICAgICAgLy8gMS4wMDAuLi4gd2hpY2ggY2FuIGFyaXNlIHdoZW4geD15LCBvciB3aGVuIHJvdW5kaW5nIG92ZXJmbG93c1xuICAgICAgICAvLyBUaGUgMS4wMDAuLi4gY2FzZSB3aWxsIHJlZHVjZSBwcm9wZXJseSB0byAxLlxuICAgICAgICBpZiAodGhpcy5zaWdudW0oKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLnplcm9WYWx1ZU9mKEJpZ0RlY2ltYWwuc2F0dXJhdGVTY2FsZShwcmVmZXJyZWRTY2FsZSkpO1xuICAgICAgICBjb25zdCB4c2NhbGUgPSB0aGlzLnByZWNpc2lvbigpO1xuICAgICAgICBjb25zdCB5c2NhbGUgPSBkaXZpc29yLnByZWNpc2lvbigpO1xuICAgICAgICBpZiAodGhpcy5pbnRDb21wYWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICBpZiAoZGl2aXNvci5pbnRDb21wYWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZGl2aWRlMih0aGlzLmludENvbXBhY3QsIHhzY2FsZSwgZGl2aXNvci5pbnRDb21wYWN0LCB5c2NhbGUsIHByZWZlcnJlZFNjYWxlLCBtYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kaXZpZGUzKHRoaXMuaW50Q29tcGFjdCwgeHNjYWxlLCBkaXZpc29yLmludFZhbCwgeXNjYWxlLCBwcmVmZXJyZWRTY2FsZSwgbWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZTQodGhpcy5pbnRWYWwsIHhzY2FsZSwgZGl2aXNvci5pbnRDb21wYWN0LCB5c2NhbGUsIHByZWZlcnJlZFNjYWxlLCBtYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kaXZpZGU1KHRoaXMuaW50VmFsLCB4c2NhbGUsIGRpdmlzb3IuaW50VmFsLCB5c2NhbGUsIHByZWZlcnJlZFNjYWxlLCBtYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBtdWx0aXBseTEoeCwgeSkge1xuICAgICAgICBjb25zdCBwcm9kdWN0ID0geCAqIHk7XG4gICAgICAgIGlmIChwcm9kdWN0IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIHByb2R1Y3QgPiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuSU5GTEFURUQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgbXVsdGlwbHkyKHgsIHksIHNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHByb2R1Y3QgPSBCaWdEZWNpbWFsLm11bHRpcGx5MSh4LCB5KTtcbiAgICAgICAgaWYgKHByb2R1Y3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMyhwcm9kdWN0LCBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKEJpZ0ludCh4KSAqIEJpZ0ludCh5KSwgQmlnRGVjaW1hbC5JTkZMQVRFRCwgc2NhbGUsIDApO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIG11bHRpcGx5Myh4LCB5LCBzY2FsZSkge1xuICAgICAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuemVyb1ZhbHVlT2Yoc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbCh5LnZhbHVlT2YoKSAqIEJpZ0ludCh4KSwgQmlnRGVjaW1hbC5JTkZMQVRFRCwgc2NhbGUsIDApO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIG11bHRpcGx5NCh4LCB5LCBzY2FsZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwoeC52YWx1ZU9mKCkgKiB5LnZhbHVlT2YoKSwgQmlnRGVjaW1hbC5JTkZMQVRFRCwgc2NhbGUsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byBpbnRlZ2VycyBhbmQgcm91bmRzIGFjY29yZGluZyB0byBgTWF0aENvbnRleHRgXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIG11bHRpcGx5QW5kUm91bmQxKHgsIHksIHNjYWxlLCBtYykge1xuICAgICAgICBjb25zdCBwcm9kdWN0ID0gQmlnRGVjaW1hbC5tdWx0aXBseTEoeCwgeSk7XG4gICAgICAgIGlmIChwcm9kdWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kb1JvdW5kMyhwcm9kdWN0LCBzY2FsZSwgbWMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByc2lnbiA9IDE7XG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgeCA9IC14O1xuICAgICAgICAgICAgcnNpZ24gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgICAgIHkgPSAteTtcbiAgICAgICAgICAgIHJzaWduICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBCaWdEZWNpbWFsKEJpZ0ludCh4KSAqIEJpZ0ludCh5KSAqIEJpZ0ludChyc2lnbiksIEJpZ0RlY2ltYWwuSU5GTEFURUQsIHNjYWxlLCAwKTtcbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZG9Sb3VuZChyZXMsIG1jKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBtdWx0aXBseUFuZFJvdW5kMih4LCB5LCBzY2FsZSwgbWMpIHtcbiAgICAgICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLnplcm9WYWx1ZU9mKHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kb1JvdW5kMih5LnZhbHVlT2YoKSAqIEJpZ0ludCh4KSwgc2NhbGUsIG1jKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBtdWx0aXBseUFuZFJvdW5kMyh4LCB5LCBzY2FsZSwgbWMpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZG9Sb3VuZDIoeC52YWx1ZU9mKCkgKiB5LnZhbHVlT2YoKSwgc2NhbGUsIG1jKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBkaXZpZGUyKHhzLCB4c2NhbGUsIHlzLCB5c2NhbGUsIHByZWZlcnJlZFNjYWxlLCBtYykge1xuICAgICAgICBjb25zdCBtY3AgPSBtYy5wcmVjaXNpb247XG4gICAgICAgIGlmICh4c2NhbGUgPD0geXNjYWxlICYmIHlzY2FsZSA8IDE1ICYmIG1jcCA8IDE1KSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kaXZpZGVTbWFsbEZhc3RQYXRoKHhzLCB4c2NhbGUsIHlzLCB5c2NhbGUsIHByZWZlcnJlZFNjYWxlLCBtYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJpZ0RlY2ltYWwuY29tcGFyZU1hZ25pdHVkZU5vcm1hbGl6ZWQoeHMsIHhzY2FsZSwgeXMsIHlzY2FsZSkgPiAwKSB7IC8vIHNhdGlzZnkgY29uc3RyYWludCAoYilcbiAgICAgICAgICAgIHlzY2FsZSAtPSAxOyAvLyBbdGhhdCBpcywgZGl2aXNvciAqPSAxMF1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBtYy5yb3VuZGluZ01vZGU7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIGRpdmlkZSBnZW5lcmF0ZXMgdGhlIGV4YWN0IHJlc3VsdCxcbiAgICAgICAgLy8gd2UgYXZvaWQgY2FsbGluZyB0aGUgYWJvdmUgZGl2aWRlIG1ldGhvZC4gJ3F1b3RpZW50JyBob2xkcyB0aGVcbiAgICAgICAgLy8gcmV0dXJuIEJpZ0RlY2ltYWwgb2JqZWN0IHdob3NlIHNjYWxlIHdpbGwgYmUgc2V0IHRvICdzY2wnLlxuICAgICAgICBjb25zdCBzY2wgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlICsgeXNjYWxlIC0geHNjYWxlICsgbWNwKTtcbiAgICAgICAgbGV0IHF1b3RpZW50O1xuICAgICAgICBpZiAoQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhtY3AgKyB5c2NhbGUgLSB4c2NhbGUpID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmFpc2UgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKG1jcCArIHlzY2FsZSAtIHhzY2FsZSk7XG4gICAgICAgICAgICBsZXQgc2NhbGVkWHM7XG4gICAgICAgICAgICBpZiAoKHNjYWxlZFhzID0gQmlnRGVjaW1hbC5pbnRlZ2VyTXVsdGlwbHlQb3dlclRlbih4cywgcmFpc2UpKSA9PT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJiID0gQmlnRGVjaW1hbC5iaWdNdWx0aXBseVBvd2VyVGVuMih4cywgcmFpc2UpO1xuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDQocmIsIHlzLCBzY2wsIHJvdW5kaW5nTW9kZSwgQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhwcmVmZXJyZWRTY2FsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMihzY2FsZWRYcywgeXMsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTY2FsZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8oeHNjYWxlIC0gbWNwKTtcbiAgICAgICAgICAgIGlmIChuZXdTY2FsZSA9PT0geXNjYWxlKSB7IC8vIGVhc3kgY2FzZVxuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDIoeHMsIHlzLCBzY2wsIHJvdW5kaW5nTW9kZSwgQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhwcmVmZXJyZWRTY2FsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFpc2UgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKG5ld1NjYWxlIC0geXNjYWxlKTtcbiAgICAgICAgICAgICAgICBsZXQgc2NhbGVkWXM7XG4gICAgICAgICAgICAgICAgaWYgKChzY2FsZWRZcyA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeXMsIHJhaXNlKSkgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmIgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4yKHlzLCByYWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDMoQmlnSW50KHhzKSwgcmIsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQyKHhzLCBzY2FsZWRZcywgc2NsLCByb3VuZGluZ01vZGUsIEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9Sb3VuZCwgaGVyZSwgb25seSBhZmZlY3RzIDEwMDAwMDAwMDAgY2FzZS5cbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZG9Sb3VuZChxdW90aWVudCwgbWMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGRpdmlkZTMoeHMsIHhzY2FsZSwgeXMsIHlzY2FsZSwgcHJlZmVycmVkU2NhbGUsIG1jKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBkaXZpZGVuZCAmIGRpdmlzb3Igc28gdGhhdCBib3RoIGZhbGwgaW50byBbMC4xLCAwLjk5OS4uLl1cbiAgICAgICAgaWYgKEJpZ0RlY2ltYWwuY29tcGFyZU1hZ25pdHVkZU5vcm1hbGl6ZWQyKHhzLCB4c2NhbGUsIHlzLCB5c2NhbGUpID4gMCkgeyAvLyBzYXRpc2Z5IGNvbnN0cmFpbnQgKGIpXG4gICAgICAgICAgICB5c2NhbGUgLT0gMTsgLy8gW3RoYXQgaXMsIGRpdmlzb3IgKj0gMTBdXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWNwID0gbWMucHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBtYy5yb3VuZGluZ01vZGU7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIGRpdmlkZSBnZW5lcmF0ZXMgdGhlIGV4YWN0IHJlc3VsdCxcbiAgICAgICAgLy8gd2UgYXZvaWQgY2FsbGluZyB0aGUgYWJvdmUgZGl2aWRlIG1ldGhvZC4gJ3F1b3RpZW50JyBob2xkcyB0aGVcbiAgICAgICAgLy8gcmV0dXJuIEJpZ0RlY2ltYWwgb2JqZWN0IHdob3NlIHNjYWxlIHdpbGwgYmUgc2V0IHRvICdzY2wnLlxuICAgICAgICBsZXQgcXVvdGllbnQ7XG4gICAgICAgIGNvbnN0IHNjbCA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUgKyB5c2NhbGUgLSB4c2NhbGUgKyBtY3ApO1xuICAgICAgICBpZiAoQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhtY3AgKyB5c2NhbGUgLSB4c2NhbGUpID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmFpc2UgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKG1jcCArIHlzY2FsZSAtIHhzY2FsZSk7XG4gICAgICAgICAgICBjb25zdCByYiA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjIoeHMsIHJhaXNlKTtcbiAgICAgICAgICAgIHF1b3RpZW50ID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDMocmIsIHlzLCBzY2wsIHJvdW5kaW5nTW9kZSwgQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhwcmVmZXJyZWRTY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHhzY2FsZSAtIG1jcCk7XG4gICAgICAgICAgICBjb25zdCByYWlzZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8obmV3U2NhbGUgLSB5c2NhbGUpO1xuICAgICAgICAgICAgY29uc3QgcmIgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4zKHlzLCByYWlzZSk7XG4gICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQzKEJpZ0ludCh4cyksIHJiLCBzY2wsIHJvdW5kaW5nTW9kZSwgQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhwcmVmZXJyZWRTY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvUm91bmQsIGhlcmUsIG9ubHkgYWZmZWN0cyAxMDAwMDAwMDAwIGNhc2UuXG4gICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRvUm91bmQocXVvdGllbnQsIG1jKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBkaXZpZGU0KHhzLCB4c2NhbGUsIHlzLCB5c2NhbGUsIHByZWZlcnJlZFNjYWxlLCBtYykge1xuICAgICAgICAvLyBOb3JtYWxpemUgZGl2aWRlbmQgJiBkaXZpc29yIHNvIHRoYXQgYm90aCBmYWxsIGludG8gWzAuMSwgMC45OTkuLi5dXG4gICAgICAgIGlmICgoLUJpZ0RlY2ltYWwuY29tcGFyZU1hZ25pdHVkZU5vcm1hbGl6ZWQyKHlzLCB5c2NhbGUsIHhzLCB4c2NhbGUpKSA+IDApIHsgLy8gc2F0aXNmeSBjb25zdHJhaW50IChiKVxuICAgICAgICAgICAgeXNjYWxlIC09IDE7IC8vIFt0aGF0IGlzLCBkaXZpc29yICo9IDEwXVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1jcCA9IG1jLnByZWNpc2lvbjtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gbWMucm91bmRpbmdNb2RlO1xuICAgICAgICAvLyBJbiBvcmRlciB0byBmaW5kIG91dCB3aGV0aGVyIHRoZSBkaXZpZGUgZ2VuZXJhdGVzIHRoZSBleGFjdCByZXN1bHQsXG4gICAgICAgIC8vIHdlIGF2b2lkIGNhbGxpbmcgdGhlIGFib3ZlIGRpdmlkZSBtZXRob2QuICdxdW90aWVudCcgaG9sZHMgdGhlXG4gICAgICAgIC8vIHJldHVybiBCaWdEZWNpbWFsIG9iamVjdCB3aG9zZSBzY2FsZSB3aWxsIGJlIHNldCB0byAnc2NsJy5cbiAgICAgICAgbGV0IHF1b3RpZW50O1xuICAgICAgICBjb25zdCBzY2wgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlICsgeXNjYWxlIC0geHNjYWxlICsgbWNwKTtcbiAgICAgICAgaWYgKEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8obWNwICsgeXNjYWxlIC0geHNjYWxlKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJhaXNlID0gQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhtY3AgKyB5c2NhbGUgLSB4c2NhbGUpO1xuICAgICAgICAgICAgY29uc3QgcmIgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4zKHhzLCByYWlzZSk7XG4gICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQ0KHJiLCB5cywgc2NsLCByb3VuZGluZ01vZGUsIEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjYWxlID0gQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyh4c2NhbGUgLSBtY3ApO1xuICAgICAgICAgICAgaWYgKG5ld1NjYWxlID09PSB5c2NhbGUpIHsgLy8gZWFzeSBjYXNlXG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kNCh4cywgeXMsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYWlzZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8obmV3U2NhbGUgLSB5c2NhbGUpO1xuICAgICAgICAgICAgICAgIGxldCBzY2FsZWRZcztcbiAgICAgICAgICAgICAgICBpZiAoKHNjYWxlZFlzID0gQmlnRGVjaW1hbC5pbnRlZ2VyTXVsdGlwbHlQb3dlclRlbih5cywgcmFpc2UpKSA9PT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYiA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjIoeXMsIHJhaXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGllbnQgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMyh4cywgcmIsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQ0KHhzLCBzY2FsZWRZcywgc2NsLCByb3VuZGluZ01vZGUsIEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9Sb3VuZCwgaGVyZSwgb25seSBhZmZlY3RzIDEwMDAwMDAwMDAgY2FzZS5cbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZG9Sb3VuZChxdW90aWVudCwgbWMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGRpdmlkZTUoeHMsIHhzY2FsZSwgeXMsIHlzY2FsZSwgcHJlZmVycmVkU2NhbGUsIG1jKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBkaXZpZGVuZCAmIGRpdmlzb3Igc28gdGhhdCBib3RoIGZhbGwgaW50byBbMC4xLCAwLjk5OS4uLl1cbiAgICAgICAgaWYgKEJpZ0RlY2ltYWwuY29tcGFyZU1hZ25pdHVkZU5vcm1hbGl6ZWQzKHhzLCB4c2NhbGUsIHlzLCB5c2NhbGUpID4gMCkgeyAvLyBzYXRpc2Z5IGNvbnN0cmFpbnQgKGIpXG4gICAgICAgICAgICB5c2NhbGUgLT0gMTsgLy8gW3RoYXQgaXMsIGRpdmlzb3IgKj0gMTBdXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWNwID0gbWMucHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBtYy5yb3VuZGluZ01vZGU7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIGRpdmlkZSBnZW5lcmF0ZXMgdGhlIGV4YWN0IHJlc3VsdCxcbiAgICAgICAgLy8gd2UgYXZvaWQgY2FsbGluZyB0aGUgYWJvdmUgZGl2aWRlIG1ldGhvZC4gJ3F1b3RpZW50JyBob2xkcyB0aGVcbiAgICAgICAgLy8gcmV0dXJuIEJpZ0RlY2ltYWwgb2JqZWN0IHdob3NlIHNjYWxlIHdpbGwgYmUgc2V0IHRvICdzY2wnLlxuICAgICAgICBsZXQgcXVvdGllbnQ7XG4gICAgICAgIGNvbnN0IHNjbCA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUgKyB5c2NhbGUgLSB4c2NhbGUgKyBtY3ApO1xuICAgICAgICBpZiAoQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhtY3AgKyB5c2NhbGUgLSB4c2NhbGUpID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmFpc2UgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKG1jcCArIHlzY2FsZSAtIHhzY2FsZSk7XG4gICAgICAgICAgICBjb25zdCByYiA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjMoeHMsIHJhaXNlKTtcbiAgICAgICAgICAgIHF1b3RpZW50ID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDMocmIsIHlzLCBzY2wsIHJvdW5kaW5nTW9kZSwgQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhwcmVmZXJyZWRTY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHhzY2FsZSAtIG1jcCk7XG4gICAgICAgICAgICBjb25zdCByYWlzZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8obmV3U2NhbGUgLSB5c2NhbGUpO1xuICAgICAgICAgICAgY29uc3QgcmIgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4zKHlzLCByYWlzZSk7XG4gICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQzKHhzLCByYiwgc2NsLCByb3VuZGluZ01vZGUsIEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb1JvdW5kLCBoZXJlLCBvbmx5IGFmZmVjdHMgMTAwMDAwMDAwMCBjYXNlLlxuICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kb1JvdW5kKHF1b3RpZW50LCBtYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydFxuICAgICAqIG9mIGAodGhpcyAvIGRpdmlzb3IpYC4gIFNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlXG4gICAgICogZXhhY3QgcXVvdGllbnQgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSByb3VuZGluZyBtb2RlLCB0aGVcbiAgICAgKiByb3VuZGluZyBtb2RlIGRvZXMgbm90IGFmZmVjdCB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoaXNcbiAgICAgKiBtZXRob2QuICBUaGUgcHJlZmVycmVkIHNjYWxlIG9mIHRoZSByZXN1bHQgaXNcbiAgICAgKiBgKHRoaXMuc2NhbGUoKSAtIGRpdmlzb3Iuc2NhbGUoKSlgLiBBXG4gICAgICogYFJhbmdlRXJyb3JgIGlzIHRocm93biBpZiB0aGUgaW50ZWdlciBwYXJ0IG9mXG4gICAgICogdGhlIGV4YWN0IHF1b3RpZW50IG5lZWRzIG1vcmUgdGhhbiBgbWMucHJlY2lzaW9uYFxuICAgICAqIGRpZ2l0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXZpc29yIHZhbHVlIGJ5IHdoaWNoIHRoaXMgYEJpZ0RlY2ltYWxgIGlzIHRvIGJlIGRpdmlkZWQuXG4gICAgICogVGhpcyB2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBCaWdEZWNpbWFsYCBiZWZvcmUgdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBTZWUgdGhlIHtAbGluayBCaWcgfCBjb25zdHJ1Y3Rvcn0gdG8gbGVhcm4gbW9yZSBhYm91dCB0aGUgY29udmVyc2lvbi5cbiAgICAgKiBAcGFyYW0gbWMgdGhlIGNvbnRleHQgdG8gdXNlLlxuICAgICAqIEByZXR1cm4gVGhlIGludGVnZXIgcGFydCBvZiBgdGhpcyAvIGRpdmlzb3JgLlxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBkaXZpc29yIGlzIDBcbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYG1jLnByZWNpc2lvbiA+IDBgIGFuZCB0aGUgcmVzdWx0XG4gICAgICogICAgICAgICByZXF1aXJlcyBhIHByZWNpc2lvbiBvZiBtb3JlIHRoYW4gYG1jLnByZWNpc2lvbmAgZGlnaXRzLlxuICAgICAqL1xuICAgIGRpdmlkZVRvSW50ZWdyYWxWYWx1ZShkaXZpc29yLCBtYykge1xuICAgICAgICBkaXZpc29yID0gQmlnRGVjaW1hbC5jb252ZXJ0VG9CaWdEZWNpbWFsKGRpdmlzb3IpO1xuICAgICAgICBpZiAoIW1jIHx8IChtYyAmJiAobWMucHJlY2lzaW9uID09PSAwIHx8IHRoaXMuY29tcGFyZU1hZ25pdHVkZShkaXZpc29yKSA8IDApKSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWZlcnJlZCBzY2FsZVxuICAgICAgICAgICAgY29uc3QgcHJlZmVycmVkU2NhbGUgPSBCaWdEZWNpbWFsLnNhdHVyYXRlU2NhbGUodGhpcy5fc2NhbGUgLSBkaXZpc29yLl9zY2FsZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlTWFnbml0dWRlKGRpdmlzb3IpIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIG11Y2ggZmFzdGVyIHdoZW4gdGhpcyA8PCBkaXZpc29yXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuemVyb1ZhbHVlT2YocHJlZmVycmVkU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT09IDAgJiYgZGl2aXNvci5zaWdudW0oKSAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTY2FsZShwcmVmZXJyZWRTY2FsZSwgUm91bmRpbmdNb2RlLlVOTkVDRVNTQVJZKTtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYSBkaXZpZGUgd2l0aCBlbm91Z2ggZGlnaXRzIHRvIHJvdW5kIHRvIGEgY29ycmVjdFxuICAgICAgICAgICAgLy8gaW50ZWdlciB2YWx1ZTsgdGhlbiByZW1vdmUgYW55IGZyYWN0aW9uYWwgZGlnaXRzXG4gICAgICAgICAgICBjb25zdCBtYXhEaWdpdHMgPSBNYXRoLm1pbih0aGlzLnByZWNpc2lvbigpICsgTWF0aC5jZWlsKDEwLjAgKiBkaXZpc29yLnByZWNpc2lvbigpIC8gMy4wKSArIE1hdGguYWJzKHRoaXMuX3NjYWxlIC0gZGl2aXNvci5fc2NhbGUpICsgMiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgICAgICAgICAgbGV0IHF1b3RpZW50ID0gdGhpcy5kaXZpZGVXaXRoTWF0aENvbnRleHQoZGl2aXNvciwgbmV3IE1hdGhDb250ZXh0KG1heERpZ2l0cywgUm91bmRpbmdNb2RlLkRPV04pKTtcbiAgICAgICAgICAgIGlmIChxdW90aWVudC5fc2NhbGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBxdW90aWVudC5zZXRTY2FsZSgwLCBSb3VuZGluZ01vZGUuRE9XTik7XG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBCaWdEZWNpbWFsLnN0cmlwWmVyb3NUb01hdGNoU2NhbGUocXVvdGllbnQuaW50VmFsLCBxdW90aWVudC5pbnRDb21wYWN0LCBxdW90aWVudC5fc2NhbGUsIHByZWZlcnJlZFNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdW90aWVudC5fc2NhbGUgPCBwcmVmZXJyZWRTY2FsZSkge1xuICAgICAgICAgICAgICAgIC8vIHBhZCB3aXRoIHplcm9zIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gcXVvdGllbnQuc2V0U2NhbGUocHJlZmVycmVkU2NhbGUsIFJvdW5kaW5nTW9kZS5VTk5FQ0VTU0FSWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcXVvdGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWZlcnJlZCBzY2FsZVxuICAgICAgICBjb25zdCBwcmVmZXJyZWRTY2FsZSA9IEJpZ0RlY2ltYWwuc2F0dXJhdGVTY2FsZSh0aGlzLl9zY2FsZSAtIGRpdmlzb3IuX3NjYWxlKTtcbiAgICAgICAgLypcbiAgICAgICAgICogUGVyZm9ybSBhIG5vcm1hbCBkaXZpZGUgdG8gbWMucHJlY2lzaW9uIGRpZ2l0cy4gIElmIHRoZVxuICAgICAgICAgKiByZW1haW5kZXIgaGFzIGFic29sdXRlIHZhbHVlIGxlc3MgdGhhbiB0aGUgZGl2aXNvciwgdGhlXG4gICAgICAgICAqIGludGVnZXIgcG9ydGlvbiBvZiB0aGUgcXVvdGllbnQgZml0cyBpbnRvIG1jLnByZWNpc2lvblxuICAgICAgICAgKiBkaWdpdHMuICBOZXh0LCByZW1vdmUgYW55IGZyYWN0aW9uYWwgZGlnaXRzIGZyb20gdGhlXG4gICAgICAgICAqIHF1b3RpZW50IGFuZCBhZGp1c3QgdGhlIHNjYWxlIHRvIHRoZSBwcmVmZXJyZWQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kaXZpZGVXaXRoTWF0aENvbnRleHQoZGl2aXNvciwgbmV3IE1hdGhDb250ZXh0KG1jLnByZWNpc2lvbiwgUm91bmRpbmdNb2RlLkRPV04pKTtcbiAgICAgICAgaWYgKHJlc3VsdC5fc2NhbGUgPCAwKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogUmVzdWx0IGlzIGFuIGludGVnZXIuIFNlZSBpZiBxdW90aWVudCByZXByZXNlbnRzIHRoZVxuICAgICAgICAgICAgICogZnVsbCBpbnRlZ2VyIHBvcnRpb24gb2YgdGhlIGV4YWN0IHF1b3RpZW50OyBpZiBpdCBkb2VzLFxuICAgICAgICAgICAgICogdGhlIGNvbXB1dGVkIHJlbWFpbmRlciB3aWxsIGJlIGxlc3MgdGhhbiB0aGUgZGl2aXNvci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IHJlc3VsdC5tdWx0aXBseShkaXZpc29yKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBxdW90aWVudCBpcyB0aGUgZnVsbCBpbnRlZ2VyIHZhbHVlLFxuICAgICAgICAgICAgLy8gfGRpdmlkZW5kLXByb2R1Y3R8IDwgfGRpdmlzb3J8LlxuICAgICAgICAgICAgaWYgKHRoaXMuc3VidHJhY3QocHJvZHVjdCkuY29tcGFyZU1hZ25pdHVkZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpdmlzaW9uIGltcG9zc2libGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQuX3NjYWxlID4gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEludGVnZXIgcG9ydGlvbiBvZiBxdW90aWVudCB3aWxsIGZpdCBpbnRvIHByZWNpc2lvblxuICAgICAgICAgICAgICogZGlnaXRzOyByZWNvbXB1dGUgcXVvdGllbnQgdG8gc2NhbGUgMCB0byBhdm9pZCBkb3VibGVcbiAgICAgICAgICAgICAqIHJvdW5kaW5nIGFuZCB0aGVuIHRyeSB0byBhZGp1c3QsIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNldFNjYWxlKDAsIFJvdW5kaW5nTW9kZS5ET1dOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIHJlc3VsdC5zY2FsZSgpID09IDA7XG4gICAgICAgIGxldCBwcmVjaXNpb25EaWZmO1xuICAgICAgICBpZiAoKHByZWZlcnJlZFNjYWxlID4gcmVzdWx0Ll9zY2FsZSkgJiZcbiAgICAgICAgICAgIChwcmVjaXNpb25EaWZmID0gbWMucHJlY2lzaW9uIC0gcmVzdWx0LnByZWNpc2lvbigpKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2V0U2NhbGUocmVzdWx0Ll9zY2FsZSArIE1hdGgubWluKHByZWNpc2lvbkRpZmYsIHByZWZlcnJlZFNjYWxlIC0gcmVzdWx0Ll9zY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuc3RyaXBaZXJvc1RvTWF0Y2hTY2FsZShyZXN1bHQuaW50VmFsLCByZXN1bHQuaW50Q29tcGFjdCwgcmVzdWx0Ll9zY2FsZSwgcHJlZmVycmVkU2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXMgYCh0aGlzICUgZGl2aXNvcilgLCB3aXRoIHJvdW5kaW5nIGFjY29yZGluZyB0byB0aGUgY29udGV4dCBzZXR0aW5ncy5cbiAgICAgKiBUaGUgYE1hdGhDb250ZXh0YCBzZXR0aW5ncyBhZmZlY3QgdGhlIGltcGxpY2l0IGRpdmlkZVxuICAgICAqIHVzZWQgdG8gY29tcHV0ZSB0aGUgcmVtYWluZGVyLiAgVGhlIHJlbWFpbmRlciBjb21wdXRhdGlvblxuICAgICAqIGl0c2VsZiBpcyBieSBkZWZpbml0aW9uIGV4YWN0LiAgVGhlcmVmb3JlLCB0aGUgcmVtYWluZGVyIG1heVxuICAgICAqIGNvbnRhaW4gbW9yZSB0aGFuIGBtYy5nZXRQcmVjaXNpb24oKWAgZGlnaXRzLlxuICAgICAqXG4gICAgICogVGhlIHJlbWFpbmRlciBpcyBnaXZlbiBieVxuICAgICAqIGB0aGlzLnN1YnRyYWN0KHRoaXMuZGl2aWRlVG9JbnRlZ3JhbFZhbHVlKGRpdmlzb3IsXG4gICAgICogbWMpLm11bHRpcGx5KGRpdmlzb3IpKWAuICBOb3RlIHRoYXQgdGhpcyBpcyBub3QgdGhlIG1vZHVsb1xuICAgICAqIG9wZXJhdGlvbiAodGhlIHJlc3VsdCBjYW4gYmUgbmVnYXRpdmUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpdmlzb3IgdmFsdWUgYnkgd2hpY2ggdGhpcyBgQmlnRGVjaW1hbGAgaXMgdG8gYmUgZGl2aWRlZC5cbiAgICAgKiBUaGlzIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYEJpZ0RlY2ltYWxgIGJlZm9yZSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIFNlZSB0aGUge0BsaW5rIEJpZyB8IGNvbnN0cnVjdG9yfSB0byBsZWFybiBtb3JlIGFib3V0IHRoZSBjb252ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBtYyB0aGUgY29udGV4dCB0byB1c2UuXG4gICAgICogQHJldHVybiBgdGhpcyAlIGRpdmlzb3JgLCByb3VuZGVkIGFzIG5lY2Vzc2FyeS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgZGl2aXNvciBpcyAwXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIHRoZSByZXN1bHQgaXMgaW5leGFjdCBidXQgdGhlXG4gICAgICogICAgICAgICByb3VuZGluZyBtb2RlIGlzIGBVTk5FQ0VTU0FSWWAsIG9yIGBtYy5wcmVjaXNpb25gXG4gICAgICogICAgICAgICA+IDAgYW5kIHRoZSByZXN1bHQgb2YgYHRoaXMuZGl2aWRlVG9JbnRlZ3JhbFZhbHVlKGRpdmlzb3IpYCB3b3VsZFxuICAgICAqICAgICAgICAgcmVxdWlyZSBhIHByZWNpc2lvbiBvZiBtb3JlIHRoYW4gYG1jLnByZWNpc2lvbmAgZGlnaXRzLlxuICAgICAqIEBzZWUgICAge0BsaW5rIGRpdmlkZVRvSW50ZWdyYWxWYWx1ZX1cbiAgICAgKi9cbiAgICByZW1haW5kZXIoZGl2aXNvciwgbWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlQW5kUmVtYWluZGVyKGRpdmlzb3IsIG1jKVsxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBvZiBjb21wYXJlVG8gdGhhdCBpZ25vcmVzIHNpZ24uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29tcGFyZU1hZ25pdHVkZSh2YWwpIHtcbiAgICAgICAgLy8gTWF0Y2ggc2NhbGVzLCBhdm9pZCB1bm5lY2Vzc2FyeSBpbmZsYXRpb25cbiAgICAgICAgbGV0IHlzID0gdmFsLmludENvbXBhY3Q7XG4gICAgICAgIGxldCB4cyA9IHRoaXMuaW50Q29tcGFjdDtcbiAgICAgICAgaWYgKHhzID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICh5cyA9PT0gMCkgPyAwIDogLTE7XG4gICAgICAgIGlmICh5cyA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjb25zdCBzZGlmZiA9IHRoaXMuX3NjYWxlIC0gdmFsLl9zY2FsZTtcbiAgICAgICAgaWYgKHNkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBtYXRjaGluZyBzY2FsZXMgaWYgdGhlIChhZGp1c3RlZCkgZXhwb25lbnRzIGRpZmZlclxuICAgICAgICAgICAgY29uc3QgeGFlID0gdGhpcy5wcmVjaXNpb24oKSAtIHRoaXMuX3NjYWxlOyAvLyBbLTFdXG4gICAgICAgICAgICBjb25zdCB5YWUgPSB2YWwucHJlY2lzaW9uKCkgLSB2YWwuX3NjYWxlOyAvLyBbLTFdXG4gICAgICAgICAgICBpZiAoeGFlIDwgeWFlKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmICh4YWUgPiB5YWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoc2RpZmYgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNhc2VzIHNkaWZmIDw9IEJpZ0RlY2ltYWwuTUlOX0lOVF9WQUxVRSBpbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICBpZiAoc2RpZmYgPiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiAmJlxuICAgICAgICAgICAgICAgICAgICAoeHMgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh4cyA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeHMsIC1zZGlmZikpID09PSBCaWdEZWNpbWFsLklORkxBVEVEKSAmJlxuICAgICAgICAgICAgICAgICAgICB5cyA9PT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYiA9IHRoaXMuYmlnTXVsdGlwbHlQb3dlclRlbigtc2RpZmYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5iaWdJbnRDb21wYXJlTWFnbml0dWRlKHJiLCB2YWwuaW50VmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gc2RpZmYgPiAwXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNhc2VzIHNkaWZmID4gSW50ZWdlci5NQVhfSU5UX1ZBTFVFIGludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoLlxuICAgICAgICAgICAgICAgIGlmIChzZGlmZiA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJlxuICAgICAgICAgICAgICAgICAgICAoeXMgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh5cyA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeXMsIHNkaWZmKSkgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpICYmXG4gICAgICAgICAgICAgICAgICAgIHhzID09PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJiID0gdmFsLmJpZ011bHRpcGx5UG93ZXJUZW4oc2RpZmYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5iaWdJbnRDb21wYXJlTWFnbml0dWRlKHRoaXMuaW50VmFsLCByYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4cyAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRClcbiAgICAgICAgICAgIHJldHVybiAoeXMgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpID8gQmlnRGVjaW1hbC5pbnRlZ2VyQ29tcGFyZU1hZ25pdHVkZSh4cywgeXMpIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKHlzICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmJpZ0ludENvbXBhcmVNYWduaXR1ZGUodGhpcy5pbnRWYWwsIHZhbC5pbnRWYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGlzIGBCaWdEZWNpbWFsYCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBvYmplY3QgZm9yIGVxdWFsaXR5LiAgVW5saWtlIHtAbGluayBjb21wYXJlVG99LFxuICAgICAqIHRoaXMgbWV0aG9kIGNvbnNpZGVycyB0d28gYEJpZ0RlY2ltYWxgXG4gICAgICogb2JqZWN0cyBlcXVhbCBvbmx5IGlmIHRoZXkgYXJlIGVxdWFsIGluIHZhbHVlIGFuZFxuICAgICAqIHNjYWxlLiBUaGVyZWZvcmUgMi4wIGlzIG5vdCBlcXVhbCB0byAyLjAwIHdoZW4gY29tcGFyZWQgYnkgdGhpc1xuICAgICAqIG1ldGhvZCBzaW5jZSB0aGUgZm9ybWVyIGhhcyBbYEJpZ0ludGAsIGBzY2FsZWBdXG4gICAgICogY29tcG9uZW50cyBlcXVhbCB0byBbMjAsIDFdIHdoaWxlIHRoZSBsYXR0ZXIgaGFzIGNvbXBvbmVudHNcbiAgICAgKiBlcXVhbCB0byBbMjAwLCAyXS5cbiAgICAgKlxuICAgICAqIE9uZSBleGFtcGxlIHRoYXQgc2hvd3MgaG93IDIuMCBhbmQgMi4wMCBhcmUgKipub3QqKlxuICAgICAqIHN1YnN0aXR1dGFibGUgZm9yIGVhY2ggb3RoZXIgdW5kZXIgc29tZSBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgICAgKiBhcmUgdGhlIHR3byBleHByZXNzaW9uczpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEJpZyhcIjIuMFwiICkuZGl2aWRlKEJpZygzKSwgdW5kZWZpbmVkLCBIQUxGX1VQKSAvLyB3aGljaCBldmFsdWF0ZXMgdG8gMC43XG4gICAgICpcbiAgICAgKiBCaWcoXCIyLjAwXCIpLmRpdmlkZShCaWcoMyksIHVuZGVmaW5lZCwgSEFMRl9VUCkgLy8gd2hpY2ggZXZhbHVhdGVzIHRvIDAuNjcuXG4gICAgICpgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB0byB3aGljaCB0aGlzIGBCaWdEZWNpbWFsYCBpc1xuICAgICAqICAgICAgICAgdG8gYmUgY29tcGFyZWQuXG4gICAgICogQHJldHVybiB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYVxuICAgICAqICAgICAgICAgQmlnRGVjaW1hbCB3aG9zZSB2YWx1ZSBhbmQgc2NhbGUgYXJlIGVxdWFsIHRvIHRoaXNcbiAgICAgKiAgICAgICAgIEJpZ0RlY2ltYWwncy5cbiAgICAgKiBAc2VlICAgIHtAbGluayBjb21wYXJlVG99XG4gICAgICovXG4gICAgZXF1YWxzKHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQmlnRGVjaW1hbCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IHZhbHVlLl9zY2FsZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuaW50Q29tcGFjdDtcbiAgICAgICAgbGV0IHhzID0gdmFsdWUuaW50Q29tcGFjdDtcbiAgICAgICAgaWYgKHMgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgIGlmICh4cyA9PT0gQmlnRGVjaW1hbC5JTkZMQVRFRClcbiAgICAgICAgICAgICAgICB4cyA9IEJpZ0RlY2ltYWwuY29tcGFjdFZhbEZvcih2YWx1ZS5pbnRWYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHhzID09PSBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhzICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKVxuICAgICAgICAgICAgcmV0dXJuIHhzID09PSBCaWdEZWNpbWFsLmNvbXBhY3RWYWxGb3IodGhpcy5pbnRWYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlZCgpID09PSB2YWx1ZS5pbmZsYXRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYEJpZ0RlY2ltYWxgIGFycmF5IGNvbnRhaW5pbmcgdGhlXG4gICAgICogcmVzdWx0IG9mIGBkaXZpZGVUb0ludGVncmFsVmFsdWVgIGZvbGxvd2VkIGJ5IHRoZSByZXN1bHQgb2ZcbiAgICAgKiBgcmVtYWluZGVyYCBvbiB0aGUgdHdvIG9wZXJhbmRzIGNhbGN1bGF0ZWQgd2l0aCByb3VuZGluZ1xuICAgICAqIGFjY29yZGluZyB0byB0aGUgY29udGV4dCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpZiBib3RoIHRoZSBxdW90aWVudCBhbmQgcmVtYWluZGVyIGFyZVxuICAgICAqIG5lZWRlZCwgdGhpcyBtZXRob2QgaXMgZmFzdGVyIHRoYW4gdXNpbmcgdGhlXG4gICAgICogYGRpdmlkZVRvSW50ZWdyYWxWYWx1ZWAgYW5kIGByZW1haW5kZXJgIG1ldGhvZHNcbiAgICAgKiBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIGRpdmlzaW9uIG5lZWQgb25seSBiZSBjYXJyaWVkIG91dCBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpdmlzb3IgdmFsdWUgYnkgd2hpY2ggdGhpcyBgQmlnRGVjaW1hbGAgaXMgdG8gYmUgZGl2aWRlZCxcbiAgICAgKiAgICAgICAgIGFuZCB0aGUgcmVtYWluZGVyIGNvbXB1dGVkLiBUaGlzIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIHRvIGFcbiAgICAgKiAgICAgICAgIGBCaWdEZWNpbWFsYCBiZWZvcmUgdGhlIG9wZXJhdGlvbi4gU2VlIHRoZVxuICAgICAqICAgICAgICAge0BsaW5rIEJpZyB8IGNvbnN0cnVjdG9yfSB0byBsZWFybiBtb3JlIGFib3V0IHRoZSBjb252ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBtYyB0aGUgY29udGV4dCB0byB1c2UuXG4gICAgICogQHJldHVybiBhIHR3byBlbGVtZW50IGBCaWdEZWNpbWFsYCBhcnJheTogdGhlIHF1b3RpZW50XG4gICAgICogICAgICAgICAodGhlIHJlc3VsdCBvZiBgZGl2aWRlVG9JbnRlZ3JhbFZhbHVlYCkgaXMgdGhlXG4gICAgICogICAgICAgICBpbml0aWFsIGVsZW1lbnQgYW5kIHRoZSByZW1haW5kZXIgaXMgdGhlIGZpbmFsIGVsZW1lbnQuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIGRpdmlzb3IgaXMgMFxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgcmVzdWx0IGlzIGluZXhhY3QgYnV0IHRoZVxuICAgICAqICAgICAgICAgcm91bmRpbmcgbW9kZSBpcyBgVU5ORUNFU1NBUllgLCBvciBgbWMucHJlY2lzaW9uID4gMGBcbiAgICAgKiAgICAgICAgIGFuZCB0aGUgcmVzdWx0IG9mIGB0aGlzLmRpdmlkZVRvSW50ZWdyYWxWYWx1ZShkaXZpc29yKWAgd291bGRcbiAgICAgKiAgICAgICAgIHJlcXVpcmUgYSBwcmVjaXNpb24gb2YgbW9yZSB0aGFuIGBtYy5wcmVjaXNpb25gIGRpZ2l0cy5cbiAgICAgKiBAc2VlICAgIHtAbGluayBkaXZpZGVUb0ludGVncmFsVmFsdWV9XG4gICAgICogQHNlZSAgICB7QGxpbmsgcmVtYWluZGVyfVxuICAgICAqL1xuICAgIGRpdmlkZUFuZFJlbWFpbmRlcihkaXZpc29yLCBtYykge1xuICAgICAgICBkaXZpc29yID0gQmlnRGVjaW1hbC5jb252ZXJ0VG9CaWdEZWNpbWFsKGRpdmlzb3IpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIHJlc3VsdFswXSA9IHRoaXMuZGl2aWRlVG9JbnRlZ3JhbFZhbHVlKGRpdmlzb3IsIG1jKTtcbiAgICAgICAgcmVzdWx0WzFdID0gdGhpcy5zdWJ0cmFjdChyZXN1bHRbMF0ubXVsdGlwbHkoZGl2aXNvcikpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFwcHJveGltYXRpb24gdG8gdGhlIHNxdWFyZSByb290IG9mIGB0aGlzYFxuICAgICAqIHdpdGggcm91bmRpbmcgYWNjb3JkaW5nIHRvIHRoZSBjb250ZXh0IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogVGhlIHByZWZlcnJlZCBzY2FsZSBvZiB0aGUgcmV0dXJuZWQgcmVzdWx0IGlzIGVxdWFsIHRvXG4gICAgICogYHRoaXMuc2NhbGUoKS8yYC4gVGhlIHZhbHVlIG9mIHRoZSByZXR1cm5lZCByZXN1bHQgaXNcbiAgICAgKiBhbHdheXMgd2l0aGluIG9uZSB1bHAgb2YgdGhlIGV4YWN0IGRlY2ltYWwgdmFsdWUgZm9yIHRoZVxuICAgICAqIHByZWNpc2lvbiBpbiBxdWVzdGlvbi4gIElmIHRoZSByb3VuZGluZyBtb2RlIGlzXG4gICAgICogIHtAbGluayBSb3VuZGluZ01vZGUuSEFMRl9VUH0sIHtAbGluayBSb3VuZGluZ01vZGUuSEFMRl9ET1dOfSxcbiAgICAgKiBvciB7QGxpbmsgUm91bmRpbmdNb2RlLkhBTEZfRVZFTn0sIHRoZVxuICAgICAqIHJlc3VsdCBpcyB3aXRoaW4gb25lIGhhbGYgYW4gdWxwIG9mIHRoZSBleGFjdCBkZWNpbWFsIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1jIHRoZSBjb250ZXh0IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHRoZSBzcXVhcmUgcm9vdCBvZiBgdGhpc2AuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIGB0aGlzYCBpcyBsZXNzIHRoYW4gemVyby5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYW4gZXhhY3QgcmVzdWx0IGlzIHJlcXVlc3RlZFxuICAgICAqIG1jLmdldFByZWNpc2lvbigpIGlzIDAgYW5kIHRoZXJlIGlzIG5vIGZpbml0ZSBkZWNpbWFsXG4gICAgICogZXhwYW5zaW9uIG9mIHRoZSBleGFjdCByZXN1bHRcbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgbWMuZ2V0Um91bmRpbmdNb2RlKCkgaXMgYFJvdW5kaW5nTW9kZS5VTk5FQ0VTU0FSWWAgYW5kXG4gICAgICogdGhlIGV4YWN0IHJlc3VsdCBjYW5ub3QgZml0IGluIGBtYy5nZXRQcmVjaXNpb24oKWBcbiAgICAgKiBkaWdpdHMuXG4gICAgICovXG4gICAgc3FydChtYykge1xuICAgICAgICBjb25zdCBzaWdudW0gPSB0aGlzLnNpZ251bSgpO1xuICAgICAgICBpZiAoc2lnbnVtICE9PSAxKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoc2lnbnVtKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHRlZCBzcXVhcmUgcm9vdCBvZiBuZWdhdGl2ZSBCaWdEZWNpbWFsJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMygwLCBNYXRoLnRydW5jKHRoaXMuX3NjYWxlIC8gMikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCYWQgdmFsdWUgZnJvbSBzaWdudW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZHJhd3Mgb24gdGhlIGFsZ29yaXRobSBwcmVzZW50ZWQgaW5cbiAgICAgICAgICAgICAqIFwiUHJvcGVybHkgUm91bmRlZCBWYXJpYWJsZSBQcmVjaXNpb24gU3F1YXJlIFJvb3QsXCIgSHVsbCBhbmRcbiAgICAgICAgICAgICAqIEFicmhhbSwgQUNNIFRyYW5zYWN0aW9ucyBvbiBNYXRoZW1hdGljYWwgU29mdHdhcmUsIFZvbCAxMSxcbiAgICAgICAgICAgICAqIE5vLiAzLCBTZXB0ZW1iZXIgMTk4NSwgUGFnZXMgMjI5LTIzNy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgQmlnRGVjaW1hbCBjb21wdXRhdGlvbmFsIG1vZGVsIGRpZmZlcnMgZnJvbSB0aGUgb25lXG4gICAgICAgICAgICAgKiBwcmVzZW50ZWQgaW4gdGhlIHBhcGVyIGluIHNldmVyYWwgd2F5czogZmlyc3QgQmlnRGVjaW1hbFxuICAgICAgICAgICAgICogbnVtYmVycyBhcmVuJ3QgbmVjZXNzYXJpbHkgbm9ybWFsaXplZCwgc2Vjb25kIG1hbnkgbW9yZVxuICAgICAgICAgICAgICogcm91bmRpbmcgbW9kZXMgYXJlIHN1cHBvcnRlZCwgaW5jbHVkaW5nIFVOTkVDRVNTQVJZLCBhbmRcbiAgICAgICAgICAgICAqIGV4YWN0IHJlc3VsdHMgY2FuIGJlIHJlcXVlc3RlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgbWFpbiBzdGVwcyBvZiB0aGUgYWxnb3JpdGhtIGJlbG93IGFyZSBhcyBmb2xsb3dzLFxuICAgICAgICAgICAgICogZmlyc3QgYXJndW1lbnQgcmVkdWNlIHRoZSB2YWx1ZSB0byB0aGUgbnVtZXJpY2FsIHJhbmdlXG4gICAgICAgICAgICAgKiBbMSwgMTApIHVzaW5nIHRoZSBmb2xsb3dpbmcgcmVsYXRpb25zOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHggPSB5ICogMTAgXiBleHBcbiAgICAgICAgICAgICAqIHNxcnQoeCkgPSBzcXJ0KHkpICogMTBeKGV4cCAvIDIpIGlmIGV4cCBpcyBldmVuXG4gICAgICAgICAgICAgKiBzcXJ0KHgpID0gc3FydCh5LzEwKSAqIDEwIF4oKGV4cCsxKS8yKSBpcyBleHAgaXMgb2RkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlbiB1c2UgTmV3dG9uJ3MgaXRlcmF0aW9uIG9uIHRoZSByZWR1Y2VkIHZhbHVlIHRvIGNvbXB1dGVcbiAgICAgICAgICAgICAqIHRoZSBudW1lcmljYWwgZGlnaXRzIG9mIHRoZSBkZXNpcmVkIHJlc3VsdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGaW5hbGx5LCBzY2FsZSBiYWNrIHRvIHRoZSBkZXNpcmVkIGV4cG9uZW50IHJhbmdlIGFuZFxuICAgICAgICAgICAgICogcGVyZm9ybSBhbnkgYWRqdXN0bWVudCB0byBnZXQgdGhlIHByZWZlcnJlZCBzY2FsZSBpbiB0aGVcbiAgICAgICAgICAgICAqIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUaGUgY29kZSBiZWxvdyBmYXZvcnMgcmVsYXRpdmUgc2ltcGxpY2l0eSBvdmVyIGNoZWNraW5nXG4gICAgICAgICAgICAvLyBmb3Igc3BlY2lhbCBjYXNlcyB0aGF0IGNvdWxkIHJ1biBmYXN0ZXIuXG4gICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRTY2FsZSA9IE1hdGgudHJ1bmModGhpcy5fc2NhbGUgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHplcm9XaXRoRmluYWxQcmVmZXJyZWRTY2FsZSA9IEJpZ0RlY2ltYWwuZnJvbUludGVnZXIzKDAsIHByZWZlcnJlZFNjYWxlKTtcbiAgICAgICAgICAgIC8vIEZpcnN0IHBoYXNlIG9mIG51bWVyaWNhbCBub3JtYWxpemF0aW9uLCBzdHJpcCB0cmFpbGluZ1xuICAgICAgICAgICAgLy8gemVyb3MgYW5kIGNoZWNrIGZvciBldmVuIHBvd2VycyBvZiAxMC5cbiAgICAgICAgICAgIGNvbnN0IHN0cmlwcGVkID0gdGhpcy5zdHJpcFRyYWlsaW5nWmVyb3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmlwcGVkU2NhbGUgPSBzdHJpcHBlZC5fc2NhbGU7XG4gICAgICAgICAgICAvLyBOdW1lcmljYWxseSBzcXJ0KDEwXjJOKSA9IDEwXk5cbiAgICAgICAgICAgIGlmIChzdHJpcHBlZC5pc1Bvd2VyT2ZUZW4oKSAmJiBzdHJpcHBlZFNjYWxlICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMygxLCBNYXRoLnRydW5jKHN0cmlwcGVkU2NhbGUgLyAyKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5fc2NhbGUgIT09IHByZWZlcnJlZFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkanVzdCB0byByZXF1ZXN0ZWQgcHJlY2lzaW9uIGFuZCBwcmVmZXJyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NhbGUgYXMgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoemVyb1dpdGhGaW5hbFByZWZlcnJlZFNjYWxlLCBtYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZnRlciBzdHJpcFRyYWlsaW5nWmVyb3MsIHRoZSByZXByZXNlbnRhdGlvbiBpcyBub3JtYWxpemVkIGFzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdW5zY2FsZWRWYWx1ZSAqIDEwXigtc2NhbGUpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gd2hlcmUgdW5zY2FsZWRWYWx1ZSBpcyBhbiBpbnRlZ2VyIHdpdGggdGhlIG1pbWltdW1cbiAgICAgICAgICAgIC8vIHByZWNpc2lvbiBmb3IgdGhlIGNvaG9ydCBvZiB0aGUgbnVtZXJpY2FsIHZhbHVlLiBUb1xuICAgICAgICAgICAgLy8gYWxsb3cgYmluYXJ5IGZsb2F0aW5nLXBvaW50IGhhcmR3YXJlIHRvIGJlIHVzZWQgdG8gZ2V0XG4gICAgICAgICAgICAvLyBhcHByb3hpbWF0ZWx5IGEgMTUgZGlnaXQgYXBwcm94aW1hdGlvbiB0byB0aGUgc3F1YXJlXG4gICAgICAgICAgICAvLyByb290LCBpdCBpcyBoZWxwZnVsIHRvIGluc3RlYWQgbm9ybWFsaXplIHRoaXMgc28gdGhhdFxuICAgICAgICAgICAgLy8gdGhlIHNpZ25pZmljYW5kIHBvcnRpb24gaXMgdG8gcmlnaHQgb2YgdGhlIGRlY2ltYWxcbiAgICAgICAgICAgIC8vIHBvaW50IGJ5IHJvdWdobHkgKHNjYWxlKCkgLSBwcmVjaXNpb24oKSArIDEpLlxuICAgICAgICAgICAgLy8gTm93IHRoZSBwcmVjaXNpb24gLyBzY2FsZSBhZGp1c3RtZW50XG4gICAgICAgICAgICBsZXQgc2NhbGVBZGp1c3Q7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHN0cmlwcGVkLl9zY2FsZSAtIHN0cmlwcGVkLnByZWNpc2lvbigpICsgMTtcbiAgICAgICAgICAgIGlmIChzY2FsZSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzY2FsZUFkanVzdCA9IHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbGVBZGp1c3QgPSBzY2FsZSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3b3JraW5nID0gc3RyaXBwZWQuc2NhbGVCeVBvd2VyT2ZUZW4oc2NhbGVBZGp1c3QpO1xuICAgICAgICAgICAgLy8gVXNlIGdvb2Qgb2xlJyBNYXRoLnNxcnQgdG8gZ2V0IHRoZSBpbml0aWFsIGd1ZXNzIGZvclxuICAgICAgICAgICAgLy8gdGhlIE5ld3RvbiBpdGVyYXRpb24sIGdvb2QgdG8gYXQgbGVhc3QgMTUgZGVjaW1hbFxuICAgICAgICAgICAgLy8gZGlnaXRzLiBUaGlzIGFwcHJvYWNoIGRvZXMgaW5jdXIgdGhlIGNvc3Qgb2YgYVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEJpZ0RlY2ltYWwgLT4gZG91YmxlIC0+IEJpZ0RlY2ltYWxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjb252ZXJzaW9uIGN5Y2xlLCBidXQgaXQgYXZvaWRzIHRoZSBuZWVkIGZvciBzZXZlcmFsXG4gICAgICAgICAgICAvLyBOZXd0b24gaXRlcmF0aW9ucyBpbiBCaWdEZWNpbWFsIGFyaXRobWV0aWMgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgLy8gd29ya2luZyBhbnN3ZXIgdG8gMTUgZGlnaXRzIG9mIHByZWNpc2lvbi4gSWYgbWFueSBmZXdlclxuICAgICAgICAgICAgLy8gdGhhbiAxNSBkaWdpdHMgd2VyZSBuZWVkZWQsIGl0IG1pZ2h0IGJlIGZhc3RlciB0byBkb1xuICAgICAgICAgICAgLy8gdGhlIGxvb3AgZW50aXJlbHkgaW4gQmlnRGVjaW1hbCBhcml0aG1ldGljLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIChBIGRvdWJsZSB2YWx1ZSBtaWdodCBoYXZlIGFzIG1hbnkgYXMgMTcgZGVjaW1hbFxuICAgICAgICAgICAgLy8gZGlnaXRzIG9mIHByZWNpc2lvbjsgaXQgZGVwZW5kcyBvbiB0aGUgcmVsYXRpdmUgZGVuc2l0eVxuICAgICAgICAgICAgLy8gb2YgYmluYXJ5IGFuZCBkZWNpbWFsIG51bWJlcnMgYXQgZGlmZmVyZW50IHJlZ2lvbnMgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBudW1iZXIgbGluZS4pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gKEl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIGNoZWNrIGZvciBjZXJ0YWluIHNwZWNpYWxcbiAgICAgICAgICAgIC8vIGNhc2VzIHRvIGF2b2lkIGRvaW5nIGFueSBOZXd0b24gaXRlcmF0aW9ucy4gRm9yXG4gICAgICAgICAgICAvLyBleGFtcGxlLCBpZiB0aGUgQmlnRGVjaW1hbCAtPiBkb3VibGUgY29udmVyc2lvbiB3YXNcbiAgICAgICAgICAgIC8vIGtub3duIHRvIGJlIGV4YWN0IGFuZCB0aGUgcm91bmRpbmcgbW9kZSBoYWQgYVxuICAgICAgICAgICAgLy8gbG93LWVub3VnaCBwcmVjaXNpb24sIHRoZSBwb3N0LU5ld3RvbiByb3VuZGluZyBsb2dpY1xuICAgICAgICAgICAgLy8gY291bGQgYmUgYXBwbGllZCBkaXJlY3RseS4pXG4gICAgICAgICAgICBjb25zdCBndWVzcyA9IEJpZ0RlY2ltYWwuZnJvbVZhbHVlKE1hdGguc3FydCh3b3JraW5nLm51bWJlclZhbHVlKCkpKTtcbiAgICAgICAgICAgIGxldCBndWVzc1ByZWNpc2lvbiA9IDE1O1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQcmVjaXNpb24gPSBtYy5wcmVjaXNpb247XG4gICAgICAgICAgICBsZXQgdGFyZ2V0UHJlY2lzaW9uO1xuICAgICAgICAgICAgLy8gSWYgYW4gZXhhY3QgdmFsdWUgaXMgcmVxdWVzdGVkLCBpdCBtdXN0IG9ubHkgbmVlZCBhYm91dFxuICAgICAgICAgICAgLy8gaGFsZiBvZiB0aGUgaW5wdXQgZGlnaXRzIHRvIHJlcHJlc2VudCBzaW5jZSBtdWx0aXBseWluZ1xuICAgICAgICAgICAgLy8gYW4gTiBkaWdpdCBudW1iZXIgYnkgaXRzZWxmIHlpZWxkIGEgMk4tMSBkaWdpdCBvciAyTlxuICAgICAgICAgICAgLy8gZGlnaXQgcmVzdWx0LlxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsUHJlY2lzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0UHJlY2lzaW9uID0gTWF0aC50cnVuYyhzdHJpcHBlZC5wcmVjaXNpb24oKSAvIDIpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogVG8gYXZvaWQgdGhlIG5lZWQgZm9yIHBvc3QtTmV3dG9uIGZpeC11cCBsb2dpYywgaW5cbiAgICAgICAgICAgICAgICAgKiB0aGUgY2FzZSBvZiBoYWxmLXdheSByb3VuZGluZyBtb2RlcywgZG91YmxlIHRoZVxuICAgICAgICAgICAgICAgICAqIHRhcmdldCBwcmVjaXNpb24gc28gdGhhdCB0aGUgXCIycCArIDJcIiBwcm9wZXJ0eSBjYW5cbiAgICAgICAgICAgICAgICAgKiBiZSByZWxpZWQgb24gdG8gYWNjb21wbGlzaCB0aGUgZmluYWwgcm91bmRpbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtYy5yb3VuZGluZ01vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3VuZGluZ01vZGUuSEFMRl9VUDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3VuZGluZ01vZGUuSEFMRl9ET1dOOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdW5kaW5nTW9kZS5IQUxGX0VWRU46XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVjaXNpb24gPSAyICogb3JpZ2luYWxQcmVjaXNpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0UHJlY2lzaW9uIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVjaXNpb24gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWNpc2lvbiA9IG9yaWdpbmFsUHJlY2lzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiBzZXR0aW5nIHRoZSBwcmVjaXNpb24gdG8gdXNlIGluc2lkZSB0aGUgTmV3dG9uXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24gbG9vcCwgdGFrZSBjYXJlIHRvIGF2b2lkIHRoZSBjYXNlIHdoZXJlIHRoZVxuICAgICAgICAgICAgLy8gcHJlY2lzaW9uIG9mIHRoZSBpbnB1dCBleGNlZWRzIHRoZSByZXF1ZXN0ZWQgcHJlY2lzaW9uXG4gICAgICAgICAgICAvLyBhbmQgcm91bmRpbmcgdGhlIGlucHV0IHZhbHVlIHRvbyBzb29uLlxuICAgICAgICAgICAgbGV0IGFwcHJveCA9IGd1ZXNzO1xuICAgICAgICAgICAgY29uc3Qgd29ya2luZ1ByZWNpc2lvbiA9IHdvcmtpbmcucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1wUHJlY2lzaW9uID0gTWF0aC5tYXgoTWF0aC5tYXgoZ3Vlc3NQcmVjaXNpb24sIHRhcmdldFByZWNpc2lvbiArIDIpLCB3b3JraW5nUHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtY1RtcCA9IG5ldyBNYXRoQ29udGV4dCh0bXBQcmVjaXNpb24sIFJvdW5kaW5nTW9kZS5IQUxGX0VWRU4pO1xuICAgICAgICAgICAgICAgIC8vIGFwcHJveCA9IDAuNSAqIChhcHByb3ggKyBmcmFjdGlvbiAvIGFwcHJveClcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBCaWdEZWNpbWFsLk9ORV9IQUxGLm11bHRpcGx5KGFwcHJveC5hZGQod29ya2luZy5kaXZpZGVXaXRoTWF0aENvbnRleHQoYXBwcm94LCBtY1RtcCksIG1jVG1wKSk7XG4gICAgICAgICAgICAgICAgZ3Vlc3NQcmVjaXNpb24gKj0gMjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGd1ZXNzUHJlY2lzaW9uIDwgdGFyZ2V0UHJlY2lzaW9uICsgMik7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Um0gPSBtYy5yb3VuZGluZ01vZGU7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Um0gPT09IFJvdW5kaW5nTW9kZS5VTk5FQ0VTU0FSWSB8fCBvcmlnaW5hbFByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcFJtID0gKHRhcmdldFJtID09PSBSb3VuZGluZ01vZGUuVU5ORUNFU1NBUlkpID8gUm91bmRpbmdNb2RlLkRPV04gOiB0YXJnZXRSbTtcbiAgICAgICAgICAgICAgICBjb25zdCBtY1RtcCA9IG5ldyBNYXRoQ29udGV4dCh0YXJnZXRQcmVjaXNpb24sIHRtcFJtKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcHByb3guc2NhbGVCeVBvd2VyT2ZUZW4oTWF0aC50cnVuYygtc2NhbGVBZGp1c3QgLyAyKSkucm91bmQobWNUbXApO1xuICAgICAgICAgICAgICAgIC8vIElmIHJlc3VsdCpyZXN1bHQgIT0gdGhpcyBudW1lcmljYWxseSwgdGhlIHNxdWFyZVxuICAgICAgICAgICAgICAgIC8vIHJvb3QgaXNuJ3QgZXhhY3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJ0cmFjdChyZXN1bHQuc3F1YXJlKCkpLmNvbXBhcmVUbyhCaWdEZWNpbWFsLlpFUk8pICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb21wdXRlZCBzcXVhcmUgcm9vdCBub3QgZXhhY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXBwcm94LnNjYWxlQnlQb3dlck9mVGVuKE1hdGgudHJ1bmMoLXNjYWxlQWRqdXN0IC8gMikpLnJvdW5kKG1jKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhcmdldFJtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm91bmRpbmdNb2RlLkRPV046XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm91bmRpbmdNb2RlLkZMT09SOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdG9vIGJpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zcXVhcmUoKS5jb21wYXJlVG8odGhpcykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVscCA9IHJlc3VsdC51bHAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgaW5jcmVtZW50IGRvd24gaW4gY2FzZSBvZiAxLjAgPSAxMF4wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIG5leHQgc21hbGxlciBudW1iZXIgaXMgb25seSAxLzEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgZmFyIHdheSBhcyB0aGUgbmV4dCBsYXJnZXIgYXQgZXhwb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib3VuZGFyaWVzLiBUZXN0IGFwcHJveCBhbmQgKm5vdCogcmVzdWx0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgaGF2aW5nIHRvIGRldGVjdCBhbiBhcmJpdHJhcnkgcG93ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0ZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwcHJveC5jb21wYXJlVG8oQmlnRGVjaW1hbC5PTkUpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVscCA9IHVscC5tdWx0aXBseShCaWdEZWNpbWFsLk9ORV9URU5USCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJ0cmFjdCh1bHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm91bmRpbmdNb2RlLlVQOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdW5kaW5nTW9kZS5DRUlMSU5HOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdG9vIHNtYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNxdWFyZSgpLmNvbXBhcmVUbyh0aGlzKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKHJlc3VsdC51bHAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFkZGl0aW9uYWwgd29yaywgcmVseSBvbiBcIjJwICsgMlwiIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY29ycmVjdCByb3VuZGluZy4gQWx0ZXJuYXRpdmVseSwgY291bGRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgcnVuIHRoZSBOZXd0b24gaXRlcmF0aW9uIHRvIGFyb3VuZCBwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWdpdHMgYW5kIHRoZW4gZG8gdGVzdHMgYW5kIGZpeC11cHMgb24gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByb3VuZGVkIHZhbHVlLiBPbmUgcG9zc2libGUgc2V0IG9mIHRlc3RzIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4LXVwcyBpcyBnaXZlbiBpbiB0aGUgSHVsbCBhbmQgQWJyaGFtIHBhcGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgYWRkaXRpb25hbCBoYWxmLXdheSBjYXNlcyBjYW4gb2NjdXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBCaWdEZWNpbWFsIGdpdmVuIHRoZSBtb3JlIHZhcmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tYmluYXRpb25zIG9mIGlucHV0IGFuZCBvdXRwdXQgcHJlY2lzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5fc2NhbGUgIT09IHByZWZlcnJlZFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByZWZlcnJlZCBzY2FsZSBvZiBhbiBhZGQgaXNcbiAgICAgICAgICAgICAgICAvLyBtYXgoYWRkZW5kLnNjYWxlKCksIGF1Z2VuZC5zY2FsZSgpKS4gVGhlcmVmb3JlLCBpZlxuICAgICAgICAgICAgICAgIC8vIHRoZSBzY2FsZSBvZiB0aGUgcmVzdWx0IGlzIGZpcnN0IG1pbmltaXplZCB1c2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwVHJhaWxpbmdaZXJvcygpLCBhZGRpbmcgYSB6ZXJvIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZWZlcnJlZCBzY2FsZSByb3VuZGluZyB0byB0aGUgY29ycmVjdCBwcmVjaXNpb25cbiAgICAgICAgICAgICAgICAvLyB3aWxsIHBlcmZvcm0gdGhlIHByb3BlciBzY2FsZSB2cyBwcmVjaXNpb25cbiAgICAgICAgICAgICAgICAvLyB0cmFkZW9mZnMuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN0cmlwVHJhaWxpbmdaZXJvcygpLmFkZCh6ZXJvV2l0aEZpbmFsUHJlZmVycmVkU2NhbGUsIG5ldyBNYXRoQ29udGV4dChvcmlnaW5hbFByZWNpc2lvbiwgUm91bmRpbmdNb2RlLlVOTkVDRVNTQVJZKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzcXVhcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIGFuIHVscCwgYSB1bml0IGluIHRoZSBsYXN0IHBsYWNlLCBvZiB0aGlzXG4gICAgICogYEJpZ0RlY2ltYWxgLiAgQW4gdWxwIG9mIGEgbm9uemVybyBgQmlnRGVjaW1hbGBcbiAgICAgKiB2YWx1ZSBpcyB0aGUgcG9zaXRpdmUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZhbHVlIGFuZCB0aGVcbiAgICAgKiBgQmlnRGVjaW1hbGAgdmFsdWUgbmV4dCBsYXJnZXIgaW4gbWFnbml0dWRlIHdpdGggdGhlXG4gICAgICogc2FtZSBudW1iZXIgb2YgZGlnaXRzLiAgQW4gdWxwIG9mIGEgemVybyB2YWx1ZSBpcyBudW1lcmljYWxseVxuICAgICAqIGVxdWFsIHRvIDEgd2l0aCB0aGUgc2NhbGUgb2YgYHRoaXNgLiAgVGhlIHJlc3VsdCBpc1xuICAgICAqIHN0b3JlZCB3aXRoIHRoZSBzYW1lIHNjYWxlIGFzIGB0aGlzYCBzbyB0aGUgcmVzdWx0XG4gICAgICogZm9yIHplcm8gYW5kIG5vbnplcm8gdmFsdWVzIGlzIGVxdWFsIHRvIGBbMSwgdGhpcy5zY2FsZSgpXWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSBzaXplIG9mIGFuIHVscCBvZiBgdGhpc2BcbiAgICAgKi9cbiAgICB1bHAoKSB7XG4gICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMigxLCB0aGlzLl9zY2FsZSwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2lnbnVtIG9mIGEgYmlnaW50LiBJZiBuZWdhdGl2ZSAtMSByZXR1cm5lZCwgaWYgcG9zaXRpdmUgMSByZXR1cm5lZCwgaWYgemVybyAwIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgYmlnSW50U2lnbnVtKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gQmlnRGVjaW1hbC56ZXJvQmlnSW50ID8gMSA6ICh2YWwgPCBCaWdEZWNpbWFsLnplcm9CaWdJbnQgPyAtMSA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJpZ0RlY2ltYWxgIHdoaWNoIGlzIG51bWVyaWNhbGx5IGVxdWFsIHRvXG4gICAgICogdGhpcyBvbmUgYnV0IHdpdGggYW55IHRyYWlsaW5nIHplcm9zIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgKiByZXByZXNlbnRhdGlvbi4gIEZvciBleGFtcGxlLCBzdHJpcHBpbmcgdGhlIHRyYWlsaW5nIHplcm9zIGZyb21cbiAgICAgKiB0aGUgYEJpZ0RlY2ltYWxgIHZhbHVlIGA2MDAuMGAsIHdoaWNoIGhhc1xuICAgICAqIFtgQmlnSW50YCwgYHNjYWxlYF0gY29tcG9uZW50cyBlcXVhbCB0b1xuICAgICAqIFs2MDAwbiwgMV0sIHlpZWxkcyBgNkUyYCB3aXRoIFtgQmlnSW50YCwgYHNjYWxlYF1cbiAgICAgKiBjb21wb25lbnRzIGVxdWFsIHRvIFs2biwgLTJdLlxuICAgICAqXG4gICAgICogQHJldHVybiBhIG51bWVyaWNhbGx5IGVxdWFsIGBCaWdEZWNpbWFsYCB3aXRoIGFueVxuICAgICAqIHRyYWlsaW5nIHplcm9zIHJlbW92ZWQuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIHNjYWxlIGZyb20gbWF4IG9yIG1pbiBzYWZlIGludGVnZXIgcmFuZ2UuXG4gICAgICovXG4gICAgc3RyaXBUcmFpbGluZ1plcm9zKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRDb21wYWN0ID09PSAwIHx8ICh0aGlzLmludFZhbCAhPT0gbnVsbCAmJiBCaWdEZWNpbWFsLmJpZ0ludFNpZ251bSh0aGlzLmludFZhbCkgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuY3JlYXRlQW5kU3RyaXBaZXJvc1RvTWF0Y2hTY2FsZSh0aGlzLmludENvbXBhY3QsIHRoaXMuX3NjYWxlLCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5jcmVhdGVBbmRTdHJpcFplcm9zVG9NYXRjaFNjYWxlMih0aGlzLmludFZhbCwgdGhpcy5fc2NhbGUsIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBgQmlnRGVjaW1hbGAgaXMgYSBwb3dlciBvZiB0ZW4obmVnYXRpdmUgb3IgcG9zaXRpdmUpLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGlzUG93ZXJPZlRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zY2FsZWRWYWx1ZSgpID09PSBCaWdEZWNpbWFsLm9uZUJpZ0ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCaWdJbnRgIHdob3NlIHZhbHVlIGlzIHRoZSA8aT51bnNjYWxlZFxuICAgICAqIHZhbHVlPC9pPiBvZiB0aGlzIGBCaWdEZWNpbWFsYC4gIChDb21wdXRlcyA8Y29kZT4odGhpcyAqXG4gICAgICogMTA8c3VwPnRoaXMuc2NhbGUoKTwvc3VwPik8L2NvZGU+LilcbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIHVuc2NhbGVkIHZhbHVlIG9mIHRoaXMgYEJpZ0RlY2ltYWxgLlxuICAgICAqL1xuICAgIHVuc2NhbGVkVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZmxhdGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIDxpPnNjYWxlPC9pPiBvZiB0aGlzIGBCaWdEZWNpbWFsYC4gIElmIHplcm9cbiAgICAgKiBvciBwb3NpdGl2ZSwgdGhlIHNjYWxlIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIHRoZSByaWdodCBvZlxuICAgICAqIHRoZSBkZWNpbWFsIHBvaW50LiAgSWYgbmVnYXRpdmUsIHRoZSB1bnNjYWxlZCB2YWx1ZSBvZiB0aGVcbiAgICAgKiBudW1iZXIgaXMgbXVsdGlwbGllZCBieSB0ZW4gdG8gdGhlIHBvd2VyIG9mIHRoZSBuZWdhdGlvbiBvZiB0aGVcbiAgICAgKiBzY2FsZS4gIEZvciBleGFtcGxlLCBhIHNjYWxlIG9mIGAtM2AgbWVhbnMgdGhlIHVuc2NhbGVkXG4gICAgICogdmFsdWUgaXMgbXVsdGlwbGllZCBieSAxMDAwLlxuICAgICAqXG4gICAgICogVGhlIHNjYWxlIHdpbGwgYmUga2VwdCBpbiB0aGUgaW50ZWdlciByYW5nZSwgaWYgY2Fubm90IGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGUgc2NhbGUgb2YgdGhpcyBgQmlnRGVjaW1hbGAuXG4gICAgICovXG4gICAgc2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJpZ0RlY2ltYWwgd2hvc2UgbnVtZXJpY2FsIHZhbHVlIGlzIGVxdWFsIHRvXG4gICAgICogKGB0aGlzYCAqIDEwPHN1cD5uPC9zdXA+KS4gIFRoZSBzY2FsZSBvZlxuICAgICAqIHRoZSByZXN1bHQgaXMgYCh0aGlzLnNjYWxlKCkgLSBuKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbiB0aGUgZXhwb25lbnQgcG93ZXIgb2YgdGVuIHRvIHNjYWxlIGJ5XG4gICAgICogQHJldHVybiBhIEJpZ0RlY2ltYWwgd2hvc2UgbnVtZXJpY2FsIHZhbHVlIGlzIGVxdWFsIHRvXG4gICAgICogKGB0aGlzYCAqIDEwPHN1cD5uPC9zdXA+KVxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgc2NhbGUgd291bGQgYmUgb3V0c2lkZSB0aGUgcmFuZ2Ugb2YgYSBzYWZlIGludGVnZXIuXG4gICAgICovXG4gICAgc2NhbGVCeVBvd2VyT2ZUZW4obikge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwodGhpcy5pbnRWYWwsIHRoaXMuaW50Q29tcGFjdCwgdGhpcy5jaGVja1NjYWxlKHRoaXMuX3NjYWxlIC0gbiksIHRoaXMuX3ByZWNpc2lvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoaXMgYEJpZ0RlY2ltYWxgIG51bWVyaWNhbGx5IHdpdGggdGhlIHNwZWNpZmllZFxuICAgICAqIGBCaWdEZWNpbWFsYC4gIFR3byBgQmlnRGVjaW1hbGAgb2JqZWN0cyB0aGF0IGFyZVxuICAgICAqIGVxdWFsIGluIHZhbHVlIGJ1dCBoYXZlIGEgZGlmZmVyZW50IHNjYWxlIChsaWtlIDIuMCBhbmQgMi4wMClcbiAgICAgKiBhcmUgY29uc2lkZXJlZCBlcXVhbCBieSB0aGlzIG1ldGhvZC4gU3VjaCB2YWx1ZXMgYXJlIGluIHRoZVxuICAgICAqIHNhbWUgPGk+Y29ob3J0PC9pPi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGluIHByZWZlcmVuY2UgdG8gaW5kaXZpZHVhbCBtZXRob2RzIGZvclxuICAgICAqIGVhY2ggb2YgdGhlIHNpeCBib29sZWFuIGNvbXBhcmlzb24gb3BlcmF0b3JzIChgPGAsIGA9PWAsXG4gICAgICogYD5gLCBgPj1gLCBgIT1gLCBgPD1gKS4gIFRoZSBzdWdnZXN0ZWRcbiAgICAgKiBpZGlvbSBmb3IgcGVyZm9ybWluZyB0aGVzZSBjb21wYXJpc29ucyBpczpcbiAgICAgKiAoeC5jb21wYXJlVG8oeSkgJmx0OzxpPm9wPC9pPiZndDsgMCksIHdoZXJlXG4gICAgICogJmx0OzxpPm9wPC9pPiZndDsgaXMgb25lIG9mIHRoZSBzaXggY29tcGFyaXNvbiBvcGVyYXRvcnMuXG5cbiAgICAgKiBAcGFyYW0gdmFsIHZhbHVlIHRvIHdoaWNoIHRoaXMgYEJpZ0RlY2ltYWxgIGlzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqIFRoaXMgdmFsdWUgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQmlnRGVjaW1hbGAgYmVmb3JlIHRoZSBvcGVyYXRpb24uXG4gICAgICogU2VlIHRoZSB7QGxpbmsgQmlnIHwgY29uc3RydWN0b3J9IHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIGNvbnZlcnNpb24uXG4gICAgICogQHJldHVybiAtMSwgMCwgb3IgMSBhcyB0aGlzIGBCaWdEZWNpbWFsYCBpcyBudW1lcmljYWxseVxuICAgICAqICAgICAgICAgIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiBgdmFsYC5cbiAgICAgKiBAc2VlIHtAbGluayBzYW1lVmFsdWV9XG4gICAgICogQHNlZSB7QGxpbmsgZ3JlYXRlclRoYW59XG4gICAgICogQHNlZSB7QGxpbmsgZ3JlYXRlclRoYW5PckVxdWFsc31cbiAgICAgKiBAc2VlIHtAbGluayBsb3dlclRoYW59XG4gICAgICogQHNlZSB7QGxpbmsgbG93ZXJUaGFuT3JFcXVhbHN9XG4gICAgICovXG4gICAgY29tcGFyZVRvKHZhbCkge1xuICAgICAgICB2YWwgPSBCaWdEZWNpbWFsLmNvbnZlcnRUb0JpZ0RlY2ltYWwodmFsKTtcbiAgICAgICAgLy8gUXVpY2sgcGF0aCBmb3IgZXF1YWwgc2NhbGUgYW5kIG5vbi1pbmZsYXRlZCBjYXNlLlxuICAgICAgICBpZiAodGhpcy5fc2NhbGUgPT09IHZhbC5fc2NhbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHhzID0gdGhpcy5pbnRDb21wYWN0O1xuICAgICAgICAgICAgY29uc3QgeXMgPSB2YWwuaW50Q29tcGFjdDtcbiAgICAgICAgICAgIGlmICh4cyAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCAmJiB5cyAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4cyAhPT0geXMgPyAoeHMgPiB5cyA/IDEgOiAtMSkgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHhzaWduID0gdGhpcy5zaWdudW0oKTtcbiAgICAgICAgY29uc3QgeXNpZ24gPSB2YWwuc2lnbnVtKCk7XG4gICAgICAgIGlmICh4c2lnbiAhPT0geXNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiB4c2lnbiA+IHlzaWduID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhzaWduID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyZU1hZ25pdHVkZSh2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHhzaWduID4gMCA/IGNtcCA6IC1jbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBBbGlhcyBmb3IgYGNvbXBhcmVUbyh2YWwpID09PSAwYC5cbiAgICAqIENvbnNpZGVyIHVzaW5nIHtAbGluayBlcXVhbHN9IGluIGNhc2UgdGhlIHNjYWxlIG5lZWRzIHRvIGJlIGNvbnNpZGVyZWQuXG4gICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyBgdmFsYFxuICAgICogQHNlZSB7QGxpbmsgZXF1YWxzfVxuICAgICogQHNlZSB7QGxpbmsgY29tcGFyZVRvfVxuICAgICovXG4gICAgc2FtZVZhbHVlKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8odmFsKSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGBjb21wYXJlVG8odmFsKSA+IDBgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbCB2YWx1ZSB0byB3aGljaCB0aGlzIGBCaWdEZWNpbWFsYCBpcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKiBUaGlzIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYEJpZ0RlY2ltYWxgIGJlZm9yZSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIFNlZSB0aGUge0BsaW5rIEJpZyB8IGNvbnN0cnVjdG9yfSB0byBsZWFybiBtb3JlIGFib3V0IHRoZSBjb252ZXJzaW9uLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBgdmFsYFxuICAgICAqIEBzZWUgICAgIHtAbGluayBjb21wYXJlVG99XG4gICAgICogQGFsaWFzICAge0BsaW5rIGd0fVxuICAgICAqL1xuICAgIGdyZWF0ZXJUaGFuKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8odmFsKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhbGlhcyB7QGxpbmsgZ3JlYXRlclRoYW59XG4gICAgICovXG4gICAgZ3QodmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyZWF0ZXJUaGFuKHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBgY29tcGFyZVRvKHZhbCkgPj0gMGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIHZhbHVlIHRvIHdoaWNoIHRoaXMgYEJpZ0RlY2ltYWxgIGlzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqIFRoaXMgdmFsdWUgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQmlnRGVjaW1hbGAgYmVmb3JlIHRoZSBvcGVyYXRpb24uXG4gICAgICogU2VlIHRoZSB7QGxpbmsgQmlnIHwgY29uc3RydWN0b3J9IHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIGNvbnZlcnNpb24uXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFscyB0byBgdmFsYFxuICAgICAqIEBzZWUgICAgIHtAbGluayBjb21wYXJlVG99XG4gICAgICogQGFsaWFzICAge0BsaW5rIGd0ZX1cbiAgICAgKi9cbiAgICBncmVhdGVyVGhhbk9yRXF1YWxzKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8odmFsKSA+PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWxpYXMge0BsaW5rIGdyZWF0ZXJUaGFuT3JFcXVhbHN9XG4gICAgICovXG4gICAgZ3RlKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbk9yRXF1YWxzKHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBgY29tcGFyZVRvKHZhbCkgPCAwYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWwgdmFsdWUgdG8gd2hpY2ggdGhpcyBgQmlnRGVjaW1hbGAgaXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICogVGhpcyB2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBCaWdEZWNpbWFsYCBiZWZvcmUgdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBTZWUgdGhlIHtAbGluayBCaWcgfCBjb25zdHJ1Y3Rvcn0gdG8gbGVhcm4gbW9yZSBhYm91dCB0aGUgY29udmVyc2lvbi5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBsb3dlciB0aGFuIGB2YWxgXG4gICAgICogQHNlZSAgICAge0BsaW5rIGNvbXBhcmVUb31cbiAgICAgKiBAYWxpYXMgICB7QGxpbmsgbHR9XG4gICAgICovXG4gICAgbG93ZXJUaGFuKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8odmFsKSA8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhbGlhcyB7QGxpbmsgbG93ZXJUaGFufVxuICAgICAqL1xuICAgIGx0KHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3dlclRoYW4odmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGBjb21wYXJlVG8odmFsKSA8PSAwYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWwgdmFsdWUgdG8gd2hpY2ggdGhpcyBgQmlnRGVjaW1hbGAgaXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICogVGhpcyB2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBCaWdEZWNpbWFsYCBiZWZvcmUgdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBTZWUgdGhlIHtAbGluayBCaWcgfCBjb25zdHJ1Y3Rvcn0gdG8gbGVhcm4gbW9yZSBhYm91dCB0aGUgY29udmVyc2lvbi5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBsb3dlciB0aGFuIG9yIGVxdWFscyB0byBgdmFsYFxuICAgICAqIEBzZWUgICAgIHtAbGluayBjb21wYXJlVG99XG4gICAgICogQGFsaWFzICAge0BsaW5rIGx0ZX1cbiAgICAgKi9cbiAgICBsb3dlclRoYW5PckVxdWFscyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKHZhbCkgPD0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFsaWFzIHtAbGluayBsb3dlclRoYW5PckVxdWFsc31cbiAgICAgKi9cbiAgICBsdGUodmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvd2VyVGhhbk9yRXF1YWxzKHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgQmlnRGVjaW1hbCB0byBudW1iZXIuXG4gICAgICogQHJldHVybiBudW1iZXIgZm9yIG9mIHRoaXMgQmlnRGVjaW1hbFxuICAgICAqL1xuICAgIG51bWJlclZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRDb21wYWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRDb21wYWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBJZiBib3RoIGludENvbXBhY3QgYW5kIHRoZSBzY2FsZSBjYW4gYmUgZXhhY3RseVxuICAgICAgICAgICAgICAgICAqIHJlcHJlc2VudGVkIGFzIGRvdWJsZSB2YWx1ZXMsIHBlcmZvcm0gYSBzaW5nbGVcbiAgICAgICAgICAgICAgICAgKiBkb3VibGUgbXVsdGlwbHkgb3IgZGl2aWRlIHRvIGNvbXB1dGUgdGhlIChwcm9wZXJseVxuICAgICAgICAgICAgICAgICAqIHJvdW5kZWQpIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5pbnRDb21wYWN0KSA8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGhhdmUgdG9vIGd1YXJkIGFnYWluc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0aC5hYnMoTUlOX1ZBTFVFKSBiZWNhdXNlIG9mIG91dGVyIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIGFnYWluc3QgSU5GTEFURUQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSA+IDAgJiYgdGhpcy5fc2NhbGUgPD0gQmlnRGVjaW1hbC5NQVhfQ09NUEFDVF9ESUdJVFMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludENvbXBhY3QgLyBCaWdEZWNpbWFsLk5VTUJFUl8xMF9QT1dbdGhpcy5fc2NhbGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3NjYWxlIDwgMCAmJiB0aGlzLl9zY2FsZSA+PSAtQmlnRGVjaW1hbC5NQVhfQ09NUEFDVF9ESUdJVFMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludENvbXBhY3QgKiBCaWdEZWNpbWFsLk5VTUJFUl8xMF9QT1dbLXRoaXMuX3NjYWxlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTb21ld2hhdCBpbmVmZmljaWVudCwgYnV0IGd1YXJhbnRlZWQgdG8gd29yay5cbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJpZ0RlY2ltYWxgIHJvdW5kZWQgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIGBNYXRoQ29udGV4dGAgc2V0dGluZ3MuICBJZiB0aGUgcHJlY2lzaW9uIHNldHRpbmcgaXMgMCB0aGVuXG4gICAgICogbm8gcm91bmRpbmcgdGFrZXMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBUaGUgZWZmZWN0IG9mIHRoaXMgbWV0aG9kIGlzIGlkZW50aWNhbCB0byB0aGF0IG9mIHRoZVxuICAgICAqIHtAbGluayBwbHVzfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWMgdGhlIGNvbnRleHQgdG8gdXNlLlxuICAgICAqIEByZXR1cm4gYSBgQmlnRGVjaW1hbGAgcm91bmRlZCBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICogICAgICAgICBgTWF0aENvbnRleHRgIHNldHRpbmdzLlxuICAgICAqIEBzZWUgICAge0BsaW5rIHBsdXN9XG4gICAgICovXG4gICAgcm91bmQobWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1cyhtYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQmlnRGVjaW1hbGAgd2hvc2Ugc2NhbGUgaXMgdGhlIHNwZWNpZmllZFxuICAgICAqIHZhbHVlLCBhbmQgd2hvc2UgdW5zY2FsZWQgdmFsdWUgaXMgZGV0ZXJtaW5lZCBieSBtdWx0aXBseWluZyBvclxuICAgICAqIGRpdmlkaW5nIHRoaXMgYEJpZ0RlY2ltYWxgJ3MgdW5zY2FsZWQgdmFsdWUgYnkgdGhlXG4gICAgICogYXBwcm9wcmlhdGUgcG93ZXIgb2YgdGVuIHRvIG1haW50YWluIGl0cyBvdmVyYWxsIHZhbHVlLiAgSWYgdGhlXG4gICAgICogc2NhbGUgaXMgcmVkdWNlZCBieSB0aGUgb3BlcmF0aW9uLCB0aGUgdW5zY2FsZWQgdmFsdWUgbXVzdCBiZVxuICAgICAqIGRpdmlkZWQgKHJhdGhlciB0aGFuIG11bHRpcGxpZWQpLCBhbmQgdGhlIHZhbHVlIG1heSBiZSBjaGFuZ2VkO1xuICAgICAqIGluIHRoaXMgY2FzZSwgdGhlIHNwZWNpZmllZCByb3VuZGluZyBtb2RlIGlzIGFwcGxpZWQgdG8gdGhlXG4gICAgICogZGl2aXNpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdTY2FsZSBzY2FsZSBvZiB0aGUgYEJpZ0RlY2ltYWxgIHZhbHVlIHRvIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSByb3VuZGluZ01vZGUgVGhlIHJvdW5kaW5nIG1vZGUgdG8gYXBwbHkuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGBVTk5FQ0VTU0FSWWAuXG4gICAgICogQHJldHVybiBhIGBCaWdEZWNpbWFsYCB3aG9zZSBzY2FsZSBpcyB0aGUgc3BlY2lmaWVkIHZhbHVlLFxuICAgICAqICAgICAgICAgYW5kIHdob3NlIHVuc2NhbGVkIHZhbHVlIGlzIGRldGVybWluZWQgYnkgbXVsdGlwbHlpbmcgb3JcbiAgICAgKiAgICAgICAgIGRpdmlkaW5nIHRoaXMgYEJpZ0RlY2ltYWxgJ3MgdW5zY2FsZWQgdmFsdWUgYnkgdGhlXG4gICAgICogICAgICAgICBhcHByb3ByaWF0ZSBwb3dlciBvZiB0ZW4gdG8gbWFpbnRhaW4gaXRzIG92ZXJhbGwgdmFsdWUuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIHJvdW5kaW5nTW9kZSBpcyBgVU5ORUNFU1NBUllgXG4gICAgICogICAgICAgICBhbmQgdGhlIHNwZWNpZmllZCBzY2FsaW5nIG9wZXJhdGlvbiB3b3VsZCByZXF1aXJlXG4gICAgICogICAgICAgICByb3VuZGluZy5cbiAgICAgKiBAc2VlIHtAbGluayBSb3VuZGluZ01vZGV9XG4gICAgICovXG4gICAgc2V0U2NhbGUobmV3U2NhbGUsIHJvdW5kaW5nTW9kZSA9IFJvdW5kaW5nTW9kZS5VTk5FQ0VTU0FSWSkge1xuICAgICAgICBpZiAocm91bmRpbmdNb2RlIDwgUm91bmRpbmdNb2RlLlVQIHx8IHJvdW5kaW5nTW9kZSA+IFJvdW5kaW5nTW9kZS5VTk5FQ0VTU0FSWSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHJvdW5kaW5nIG1vZGUnKTtcbiAgICAgICAgY29uc3Qgb2xkU2NhbGUgPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgaWYgKG5ld1NjYWxlID09PSBvbGRTY2FsZSkgLy8gZWFzeSBjYXNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT09IDApIC8vIHplcm8gY2FuIGhhdmUgYW55IHNjYWxlXG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC56ZXJvVmFsdWVPZihuZXdTY2FsZSk7XG4gICAgICAgIGlmICh0aGlzLmludENvbXBhY3QgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgIGxldCBycyA9IHRoaXMuaW50Q29tcGFjdDtcbiAgICAgICAgICAgIGlmIChuZXdTY2FsZSA+IG9sZFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFpc2UgPSB0aGlzLmNoZWNrU2NhbGUobmV3U2NhbGUgLSBvbGRTY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKChycyA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4ocnMsIHJhaXNlKSkgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUludGVnZXIzKHJzLCBuZXdTY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJiID0gdGhpcy5iaWdNdWx0aXBseVBvd2VyVGVuKHJhaXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwocmIsIEJpZ0RlY2ltYWwuSU5GTEFURUQsIG5ld1NjYWxlLCAodGhpcy5fcHJlY2lzaW9uID4gMCkgPyB0aGlzLl9wcmVjaXNpb24gKyByYWlzZSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3U2NhbGUgPCBvbGRTY2FsZSAtLSBkcm9wIHNvbWUgZGlnaXRzXG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgcHJlZGljdCB0aGUgcHJlY2lzaW9uIGR1ZSB0byB0aGUgZWZmZWN0IG9mIHJvdW5kaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IGRyb3AgPSB0aGlzLmNoZWNrU2NhbGUob2xkU2NhbGUgLSBuZXdTY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRyb3AgPCBCaWdEZWNpbWFsLlRFTl9QT1dFUlNfVEFCTEUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMihycywgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFW2Ryb3BdLCBuZXdTY2FsZSwgcm91bmRpbmdNb2RlLCBuZXdTY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDModGhpcy5pbmZsYXRlZCgpLCBCaWdJbnQoMTApICoqIEJpZ0ludChkcm9wKSwgbmV3U2NhbGUsIHJvdW5kaW5nTW9kZSwgbmV3U2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdTY2FsZSA+IG9sZFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFpc2UgPSB0aGlzLmNoZWNrU2NhbGUobmV3U2NhbGUgLSBvbGRTY2FsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmIgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4zKHRoaXMuaW50VmFsLCByYWlzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKHJiLCBCaWdEZWNpbWFsLklORkxBVEVELCBuZXdTY2FsZSwgKHRoaXMuX3ByZWNpc2lvbiA+IDApID8gdGhpcy5fcHJlY2lzaW9uICsgcmFpc2UgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5ld1NjYWxlIDwgb2xkU2NhbGUgLS0gZHJvcCBzb21lIGRpZ2l0c1xuICAgICAgICAgICAgICAgIC8vIENhbid0IHByZWRpY3QgdGhlIHByZWNpc2lvbiBkdWUgdG8gdGhlIGVmZmVjdCBvZiByb3VuZGluZy5cbiAgICAgICAgICAgICAgICBjb25zdCBkcm9wID0gdGhpcy5jaGVja1NjYWxlKG9sZFNjYWxlIC0gbmV3U2NhbGUpO1xuICAgICAgICAgICAgICAgIGlmIChkcm9wIDwgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQ0KHRoaXMuaW50VmFsLCBCaWdEZWNpbWFsLlRFTl9QT1dFUlNfVEFCTEVbZHJvcF0sIG5ld1NjYWxlLCByb3VuZGluZ01vZGUsIG5ld1NjYWxlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMyh0aGlzLmludFZhbCwgQmlnSW50KDEwKSAqKiBCaWdJbnQoZHJvcCksIG5ld1NjYWxlLCByb3VuZGluZ01vZGUsIG5ld1NjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJpZ0RlY2ltYWxgIHdob3NlIHZhbHVlIGlzIGAoK3RoaXMpYCxcbiAgICAgKiB3aXRoIHJvdW5kaW5nIGFjY29yZGluZyB0byB0aGUgY29udGV4dCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIFRoZSBlZmZlY3Qgb2YgdGhpcyBtZXRob2QgaXMgaWRlbnRpY2FsIHRvIHRoYXQgb2YgdGhlIHtAbGluayByb3VuZH0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1jIHRoZSBjb250ZXh0IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIGB0aGlzYCwgcm91bmRlZCBhcyBuZWNlc3NhcnkuICBBIHplcm8gcmVzdWx0IHdpbGxcbiAgICAgKiAgICAgICAgIGhhdmUgYSBzY2FsZSBvZiAwLlxuICAgICAqIEBzZWUgICAge0BsaW5rIHJvdW5kfVxuICAgICAqL1xuICAgIHBsdXMobWMpIHtcbiAgICAgICAgaWYgKCFtYylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobWMucHJlY2lzaW9uID09PSAwKSAvLyBubyByb3VuZGluZyBwbGVhc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kb1JvdW5kKHRoaXMsIG1jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCaWdEZWNpbWFsYCB3aG9zZSB2YWx1ZSBpc1xuICAgICAqIDxjb2RlPih0aGlzPHN1cD5uPC9zdXA+KTwvY29kZT4uICBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiB1c2VzXG4gICAgICogdGhlIGNvcmUgYWxnb3JpdGhtIGRlZmluZWQgaW4gQU5TSSBzdGFuZGFyZCBYMy4yNzQtMTk5NiB3aXRoXG4gICAgICogcm91bmRpbmcgYWNjb3JkaW5nIHRvIHRoZSBjb250ZXh0IHNldHRpbmdzLiAgSW4gZ2VuZXJhbCwgdGhlXG4gICAgICogcmV0dXJuZWQgbnVtZXJpY2FsIHZhbHVlIGlzIHdpdGhpbiB0d28gdWxwcyBvZiB0aGUgZXhhY3RcbiAgICAgKiBudW1lcmljYWwgdmFsdWUgZm9yIHRoZSBjaG9zZW4gcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogVGhlIFgzLjI3NC0xOTk2IGFsZ29yaXRobSBpczpcbiAgICAgKlxuICAgICAqICogQW4gYFJhbmdlRXJyb3JgIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWZcbiAgICAgKiAgICAgKiBgYWJzKG4pYCA+IDk5OTk5OTk5OVxuICAgICAqICAgICAqIGBtYy5wcmVjaXNpb24gPT0gMGAgYW5kIGBuIDwgMGBcbiAgICAgKiAgICAgKiBgbWMucHJlY2lzaW9uID4gMGAgYW5kIGBuYCBoYXMgbW9yZSB0aGFuXG4gICAgICogICAgYG1jLnByZWNpc2lvbmAgZGVjaW1hbCBkaWdpdHNcbiAgICAgKlxuICAgICAqICogaWYgYG5gIGlzIHplcm8sIGEgQmlnRGVjaW1hbCB3aXRoIHZhbHVlIDEgaXMgcmV0dXJuZWQgZXZlbiBpZlxuICAgICAqIGB0aGlzYCBpcyB6ZXJvLCBvdGhlcndpc2VcblxuICAgICAqICAgICAqIGlmIGBuYCBpcyBwb3NpdGl2ZSwgdGhlIHJlc3VsdCBpcyBjYWxjdWxhdGVkIHZpYVxuICAgICAqICAgdGhlIHJlcGVhdGVkIHNxdWFyaW5nIHRlY2huaXF1ZSBpbnRvIGEgc2luZ2xlIGFjY3VtdWxhdG9yLlxuICAgICAqICAgVGhlIGluZGl2aWR1YWwgbXVsdGlwbGljYXRpb25zIHdpdGggdGhlIGFjY3VtdWxhdG9yIHVzZSB0aGVcbiAgICAgKiAgIHNhbWUgbWF0aCBjb250ZXh0IHNldHRpbmdzIGFzIGluIGBtY2AgZXhjZXB0IGZvciBhXG4gICAgICogICBwcmVjaXNpb24gaW5jcmVhc2VkIHRvIGBtYy5wcmVjaXNpb24gKyBlbGVuZ3RoICsgMWBcbiAgICAgKiAgIHdoZXJlIGBlbGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzIGluXG4gICAgICogICBgbmAuXG4gICAgICpcbiAgICAgKiAgICAgKiBpZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSByZXN1bHQgaXMgY2FsY3VsYXRlZCBhcyBpZlxuICAgICAqICAgYG5gIHdlcmUgcG9zaXRpdmU7IHRoaXMgdmFsdWUgaXMgdGhlbiBkaXZpZGVkIGludG8gb25lXG4gICAgICogICB1c2luZyB0aGUgd29ya2luZyBwcmVjaXNpb24gc3BlY2lmaWVkIGFib3ZlLlxuICAgICAqXG4gICAgICogICAgICogVGhlIGZpbmFsIHZhbHVlIGZyb20gZWl0aGVyIHRoZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBjYXNlXG4gICAgICogICBpcyB0aGVuIHJvdW5kZWQgdG8gdGhlIGRlc3RpbmF0aW9uIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuIHBvd2VyIHRvIHJhaXNlIHRoaXMgYEJpZ0RlY2ltYWxgIHRvLlxuICAgICAqIEBwYXJhbSBtYyB0aGUgY29udGV4dCB0byB1c2UuXG4gICAgICogQHJldHVybiA8Y29kZT50aGlzPHN1cD5uPC9zdXA+PC9jb2RlPiB1c2luZyB0aGUgQU5TSSBzdGFuZGFyZCBYMy4yNzQtMTk5NlxuICAgICAqICAgICAgICAgYWxnb3JpdGhtXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIHRoZSByZXN1bHQgaXMgaW5leGFjdCBidXQgdGhlXG4gICAgICogICAgICAgICByb3VuZGluZyBtb2RlIGlzIGBVTk5FQ0VTU0FSWWAsIG9yIGBuYCBpcyBvdXRcbiAgICAgKiAgICAgICAgIG9mIHJhbmdlLlxuICAgICAqL1xuICAgIHBvdyhuLCBtYykge1xuICAgICAgICBpZiAoIW1jIHx8IChtYyAmJiBtYy5wcmVjaXNpb24gPT09IDApKSB7XG4gICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+IDk5OTk5OTk5OSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBvcGVyYXRpb24nKTtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2FsY3VsYXRlIHBvdyhuKSBpZiByZXN1bHQgd2lsbCBvdmVyL3VuZGVyZmxvdy5cbiAgICAgICAgICAgIC8vIERvbid0IGF0dGVtcHQgdG8gc3VwcG9ydCBcInN1cGVybm9ybWFsXCIgbnVtYmVycy5cbiAgICAgICAgICAgIGNvbnN0IG5ld1NjYWxlID0gdGhpcy5jaGVja1NjYWxlKHRoaXMuX3NjYWxlICogbik7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tQmlnSW50NSh0aGlzLmluZmxhdGVkKCkudmFsdWVPZigpICoqIEJpZ0ludChuKSwgbmV3U2NhbGUsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDwgLTk5OTk5OTk5OSB8fCBuID4gOTk5OTk5OTk5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgb3BlcmF0aW9uJyk7XG4gICAgICAgIGlmIChuID09PSAwKSAvLyB4KiowID09IDEgaW4gWDMuMjc0XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5PTkU7XG4gICAgICAgIGxldCB3b3JrbWMgPSBtYzsgLy8gd29ya2luZyBzZXR0aW5nc1xuICAgICAgICBsZXQgbWFnID0gTWF0aC5hYnMobik7IC8vIG1hZ25pdHVkZSBvZiBuXG4gICAgICAgIGlmIChtYy5wcmVjaXNpb24gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVuZ3RoID0gQmlnRGVjaW1hbC5pbnRlZ2VyRGlnaXRMZW5ndGgobWFnKTsgLy8gbGVuZ3RoIG9mIG4gaW4gZGlnaXRzXG4gICAgICAgICAgICBpZiAoZWxlbmd0aCA+IG1jLnByZWNpc2lvbikgLy8gWDMuMjc0IHJ1bGVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBvcGVyYXRpb24nKTtcbiAgICAgICAgICAgIHdvcmttYyA9IG5ldyBNYXRoQ29udGV4dChtYy5wcmVjaXNpb24gKyBlbGVuZ3RoICsgMSwgbWMucm91bmRpbmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeSB0byBjYXJyeSBvdXQgcG93ZXIgY2FsY3VsYXRpb24uLi5cbiAgICAgICAgbGV0IGFjYyA9IEJpZ0RlY2ltYWwuT05FOyAvLyBhY2N1bXVsYXRvclxuICAgICAgICBsZXQgc2VlbmJpdCA9IGZhbHNlOyAvLyBzZXQgb25jZSB3ZSd2ZSBzZWVuIGEgMS1iaXRcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7OyBpKyspIHsgLy8gZm9yIGVhY2ggYml0IFt0b3AgYml0IGlnbm9yZWRdXG4gICAgICAgICAgICBtYWcgPDw9IDE7IC8vIHNoaWZ0IGxlZnQgMSBiaXRcbiAgICAgICAgICAgIGlmIChtYWcgPCAwKSB7IC8vIHRvcCBiaXQgaXMgc2V0XG4gICAgICAgICAgICAgICAgc2VlbmJpdCA9IHRydWU7IC8vIE9LLCB3ZSdyZSBvZmZcbiAgICAgICAgICAgICAgICBhY2MgPSBhY2MubXVsdGlwbHkodGhpcywgd29ya21jKTsgLy8gYWNjPWFjYyp4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gMzEpXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIHRoYXQgd2FzIHRoZSBsYXN0IGJpdFxuICAgICAgICAgICAgaWYgKHNlZW5iaXQpXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLm11bHRpcGx5KGFjYywgd29ya21jKTsgLy8gYWNjPWFjYyphY2MgW3NxdWFyZV1cbiAgICAgICAgICAgIC8vIGVsc2UgKCFzZWVuYml0KSBubyBwb2ludCBpbiBzcXVhcmluZyBPTkVcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBuZWdhdGl2ZSBuLCBjYWxjdWxhdGUgdGhlIHJlY2lwcm9jYWwgdXNpbmcgd29ya2luZyBwcmVjaXNpb25cbiAgICAgICAgaWYgKG4gPCAwKSAvLyBbaGVuY2UgbWMucHJlY2lzaW9uPjBdXG4gICAgICAgICAgICBhY2MgPSBCaWdEZWNpbWFsLk9ORS5kaXZpZGVXaXRoTWF0aENvbnRleHQoYWNjLCB3b3JrbWMpO1xuICAgICAgICAvLyByb3VuZCB0byBmaW5hbCBwcmVjaXNpb24gYW5kIHN0cmlwIHplcm9zXG4gICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRvUm91bmQoYWNjLCBtYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgICogb2YgdGhpcyBgQmlnRGVjaW1hbGAsIHdpdGggcm91bmRpbmcgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIGNvbnRleHQgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWMgdGhlIGNvbnRleHQgdG8gdXNlLlxuICAgICAqIEByZXR1cm4gYWJzb2x1dGUgdmFsdWUsIHJvdW5kZWQgYXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIGFicyhtYykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWdudW0oKSA8IDAgPyB0aGlzLm5lZ2F0ZShtYykgOiB0aGlzLnBsdXMobWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHVzZWQgZm9yIGRpdmlzaW9uIG9wZXJhdGlvbiBmb3IgZGl2aXNpb24gYG51bWJlcmBcbiAgICAgKiBieSBgbnVtYmVyYC5cbiAgICAgKiBUaGUgcmV0dXJuZWQgYEJpZ0RlY2ltYWxgIG9iamVjdCBpcyB0aGUgcXVvdGllbnQgd2hvc2Ugc2NhbGUgaXMgc2V0XG4gICAgICogdG8gdGhlIHBhc3NlZCBpbiBzY2FsZS4gSWYgdGhlIHJlbWFpbmRlciBpcyBub3QgemVybywgaXQgd2lsbCBiZSByb3VuZGVkXG4gICAgICogYmFzZWQgb24gdGhlIHBhc3NlZCBpbiByb3VuZGluZ01vZGUuIEFsc28sIGlmIHRoZSByZW1haW5kZXIgaXMgemVybyBhbmRcbiAgICAgKiB0aGUgbGFzdCBwYXJhbWV0ZXIsIGkuZS4gcHJlZmVycmVkU2NhbGUgaXMgTk9UIGVxdWFsIHRvIHNjYWxlLCB0aGVcbiAgICAgKiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgcmVzdWx0IGlzIHN0cmlwcGVkIHRvIG1hdGNoIHRoZSBwcmVmZXJyZWRTY2FsZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZGl2aWRlQW5kUm91bmQyKGxkaXZpZGVuZCwgbGRpdmlzb3IsIHNjYWxlLCByb3VuZGluZ01vZGUsIHByZWZlcnJlZFNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHEgPSBNYXRoLnRydW5jKGxkaXZpZGVuZCAvIGxkaXZpc29yKTtcbiAgICAgICAgaWYgKHJvdW5kaW5nTW9kZSA9PT0gUm91bmRpbmdNb2RlLkRPV04gJiYgc2NhbGUgPT09IHByZWZlcnJlZFNjYWxlKVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUludGVnZXIzKHEsIHNjYWxlKTtcbiAgICAgICAgY29uc3QgciA9IGxkaXZpZGVuZCAlIGxkaXZpc29yO1xuICAgICAgICBjb25zdCBxc2lnbiA9ICgobGRpdmlkZW5kIDwgMCkgPT09IChsZGl2aXNvciA8IDApKSA/IDEgOiAtMTsgLy8gcXVvdGllbnQgc2lnblxuICAgICAgICBpZiAociAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgaW5jcmVtZW50ID0gQmlnRGVjaW1hbC5uZWVkSW5jcmVtZW50KGxkaXZpc29yLCByb3VuZGluZ01vZGUsIHFzaWduLCBxLCByKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMygoaW5jcmVtZW50ID8gcSArIHFzaWduIDogcSksIHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmVmZXJyZWRTY2FsZSAhPT0gc2NhbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuY3JlYXRlQW5kU3RyaXBaZXJvc1RvTWF0Y2hTY2FsZShxLCBzY2FsZSwgcHJlZmVycmVkU2NhbGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21JbnRlZ2VyMyhxLCBzY2FsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgcXVvdGllbnQgaGFzIHRvIGJlIGluY3JlbWVudGVkIGFjY29yZGluZyB0aGUgcm91bmRpbmdNb2RlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIG5lZWRJbmNyZW1lbnQobGRpdmlzb3IsIHJvdW5kaW5nTW9kZSwgcXNpZ24sIHEsIHIpIHtcbiAgICAgICAgbGV0IGNtcEZyYWNIYWxmO1xuICAgICAgICBpZiAociA8PSBCaWdEZWNpbWFsLkhBTEZfTlVNQkVSX01JTl9WQUxVRSB8fCByID4gQmlnRGVjaW1hbC5IQUxGX05VTUJFUl9NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGNtcEZyYWNIYWxmID0gMTsgLy8gMiAqIHIgY2FuJ3QgZml0IGludG8gbG9uZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY21wRnJhY0hhbGYgPSBCaWdEZWNpbWFsLmludGVnZXJDb21wYXJlTWFnbml0dWRlKDIgKiByLCBsZGl2aXNvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuY29tbW9uTmVlZEluY3JlbWVudChyb3VuZGluZ01vZGUsIHFzaWduLCBjbXBGcmFjSGFsZiwgKHEgJiAxKSAhPT0gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNoYXJlZCBsb2dpYyBvZiBuZWVkIGluY3JlbWVudCBjb21wdXRhdGlvbi5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tbW9uTmVlZEluY3JlbWVudChyb3VuZGluZ01vZGUsIHFzaWduLCBjbXBGcmFjSGFsZiwgb2RkUXVvdCkge1xuICAgICAgICBzd2l0Y2ggKHJvdW5kaW5nTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBSb3VuZGluZ01vZGUuVU5ORUNFU1NBUlk6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1JvdW5kaW5nIG5lY2Vzc2FyeScpO1xuICAgICAgICAgICAgY2FzZSBSb3VuZGluZ01vZGUuVVA6IC8vIEF3YXkgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nTW9kZS5ET1dOOiAvLyBUb3dhcmRzIHplcm9cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nTW9kZS5DRUlMSU5HOiAvLyBUb3dhcmRzICtpbmZpbml0eVxuICAgICAgICAgICAgICAgIHJldHVybiBxc2lnbiA+IDA7XG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nTW9kZS5GTE9PUjogLy8gVG93YXJkcyAtaW5maW5pdHlcbiAgICAgICAgICAgICAgICByZXR1cm4gcXNpZ24gPCAwO1xuICAgICAgICAgICAgZGVmYXVsdDogLy8gU29tZSBraW5kIG9mIGhhbGYtd2F5IHJvdW5kaW5nXG4gICAgICAgICAgICAgICAgaWYgKGNtcEZyYWNIYWxmIDwgMCkgLy8gV2UncmUgY2xvc2VyIHRvIGhpZ2hlciBkaWdpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY21wRnJhY0hhbGYgPiAwKSAvLyBXZSdyZSBjbG9zZXIgdG8gbG93ZXIgZGlnaXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIGhhbGYtd2F5XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocm91bmRpbmdNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdW5kaW5nTW9kZS5IQUxGX0RPV046XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3VuZGluZ01vZGUuSEFMRl9VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUm91bmRpbmdNb2RlLkhBTEZfRVZFTjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2RkUXVvdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuZXhwZWN0ZWQgcm91bmRpbmcgbW9kZSAke1JvdW5kaW5nTW9kZVtyb3VuZGluZ01vZGVdfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgaW50ZWdlckNvbXBhcmVNYWduaXR1ZGUoeCwgeSkge1xuICAgICAgICBpZiAoeCA8IDApXG4gICAgICAgICAgICB4ID0gLXg7XG4gICAgICAgIGlmICh5IDwgMClcbiAgICAgICAgICAgIHkgPSAteTtcbiAgICAgICAgcmV0dXJuICh4IDwgeSkgPyAtMSA6ICgoeCA9PT0geSkgPyAwIDogMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIG1hZ25pdHVkZXMgb2YgdHdvIGJpZ2ludHMgaWYgeCA8IHkgcmV0dXJucyAtMSwgaWYgZXF1YWwgMCBpZiB4ID4geSwgMS5cbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGJpZ0ludENvbXBhcmVNYWduaXR1ZGUoeCwgeSkge1xuICAgICAgICBpZiAoeCA8IEJpZ0RlY2ltYWwuemVyb0JpZ0ludClcbiAgICAgICAgICAgIHggPSBCaWdEZWNpbWFsLm1pbnVzT25lQmlnSW50ICogeC52YWx1ZU9mKCk7XG4gICAgICAgIGlmICh5IDwgQmlnRGVjaW1hbC56ZXJvQmlnSW50KVxuICAgICAgICAgICAgeSA9IEJpZ0RlY2ltYWwubWludXNPbmVCaWdJbnQgKiB5LnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuICh4IDwgeSkgPyAtMSA6ICgoeCA9PT0geSkgPyAwIDogMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYmlnaW50IHRvIGJpZ2RlY2ltYWxcbiAgICAgKiBAcGFyYW0gYmlnSW50IGJpZ2ludFxuICAgICAqIEBwYXJhbSBxc2lnbiBzaWduXG4gICAgICogQHBhcmFtIHNjYWxlIHNjYWxlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGJpZ0ludFRvQmlnRGVjaW1hbChiaWdJbnQsIHFzaWduLCBzY2FsZSkge1xuICAgICAgICBpZiAoYmlnSW50IDw9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgJiYgYmlnSW50ID49IEJpZ0ludChOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlckZvcm0gPSBOdW1iZXIoYmlnSW50KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbChudWxsLCBxc2lnbiAqIG51bWJlckZvcm0sIHNjYWxlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbChCaWdJbnQocXNpZ24pICogYmlnSW50LnZhbHVlT2YoKSwgQmlnRGVjaW1hbC5JTkZMQVRFRCwgc2NhbGUsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYmlnaW50IHRvIG51bWJlciwgcmV0dXJucyBJTkZMQVRFRCBpZiBpdCB3b24ndCBiZSBhIHNhZmUgaW50ZWdlclxuICAgICAqIEBwYXJhbSBiaWdJbnQgYmlnaW50XG4gICAgICogQHBhcmFtIHFzaWduIHNpZ24gbnVtYmVyXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGJpZ0ludFRvQ29tcGFjdFZhbHVlKGJpZ0ludCwgcXNpZ24pIHtcbiAgICAgICAgaWYgKGJpZ0ludCA8PSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpICYmIGJpZ0ludCA+PSBCaWdJbnQoTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcXNpZ24gKiBOdW1iZXIoYmlnSW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLklORkxBVEVEO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgdXNlZCBmb3IgZGl2aXNpb24gb3BlcmF0aW9uIGZvciBkaXZpc2lvbiBgQmlnSW50YFxuICAgICAqIGJ5IGBCaWdJbnRgLlxuICAgICAqIFRoZSByZXR1cm5lZCBgQmlnRGVjaW1hbGAgb2JqZWN0IGlzIHRoZSBxdW90aWVudCB3aG9zZSBzY2FsZSBpcyBzZXRcbiAgICAgKiB0byB0aGUgcGFzc2VkIGluIHNjYWxlLiBJZiB0aGUgcmVtYWluZGVyIGlzIG5vdCB6ZXJvLCBpdCB3aWxsIGJlIHJvdW5kZWRcbiAgICAgKiBiYXNlZCBvbiB0aGUgcGFzc2VkIGluIHJvdW5kaW5nTW9kZS4gQWxzbywgaWYgdGhlIHJlbWFpbmRlciBpcyB6ZXJvIGFuZFxuICAgICAqIHRoZSBsYXN0IHBhcmFtZXRlciwgaS5lLiBwcmVmZXJyZWRTY2FsZSBpcyBOT1QgZXF1YWwgdG8gc2NhbGUsIHRoZVxuICAgICAqIHRyYWlsaW5nIHplcm9zIG9mIHRoZSByZXN1bHQgaXMgc3RyaXBwZWQgdG8gbWF0Y2ggdGhlIHByZWZlcnJlZFNjYWxlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBkaXZpZGVBbmRSb3VuZDMoYmRpdmlkZW5kLCBiZGl2aXNvciwgc2NhbGUsIHJvdW5kaW5nTW9kZSwgcHJlZmVycmVkU2NhbGUpIHtcbiAgICAgICAgLy8gcXVvdGllbnQgc2lnblxuICAgICAgICBjb25zdCBxc2lnbiA9IChCaWdEZWNpbWFsLmJpZ0ludFNpZ251bShiZGl2aWRlbmQpICE9PSBCaWdEZWNpbWFsLmJpZ0ludFNpZ251bShiZGl2aXNvcikpID8gLTEgOiAxO1xuICAgICAgICBpZiAoYmRpdmlkZW5kIDwgQmlnRGVjaW1hbC56ZXJvQmlnSW50KVxuICAgICAgICAgICAgYmRpdmlkZW5kID0gYmRpdmlkZW5kLnZhbHVlT2YoKSAqIEJpZ0RlY2ltYWwubWludXNPbmVCaWdJbnQ7XG4gICAgICAgIGlmIChiZGl2aXNvciA8IEJpZ0RlY2ltYWwuemVyb0JpZ0ludClcbiAgICAgICAgICAgIGJkaXZpc29yID0gYmRpdmlzb3IudmFsdWVPZigpICogQmlnRGVjaW1hbC5taW51c09uZUJpZ0ludDtcbiAgICAgICAgbGV0IG1xID0gYmRpdmlkZW5kLnZhbHVlT2YoKSAvIGJkaXZpc29yLnZhbHVlT2YoKTtcbiAgICAgICAgY29uc3QgbXIgPSBiZGl2aWRlbmQudmFsdWVPZigpICUgYmRpdmlzb3IudmFsdWVPZigpO1xuICAgICAgICAvLyByZWNvcmQgcmVtYWluZGVyIGlzIHplcm8gb3Igbm90XG4gICAgICAgIGNvbnN0IGlzUmVtYWluZGVyWmVybyA9IG1yID09PSBCaWdEZWNpbWFsLnplcm9CaWdJbnQ7XG4gICAgICAgIGlmICghaXNSZW1haW5kZXJaZXJvKSB7XG4gICAgICAgICAgICBpZiAoQmlnRGVjaW1hbC5uZWVkSW5jcmVtZW50MihiZGl2aXNvciwgcm91bmRpbmdNb2RlLCBxc2lnbiwgbXEsIG1yKSkge1xuICAgICAgICAgICAgICAgIG1xICs9IEJpZ0RlY2ltYWwub25lQmlnSW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuYmlnSW50VG9CaWdEZWNpbWFsKG1xLCBxc2lnbiwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZWZlcnJlZFNjYWxlICE9PSBzY2FsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhY3RWYWwgPSBCaWdEZWNpbWFsLmJpZ0ludFRvQ29tcGFjdFZhbHVlKG1xLCBxc2lnbik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhY3RWYWwgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuY3JlYXRlQW5kU3RyaXBaZXJvc1RvTWF0Y2hTY2FsZShjb21wYWN0VmFsLCBzY2FsZSwgcHJlZmVycmVkU2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbnRWYWwgPSBCaWdJbnQocXNpZ24pICogbXEudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmNyZWF0ZUFuZFN0cmlwWmVyb3NUb01hdGNoU2NhbGUyKGludFZhbCwgc2NhbGUsIHByZWZlcnJlZFNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmJpZ0ludFRvQmlnRGVjaW1hbChtcSwgcXNpZ24sIHNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBxdW90aWVudCBoYXMgdG8gYmUgaW5jcmVtZW50ZWQgYWNjb3JkaW5nIHRoZSByb3VuZGluZ01vZGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgbmVlZEluY3JlbWVudDIobWRpdmlzb3IsIHJvdW5kaW5nTW9kZSwgcXNpZ24sIG1xLCBtcikge1xuICAgICAgICBjb25zdCBjbXBGcmFjSGFsZiA9IEJpZ0RlY2ltYWwuY29tcGFyZUhhbGYobXIsIG1kaXZpc29yKTtcbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuY29tbW9uTmVlZEluY3JlbWVudChyb3VuZGluZ01vZGUsIHFzaWduLCBjbXBGcmFjSGFsZiwgbXEudmFsdWVPZigpICUgQmlnRGVjaW1hbC50d29CaWdJbnQgPT09IEJpZ0RlY2ltYWwub25lQmlnSW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgaGFsZiBvZiBzZWNvbmQgd2l0aCBmaXJzdFxuICAgICAqIEBwYXJhbSBmaXJzdFxuICAgICAqIEBwYXJhbSBzZWNvbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlSGFsZihmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHNlY29uZCA9IHNlY29uZC52YWx1ZU9mKCkgLyBCaWdEZWNpbWFsLnR3b0JpZ0ludDtcbiAgICAgICAgaWYgKGZpcnN0IDwgc2Vjb25kKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoZmlyc3QgPiBzZWNvbmQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgdXNlZCBmb3IgZGl2aXNpb24gb3BlcmF0aW9uIGZvciBkaXZpc2lvbiBgQmlnSW50YFxuICAgICAqIGJ5IGBudW1iZXJgLlxuICAgICAqIFRoZSByZXR1cm5lZCBgQmlnRGVjaW1hbGAgb2JqZWN0IGlzIHRoZSBxdW90aWVudCB3aG9zZSBzY2FsZSBpcyBzZXRcbiAgICAgKiB0byB0aGUgcGFzc2VkIGluIHNjYWxlLiBJZiB0aGUgcmVtYWluZGVyIGlzIG5vdCB6ZXJvLCBpdCB3aWxsIGJlIHJvdW5kZWRcbiAgICAgKiBiYXNlZCBvbiB0aGUgcGFzc2VkIGluIHJvdW5kaW5nTW9kZS4gQWxzbywgaWYgdGhlIHJlbWFpbmRlciBpcyB6ZXJvIGFuZFxuICAgICAqIHRoZSBsYXN0IHBhcmFtZXRlciwgaS5lLiBwcmVmZXJyZWRTY2FsZSBpcyBOT1QgZXF1YWwgdG8gc2NhbGUsIHRoZVxuICAgICAqIHRyYWlsaW5nIHplcm9zIG9mIHRoZSByZXN1bHQgaXMgc3RyaXBwZWQgdG8gbWF0Y2ggdGhlIHByZWZlcnJlZFNjYWxlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBkaXZpZGVBbmRSb3VuZDQoYmRpdmlkZW5kLCBsZGl2aXNvciwgc2NhbGUsIHJvdW5kaW5nTW9kZSwgcHJlZmVycmVkU2NhbGUpIHtcbiAgICAgICAgY29uc3QgZGl2aXNvck5lZ2F0aXZlID0gbGRpdmlzb3IgPCAwO1xuICAgICAgICBjb25zdCBkaXZpZGVuZFNpZ251bSA9IEJpZ0RlY2ltYWwuYmlnSW50U2lnbnVtKGJkaXZpZGVuZCk7XG4gICAgICAgIGlmIChkaXZpc29yTmVnYXRpdmUpXG4gICAgICAgICAgICBsZGl2aXNvciAqPSAtMTtcbiAgICAgICAgaWYgKGRpdmlkZW5kU2lnbnVtID09PSAtMSlcbiAgICAgICAgICAgIGJkaXZpZGVuZCA9IGJkaXZpZGVuZC52YWx1ZU9mKCkgKiBCaWdEZWNpbWFsLm1pbnVzT25lQmlnSW50O1xuICAgICAgICBsZXQgbXEgPSBiZGl2aWRlbmQudmFsdWVPZigpIC8gQmlnSW50KGxkaXZpc29yKTtcbiAgICAgICAgbGV0IG1yO1xuICAgICAgICBjb25zdCBiRGl2aWRlbmROdW1iZXIgPSBOdW1iZXIoYmRpdmlkZW5kKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKGJEaXZpZGVuZE51bWJlcikpIHtcbiAgICAgICAgICAgIG1yID0gYkRpdmlkZW5kTnVtYmVyICUgbGRpdmlzb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtciA9IE51bWJlcihiZGl2aWRlbmQudmFsdWVPZigpICUgQmlnSW50KGxkaXZpc29yKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb3JkIHJlbWFpbmRlciBpcyB6ZXJvIG9yIG5vdFxuICAgICAgICBjb25zdCBpc1JlbWFpbmRlclplcm8gPSBtciA9PT0gMDtcbiAgICAgICAgLy8gcXVvdGllbnQgc2lnblxuICAgICAgICBjb25zdCBxc2lnbiA9IGRpdmlzb3JOZWdhdGl2ZSA/IC1kaXZpZGVuZFNpZ251bSA6IGRpdmlkZW5kU2lnbnVtO1xuICAgICAgICBpZiAoIWlzUmVtYWluZGVyWmVybykge1xuICAgICAgICAgICAgaWYgKEJpZ0RlY2ltYWwubmVlZEluY3JlbWVudDMobGRpdmlzb3IsIHJvdW5kaW5nTW9kZSwgcXNpZ24sIG1xLCBtcikpIHtcbiAgICAgICAgICAgICAgICBtcSArPSBCaWdEZWNpbWFsLm9uZUJpZ0ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmJpZ0ludFRvQmlnRGVjaW1hbChtcSwgcXNpZ24sIHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmVmZXJyZWRTY2FsZSAhPT0gc2NhbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYWN0VmFsID0gQmlnRGVjaW1hbC5iaWdJbnRUb0NvbXBhY3RWYWx1ZShtcSwgcXNpZ24pO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYWN0VmFsICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmNyZWF0ZUFuZFN0cmlwWmVyb3NUb01hdGNoU2NhbGUoY29tcGFjdFZhbCwgc2NhbGUsIHByZWZlcnJlZFNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaW50VmFsID0gQmlnSW50KHFzaWduKSAqIG1xLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5jcmVhdGVBbmRTdHJpcFplcm9zVG9NYXRjaFNjYWxlMihpbnRWYWwsIHNjYWxlLCBwcmVmZXJyZWRTY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5iaWdJbnRUb0JpZ0RlY2ltYWwobXEsIHFzaWduLCBzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgcXVvdGllbnQgaGFzIHRvIGJlIGluY3JlbWVudGVkIGFjY29yZGluZyB0aGUgcm91bmRpbmdNb2RlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIG5lZWRJbmNyZW1lbnQzKGxkaXZpc29yLCByb3VuZGluZ01vZGUsIHFzaWduLCBtcSwgcikge1xuICAgICAgICBsZXQgY21wRnJhY0hhbGY7XG4gICAgICAgIGlmIChyIDw9IEJpZ0RlY2ltYWwuSEFMRl9OVU1CRVJfTUlOX1ZBTFVFIHx8IHIgPiBCaWdEZWNpbWFsLkhBTEZfTlVNQkVSX01BWF9WQUxVRSkge1xuICAgICAgICAgICAgY21wRnJhY0hhbGYgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY21wRnJhY0hhbGYgPSBCaWdEZWNpbWFsLmludGVnZXJDb21wYXJlTWFnbml0dWRlKDIgKiByLCBsZGl2aXNvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuY29tbW9uTmVlZEluY3JlbWVudChyb3VuZGluZ01vZGUsIHFzaWduLCBjbXBGcmFjSGFsZiwgbXEudmFsdWVPZigpICUgQmlnRGVjaW1hbC50d29CaWdJbnQgPT09IEJpZ0RlY2ltYWwub25lQmlnSW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCaWdEZWNpbWFsYCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoaXMgb25lXG4gICAgICogd2l0aCB0aGUgZGVjaW1hbCBwb2ludCBtb3ZlZCBgbmAgcGxhY2VzIHRvIHRoZSBsZWZ0LiAgSWZcbiAgICAgKiBgbmAgaXMgbm9uLW5lZ2F0aXZlLCB0aGUgY2FsbCBtZXJlbHkgYWRkcyBgbmAgdG9cbiAgICAgKiB0aGUgc2NhbGUuICBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBjYWxsIGlzIGVxdWl2YWxlbnRcbiAgICAgKiB0byBgbW92ZVBvaW50UmlnaHQoLW4pYC4gIFRoZSBgQmlnRGVjaW1hbGBcbiAgICAgKiByZXR1cm5lZCBieSB0aGlzIGNhbGwgaGFzIHZhbHVlIDxjb2RlPih0aGlzICZ0aW1lcztcbiAgICAgKiAxMDxzdXA+LW48L3N1cD4pPC9jb2RlPiBhbmQgc2NhbGUgYG1heCh0aGlzLnNjYWxlKCkrbixcbiAgICAgKiAwKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbiBudW1iZXIgb2YgcGxhY2VzIHRvIG1vdmUgdGhlIGRlY2ltYWwgcG9pbnQgdG8gdGhlIGxlZnQuXG4gICAgICogQHJldHVybiBhIGBCaWdEZWNpbWFsYCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoaXMgb25lIHdpdGggdGhlXG4gICAgICogICAgICAgICBkZWNpbWFsIHBvaW50IG1vdmVkIGBuYCBwbGFjZXMgdG8gdGhlIGxlZnQuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIHNjYWxlIG92ZXJmbG93cy5cbiAgICAgKi9cbiAgICBtb3ZlUG9pbnRMZWZ0KG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgLy8gQ2Fubm90IHVzZSBtb3ZlUG9pbnRSaWdodCgtbikgaW4gY2FzZSBvZiBuPT1CaWdEZWNpbWFsLk1JTl9JTlRfVkFMVUVcbiAgICAgICAgY29uc3QgbmV3U2NhbGUgPSB0aGlzLmNoZWNrU2NhbGUodGhpcy5fc2NhbGUgKyBuKTtcbiAgICAgICAgY29uc3QgbnVtID0gbmV3IEJpZ0RlY2ltYWwodGhpcy5pbnRWYWwsIHRoaXMuaW50Q29tcGFjdCwgbmV3U2NhbGUsIDApO1xuICAgICAgICByZXR1cm4gbnVtLl9zY2FsZSA8IDAgPyBudW0uc2V0U2NhbGUoMCwgUm91bmRpbmdNb2RlLlVOTkVDRVNTQVJZKSA6IG51bTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCaWdEZWNpbWFsYCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoaXMgb25lXG4gICAgICogd2l0aCB0aGUgZGVjaW1hbCBwb2ludCBtb3ZlZCBgbmAgcGxhY2VzIHRvIHRoZSByaWdodC5cbiAgICAgKiBJZiBgbmAgaXMgbm9uLW5lZ2F0aXZlLCB0aGUgY2FsbCBtZXJlbHkgc3VidHJhY3RzXG4gICAgICogYG5gIGZyb20gdGhlIHNjYWxlLiAgSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgY2FsbFxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gYG1vdmVQb2ludExlZnQoLW4pYC4gIFRoZVxuICAgICAqIGBCaWdEZWNpbWFsYCByZXR1cm5lZCBieSB0aGlzIGNhbGwgaGFzIHZhbHVlIDxjb2RlPih0aGlzXG4gICAgICogJnRpbWVzOyAxMDxzdXA+bjwvc3VwPik8L2NvZGU+IGFuZCBzY2FsZSBgbWF4KHRoaXMuc2NhbGUoKS1uLCAwKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbiBudW1iZXIgb2YgcGxhY2VzIHRvIG1vdmUgdGhlIGRlY2ltYWwgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuICAgICAqIEByZXR1cm4gYSBgQmlnRGVjaW1hbGAgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGlzIG9uZVxuICAgICAqICAgICAgICAgd2l0aCB0aGUgZGVjaW1hbCBwb2ludCBtb3ZlZCBgbmAgcGxhY2VzIHRvIHRoZSByaWdodC5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgc2NhbGUgb3ZlcmZsb3dzLlxuICAgICAqL1xuICAgIG1vdmVQb2ludFJpZ2h0KG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgLy8gQ2Fubm90IHVzZSBtb3ZlUG9pbnRMZWZ0KC1uKSBpbiBjYXNlIG9mIG49PUJpZ0RlY2ltYWwuTUlOX0lOVF9WQUxVRVxuICAgICAgICBjb25zdCBuZXdTY2FsZSA9IHRoaXMuY2hlY2tTY2FsZSh0aGlzLl9zY2FsZSAtIG4pO1xuICAgICAgICBjb25zdCBudW0gPSBuZXcgQmlnRGVjaW1hbCh0aGlzLmludFZhbCwgdGhpcy5pbnRDb21wYWN0LCBuZXdTY2FsZSwgMCk7XG4gICAgICAgIHJldHVybiBudW0uX3NjYWxlIDwgMCA/IG51bS5zZXRTY2FsZSgwLCBSb3VuZGluZ01vZGUuVU5ORUNFU1NBUlkpIDogbnVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHRoaXMgYEJpZ0RlY2ltYWxgIGFuZCBgdmFsYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWwgdmFsdWUgd2l0aCB3aGljaCB0aGUgbWluaW11bSBpcyB0byBiZSBjb21wdXRlZC5cbiAgICAgKiBAcmV0dXJuIHRoZSBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXMgdGhlIGxlc3NlciBvZiB0aGlzXG4gICAgICogICAgICAgICBgQmlnRGVjaW1hbGAgYW5kIGB2YWxgLiAgSWYgdGhleSBhcmUgZXF1YWwsXG4gICAgICogICAgICAgICBhcyBkZWZpbmVkIGJ5IHRoZSB7QGxpbmsgY29tcGFyZVRvfVxuICAgICAqICAgICAgICAgbWV0aG9kLCBgdGhpc2AgaXMgcmV0dXJuZWQuXG4gICAgICogQHNlZSAgICB7QGxpbmsgY29tcGFyZVRvfVxuICAgICAqL1xuICAgIG1pbih2YWwpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyh2YWwpIDw9IDAgPyB0aGlzIDogdmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0aGlzIGBCaWdEZWNpbWFsYCBhbmQgYHZhbGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIHZhbHVlIHdpdGggd2hpY2ggdGhlIG1heGltdW0gaXMgdG8gYmUgY29tcHV0ZWQuXG4gICAgICogQHJldHVybiB0aGUgYEJpZ0RlY2ltYWxgIHdob3NlIHZhbHVlIGlzIHRoZSBncmVhdGVyIG9mIHRoaXNcbiAgICAgKiAgICAgICAgIGBCaWdEZWNpbWFsYCBhbmQgYHZhbGAuICBJZiB0aGV5IGFyZSBlcXVhbCxcbiAgICAgKiAgICAgICAgIGFzIGRlZmluZWQgYnkgdGhlIHtAbGluayBjb21wYXJlVG99XG4gICAgICogICAgICAgICBtZXRob2QsIGB0aGlzYCBpcyByZXR1cm5lZC5cbiAgICAgKiBAc2VlICAgIHtAbGluayBjb21wYXJlVG99XG4gICAgICovXG4gICAgbWF4KHZhbCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKHZhbCkgPj0gMCA/IHRoaXMgOiB2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgQmlnRGVjaW1hbGAsXG4gICAgICogdXNpbmcgc2NpZW50aWZpYyBub3RhdGlvbiBpZiBhbiBleHBvbmVudCBpcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBBIHN0YW5kYXJkIGNhbm9uaWNhbCBzdHJpbmcgZm9ybSBvZiB0aGUgYEJpZ0RlY2ltYWxgXG4gICAgICogaXMgY3JlYXRlZCBhcyB0aG91Z2ggYnkgdGhlIGZvbGxvd2luZyBzdGVwczogZmlyc3QsIHRoZVxuICAgICAqIGFic29sdXRlIHZhbHVlIG9mIHRoZSB1bnNjYWxlZCB2YWx1ZSBvZiB0aGUgYEJpZ0RlY2ltYWxgXG4gICAgICogaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGluIGJhc2UgdGVuIHVzaW5nIHRoZSBjaGFyYWN0ZXJzXG4gICAgICogJzAnIHRocm91Z2ggJzknIHdpdGggbm8gbGVhZGluZyB6ZXJvcyAoZXhjZXB0XG4gICAgICogaWYgaXRzIHZhbHVlIGlzIHplcm8sIGluIHdoaWNoIGNhc2UgYSBzaW5nbGUgJzAnXG4gICAgICogY2hhcmFjdGVyIGlzIHVzZWQpLlxuICAgICAqXG4gICAgICogTmV4dCwgYW4gPGk+YWRqdXN0ZWQgZXhwb25lbnQ8L2k+IGlzIGNhbGN1bGF0ZWQ7IHRoaXMgaXMgdGhlXG4gICAgICogbmVnYXRlZCBzY2FsZSwgcGx1cyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGNvbnZlcnRlZFxuICAgICAqIHVuc2NhbGVkIHZhbHVlLCBsZXNzIG9uZS4gIFRoYXQgaXMsXG4gICAgICogYC1zY2FsZSsodWxlbmd0aC0xKWAsIHdoZXJlIGB1bGVuZ3RoYCBpcyB0aGVcbiAgICAgKiBsZW5ndGggb2YgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSB1bnNjYWxlZCB2YWx1ZSBpbiBkZWNpbWFsXG4gICAgICogZGlnaXRzIChpdHMgPGk+cHJlY2lzaW9uPC9pPikuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc2NhbGUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8gYW5kIHRoZVxuICAgICAqIGFkanVzdGVkIGV4cG9uZW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgLTZgLCB0aGVcbiAgICAgKiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBjaGFyYWN0ZXIgZm9ybSB3aXRob3V0IHVzaW5nXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uICBJbiB0aGlzIGNhc2UsIGlmIHRoZSBzY2FsZSBpcyB6ZXJvIHRoZW5cbiAgICAgKiBubyBkZWNpbWFsIHBvaW50IGlzIGFkZGVkIGFuZCBpZiB0aGUgc2NhbGUgaXMgcG9zaXRpdmUgYVxuICAgICAqIGRlY2ltYWwgcG9pbnQgd2lsbCBiZSBpbnNlcnRlZCB3aXRoIHRoZSBzY2FsZSBzcGVjaWZ5aW5nIHRoZVxuICAgICAqIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodCBvZiB0aGUgZGVjaW1hbCBwb2ludC5cbiAgICAgKiAnMCcgY2hhcmFjdGVycyBhcmUgYWRkZWQgdG8gdGhlIGxlZnQgb2YgdGhlIGNvbnZlcnRlZFxuICAgICAqIHVuc2NhbGVkIHZhbHVlIGFzIG5lY2Vzc2FyeS4gIElmIG5vIGNoYXJhY3RlciBwcmVjZWRlcyB0aGVcbiAgICAgKiBkZWNpbWFsIHBvaW50IGFmdGVyIHRoaXMgaW5zZXJ0aW9uIHRoZW4gYSBjb252ZW50aW9uYWxcbiAgICAgKiAnMCcgY2hhcmFjdGVyIGlzIHByZWZpeGVkLlxuICAgICAqXG4gICAgICogT3RoZXJ3aXNlICh0aGF0IGlzLCBpZiB0aGUgc2NhbGUgaXMgbmVnYXRpdmUsIG9yIHRoZVxuICAgICAqIGFkanVzdGVkIGV4cG9uZW50IGlzIGxlc3MgdGhhbiBgLTZgKSwgdGhlIG51bWJlciB3aWxsIGJlXG4gICAgICogY29udmVydGVkIHRvIGEgY2hhcmFjdGVyIGZvcm0gdXNpbmcgZXhwb25lbnRpYWwgbm90YXRpb24uICBJblxuICAgICAqIHRoaXMgY2FzZSwgaWYgdGhlIGNvbnZlcnRlZCBgQmlnSW50YCBoYXMgbW9yZSB0aGFuXG4gICAgICogb25lIGRpZ2l0IGEgZGVjaW1hbCBwb2ludCBpcyBpbnNlcnRlZCBhZnRlciB0aGUgZmlyc3QgZGlnaXQuXG4gICAgICogQW4gZXhwb25lbnQgaW4gY2hhcmFjdGVyIGZvcm0gaXMgdGhlbiBzdWZmaXhlZCB0byB0aGUgY29udmVydGVkXG4gICAgICogdW5zY2FsZWQgdmFsdWUgKHBlcmhhcHMgd2l0aCBpbnNlcnRlZCBkZWNpbWFsIHBvaW50KTsgdGhpc1xuICAgICAqIGNvbXByaXNlcyB0aGUgbGV0dGVyICdFJyBmb2xsb3dlZCBpbW1lZGlhdGVseSBieSB0aGVcbiAgICAgKiBhZGp1c3RlZCBleHBvbmVudCBjb252ZXJ0ZWQgdG8gYSBjaGFyYWN0ZXIgZm9ybS4gIFRoZSBsYXR0ZXIgaXNcbiAgICAgKiBpbiBiYXNlIHRlbiwgdXNpbmcgdGhlIGNoYXJhY3RlcnMgJzAnIHRocm91Z2hcbiAgICAgKiAnOScgd2l0aCBubyBsZWFkaW5nIHplcm9zLCBhbmQgaXMgYWx3YXlzIHByZWZpeGVkIGJ5IGFcbiAgICAgKiBzaWduIGNoYXJhY3RlciAnLScgKDxjb2RlPicmIzkyO3UwMDJEJzwvY29kZT4pIGlmIHRoZVxuICAgICAqIGFkanVzdGVkIGV4cG9uZW50IGlzIG5lZ2F0aXZlLCAnKydcbiAgICAgKiAoPGNvZGU+JyYjOTI7dTAwMkInPC9jb2RlPikgb3RoZXJ3aXNlKS5cbiAgICAgKlxuICAgICAqIEZpbmFsbHksIHRoZSBlbnRpcmUgc3RyaW5nIGlzIHByZWZpeGVkIGJ5IGEgbWludXMgc2lnblxuICAgICAqIGNoYXJhY3RlciAnLScgKDxjb2RlPicmIzkyO3UwMDJEJzwvY29kZT4pIGlmIHRoZSB1bnNjYWxlZFxuICAgICAqIHZhbHVlIGlzIGxlc3MgdGhhbiB6ZXJvLiAgTm8gc2lnbiBjaGFyYWN0ZXIgaXMgcHJlZml4ZWQgaWYgdGhlXG4gICAgICogdW5zY2FsZWQgdmFsdWUgaXMgemVybyBvciBwb3NpdGl2ZS5cbiAgICAgKlxuICAgICAqICoqRXhhbXBsZXM6KipcbiAgICAgKiBGb3IgZWFjaCByZXByZXNlbnRhdGlvbiBbPGk+dW5zY2FsZWQgdmFsdWU8L2k+LCA8aT5zY2FsZTwvaT5dXG4gICAgICogb24gdGhlIGxlZnQsIHRoZSByZXN1bHRpbmcgc3RyaW5nIGlzIHNob3duIG9uIHRoZSByaWdodC5cbiAgICAgKiA8cHJlPlxuICAgICAqIFsxMjMsMF0gICAgICBcIjEyM1wiXG4gICAgICogWy0xMjMsMF0gICAgIFwiLTEyM1wiXG4gICAgICogWzEyMywtMV0gICAgIFwiMS4yM0UrM1wiXG4gICAgICogWzEyMywtM10gICAgIFwiMS4yM0UrNVwiXG4gICAgICogWzEyMywxXSAgICAgIFwiMTIuM1wiXG4gICAgICogWzEyMyw1XSAgICAgIFwiMC4wMDEyM1wiXG4gICAgICogWzEyMywxMF0gICAgIFwiMS4yM0UtOFwiXG4gICAgICogWy0xMjMsMTJdICAgIFwiLTEuMjNFLTEwXCJcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqICoqTm90ZXM6KipcbiAgICAgKlxuICAgICAqICogVGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlbiB0aGUgZGlzdGluZ3Vpc2hhYmxlXG4gICAgICogYEJpZ0RlY2ltYWxgIHZhbHVlcyBhbmQgdGhlIHJlc3VsdCBvZiB0aGlzIGNvbnZlcnNpb24uXG4gICAgICogVGhhdCBpcywgZXZlcnkgZGlzdGluZ3Vpc2hhYmxlIGBCaWdEZWNpbWFsYCB2YWx1ZVxuICAgICAqICh1bnNjYWxlZCB2YWx1ZSBhbmQgc2NhbGUpIGhhcyBhIHVuaXF1ZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBhcyBhIHJlc3VsdCBvZiB1c2luZyBgdG9TdHJpbmdgLiAgSWYgdGhhdCBzdHJpbmdcbiAgICAgKiByZXByZXNlbnRhdGlvbiBpcyBjb252ZXJ0ZWQgYmFjayB0byBhIGBCaWdEZWNpbWFsYCB1c2luZ1xuICAgICAqIHRoZSBzdHJpbmcgY29uc3RydWN0b3IsIHRoZW4gdGhlIG9yaWdpbmFsXG4gICAgICogdmFsdWUgd2lsbCBiZSByZWNvdmVyZWQuXG4gICAgICpcbiAgICAgKiAqIFRoZSB7QGxpbmsgdG9FbmdpbmVlcmluZ1N0cmluZ30gbWV0aG9kIG1heSBiZSB1c2VkIGZvclxuICAgICAqIHByZXNlbnRpbmcgbnVtYmVycyB3aXRoIGV4cG9uZW50cyBpbiBlbmdpbmVlcmluZyBub3RhdGlvbiwgYW5kIHRoZVxuICAgICAqIHtAbGluayBzZXRTY2FsZX0gbWV0aG9kIG1heSBiZSB1c2VkIGZvclxuICAgICAqIHJvdW5kaW5nIGEgYEJpZ0RlY2ltYWxgIHNvIGl0IGhhcyBhIGtub3duIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXJcbiAgICAgKiB0aGUgZGVjaW1hbCBwb2ludC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYEJpZ0RlY2ltYWxgLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc2MgPSB0aGlzLnN0cmluZ0NhY2hlO1xuICAgICAgICBpZiAoc2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdDYWNoZSA9IHNjID0gdGhpcy5sYXlvdXRTdHJpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYEJpZ0RlY2ltYWxgLFxuICAgICAqIHVzaW5nIGVuZ2luZWVyaW5nIG5vdGF0aW9uIGlmIGFuIGV4cG9uZW50IGlzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBgQmlnRGVjaW1hbGAgYXNcbiAgICAgKiBkZXNjcmliZWQgaW4gdGhlIHtAbGluayB0b1N0cmluZ30gbWV0aG9kLCBleGNlcHQgdGhhdCBpZlxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlzIHVzZWQsIHRoZSBwb3dlciBvZiB0ZW4gaXMgYWRqdXN0ZWQgdG9cbiAgICAgKiBiZSBhIG11bHRpcGxlIG9mIHRocmVlIChlbmdpbmVlcmluZyBub3RhdGlvbikgc3VjaCB0aGF0IHRoZVxuICAgICAqIGludGVnZXIgcGFydCBvZiBub256ZXJvIHZhbHVlcyB3aWxsIGJlIGluIHRoZSByYW5nZSAxIHRocm91Z2hcbiAgICAgKiA5OTkuICBJZiBleHBvbmVudGlhbCBub3RhdGlvbiBpcyB1c2VkIGZvciB6ZXJvIHZhbHVlcywgYVxuICAgICAqIGRlY2ltYWwgcG9pbnQgYW5kIG9uZSBvciB0d28gZnJhY3Rpb25hbCB6ZXJvIGRpZ2l0cyBhcmUgdXNlZCBzb1xuICAgICAqIHRoYXQgdGhlIHNjYWxlIG9mIHRoZSB6ZXJvIHZhbHVlIGlzIHByZXNlcnZlZC4gIE5vdGUgdGhhdFxuICAgICAqIHVubGlrZSB0aGUgb3V0cHV0IG9mIHtAbGluayB0b1N0cmluZ30sIHRoZSBvdXRwdXQgb2YgdGhpc1xuICAgICAqIG1ldGhvZCBpcyA8ZW0+bm90PC9lbT4gZ3VhcmFudGVlZCB0byByZWNvdmVyIHRoZSBzYW1lIFtudW1iZXIsXG4gICAgICogc2NhbGVdIHBhaXIgb2YgdGhpcyBgQmlnRGVjaW1hbGAgaWYgdGhlIG91dHB1dCBzdHJpbmcgaXNcbiAgICAgKiBjb252ZXJ0aW5nIGJhY2sgdG8gYSBgQmlnRGVjaW1hbGAgdXNpbmcgdGhlIHN0cmluZyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBUaGUgcmVzdWx0IG9mIHRoaXMgbWV0aG9kIG1lZXRzIHRoZSB3ZWFrZXIgY29uc3RyYWludCBvZiBhbHdheXMgcHJvZHVjaW5nIGEgbnVtZXJpY2FsbHkgZXF1YWxcbiAgICAgKiByZXN1bHQgZnJvbSBhcHBseWluZyB0aGUgc3RyaW5nIGNvbnN0cnVjdG9yIHRvIHRoZSBtZXRob2QncyBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBCaWdEZWNpbWFsYCwgdXNpbmdcbiAgICAgKiAgICAgICAgIGVuZ2luZWVyaW5nIG5vdGF0aW9uIGlmIGFuIGV4cG9uZW50IGlzIG5lZWRlZC5cbiAgICAgKi9cbiAgICB0b0VuZ2luZWVyaW5nU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXRTdHJpbmcoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFic29sdXRlIHZhbHVlIG9mIGEgYmlnaW50XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGJpZ0ludEFicyh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA8IEJpZ0RlY2ltYWwuemVyb0JpZ0ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC52YWx1ZU9mKCkgKiBCaWdEZWNpbWFsLm1pbnVzT25lQmlnSW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExheSBvdXQgdGhpcyBgQmlnRGVjaW1hbGAgaW50byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2kgYHRydWVgIGZvciBTY2llbnRpZmljIGV4cG9uZW50aWFsIG5vdGF0aW9uO1xuICAgICAqICAgICAgICAgICAgYGZhbHNlYCBmb3IgRW5naW5lZXJpbmdcbiAgICAgKiBAcmV0dXJuIHN0cmluZyB3aXRoIGNhbm9uaWNhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpc1xuICAgICAqIGBCaWdEZWNpbWFsYFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGxheW91dFN0cmluZyhzY2kpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlID09PSAwKSAvLyB6ZXJvIHNjYWxlIGlzIHRyaXZpYWxcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pbnRDb21wYWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSA/IHRoaXMuaW50Q29tcGFjdC50b1N0cmluZygpIDogdGhpcy5pbnRWYWwudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlID09PSAyICYmIHRoaXMuaW50Q29tcGFjdCA+PSAwICYmIHRoaXMuaW50Q29tcGFjdCA8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAvLyBjdXJyZW5jeSBmYXN0IHBhdGhcbiAgICAgICAgICAgIGNvbnN0IGxvd0ludCA9IHRoaXMuaW50Q29tcGFjdCAlIDEwMDtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hJbnQgPSBNYXRoLnRydW5jKHRoaXMuaW50Q29tcGFjdCAvIDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gKGhpZ2hJbnQudG9TdHJpbmcoKSArICcuJyArIEJpZ0RlY2ltYWwuRElHSVRfVEVOU1tsb3dJbnRdICsgQmlnRGVjaW1hbC5ESUdJVF9PTkVTW2xvd0ludF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2VmZjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gMDsgLy8gb2Zmc2V0IGlzIHRoZSBzdGFydGluZyBpbmRleCBmb3IgY29lZmYgYXJyYXlcbiAgICAgICAgLy8gR2V0IHRoZSBzaWduaWZpY2FuZCBhcyBhbiBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICBpZiAodGhpcy5pbnRDb21wYWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICBjb2VmZiA9IE1hdGguYWJzKHRoaXMuaW50Q29tcGFjdCkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZWZmID0gQmlnRGVjaW1hbC5iaWdJbnRBYnModGhpcy5pbnRWYWwpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc3RydWN0IGEgc3RyaW5nLlxuICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnNpZ251bSgpIDwgMCkgLy8gcHJlZml4ICctJyBpZiBuZWdhdGl2ZVxuICAgICAgICAgICAgc3RyICs9ICctJztcbiAgICAgICAgY29uc3QgY29lZmZMZW4gPSBjb2VmZi5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgIGxldCBhZGp1c3RlZCA9IC10aGlzLl9zY2FsZSArIChjb2VmZkxlbiAtIDEpO1xuICAgICAgICBpZiAoKHRoaXMuX3NjYWxlID49IDApICYmIChhZGp1c3RlZCA+PSAtNikpIHsgLy8gcGxhaW4gbnVtYmVyXG4gICAgICAgICAgICBsZXQgcGFkID0gdGhpcy5fc2NhbGUgLSBjb2VmZkxlbjsgLy8gY291bnQgb2YgcGFkZGluZyB6ZXJvc1xuICAgICAgICAgICAgaWYgKHBhZCA+PSAwKSB7IC8vIDAueHh4IGZvcm1cbiAgICAgICAgICAgICAgICBzdHIgKz0gJzAnO1xuICAgICAgICAgICAgICAgIHN0ciArPSAnLic7XG4gICAgICAgICAgICAgICAgZm9yICg7IHBhZCA+IDA7IHBhZC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnMCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciArPSBjb2VmZi5zdWJzdHIob2Zmc2V0LCBjb2VmZkxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8geHgueHggZm9ybVxuICAgICAgICAgICAgICAgIHN0ciArPSBjb2VmZi5zdWJzdHIob2Zmc2V0LCAtcGFkKTtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJy4nO1xuICAgICAgICAgICAgICAgIHN0ciArPSBjb2VmZi5zdWJzdHIoLXBhZCArIG9mZnNldCwgdGhpcy5fc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBFLW5vdGF0aW9uIGlzIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHNjaSkgeyAvLyBTY2llbnRpZmljIG5vdGF0aW9uXG4gICAgICAgICAgICAgICAgc3RyICs9IGNvZWZmW29mZnNldF07IC8vIGZpcnN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChjb2VmZkxlbiA+IDEpIHsgLy8gbW9yZSB0byBjb21lXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnLic7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBjb2VmZi5zdWJzdHIob2Zmc2V0ICsgMSwgY29lZmZMZW4gLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gRW5naW5lZXJpbmcgbm90YXRpb25cbiAgICAgICAgICAgICAgICBsZXQgc2lnID0gKGFkanVzdGVkICUgMyk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZyA8IDApXG4gICAgICAgICAgICAgICAgICAgIHNpZyArPSAzOyAvLyBbYWRqdXN0ZWQgd2FzIG5lZ2F0aXZlXVxuICAgICAgICAgICAgICAgIGFkanVzdGVkIC09IHNpZzsgLy8gbm93IGEgbXVsdGlwbGUgb2YgM1xuICAgICAgICAgICAgICAgIHNpZysrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpZ251bSgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2lnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICcwJzsgLy8gZXhwb25lbnQgaXMgYSBtdWx0aXBsZSBvZiB0aHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnMC4wMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJzAuMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VuZXhwZWN0ZWQgc2lnIHZhbHVlICcgKyBzaWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZyA+PSBjb2VmZkxlbikgeyAvLyBzaWduaWZpY2FuZCBhbGwgaW4gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY29lZmYuc3Vic3RyKG9mZnNldCwgY29lZmZMZW4pO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXkgbmVlZCBzb21lIHplcm9zLCB0b29cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNpZyAtIGNvZWZmTGVuOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyB4eC54eEUgZm9ybVxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY29lZmYuc3Vic3RyKG9mZnNldCwgc2lnKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9ICcuJztcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNvZWZmLnN1YnN0cihvZmZzZXQgKyBzaWcsIGNvZWZmTGVuIC0gc2lnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRqdXN0ZWQgIT09IDApIHsgLy8gWyFzY2kgY291bGQgaGF2ZSBtYWRlIDBdXG4gICAgICAgICAgICAgICAgc3RyICs9ICdFJztcbiAgICAgICAgICAgICAgICBpZiAoYWRqdXN0ZWQgPiAwKSAvLyBmb3JjZSBzaWduIGZvciBwb3NpdGl2ZVxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJysnO1xuICAgICAgICAgICAgICAgIHN0ciArPSBhZGp1c3RlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgQmlnRGVjaW1hbGBcbiAgICAgKiB3aXRob3V0IGFuIGV4cG9uZW50IGZpZWxkLiAgRm9yIHZhbHVlcyB3aXRoIGEgcG9zaXRpdmUgc2NhbGUsXG4gICAgICogdGhlIG51bWJlciBvZiBkaWdpdHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkZWNpbWFsIHBvaW50IGlzIHVzZWRcbiAgICAgKiB0byBpbmRpY2F0ZSBzY2FsZS4gIEZvciB2YWx1ZXMgd2l0aCBhIHplcm8gb3IgbmVnYXRpdmUgc2NhbGUsXG4gICAgICogdGhlIHJlc3VsdGluZyBzdHJpbmcgaXMgZ2VuZXJhdGVkIGFzIGlmIHRoZSB2YWx1ZSB3ZXJlXG4gICAgICogY29udmVydGVkIHRvIGEgbnVtZXJpY2FsbHkgZXF1YWwgdmFsdWUgd2l0aCB6ZXJvIHNjYWxlIGFuZCBhc1xuICAgICAqIGlmIGFsbCB0aGUgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIHplcm8gc2NhbGUgdmFsdWUgd2VyZSBwcmVzZW50XG4gICAgICogaW4gdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIFRoZSBlbnRpcmUgc3RyaW5nIGlzIHByZWZpeGVkIGJ5IGEgbWludXMgc2lnbiBjaGFyYWN0ZXIgJy0nXG4gICAgICogKDxjb2RlPicmIzkyO3UwMDJEJzwvY29kZT4pIGlmIHRoZSB1bnNjYWxlZCB2YWx1ZSBpcyBsZXNzIHRoYW5cbiAgICAgKiB6ZXJvLiBObyBzaWduIGNoYXJhY3RlciBpcyBwcmVmaXhlZCBpZiB0aGUgdW5zY2FsZWQgdmFsdWUgaXNcbiAgICAgKiB6ZXJvIG9yIHBvc2l0aXZlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGlmIHRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgcGFzc2VkIHRvIHRoZVxuICAgICAqIHN0cmluZyBjb25zdHJ1Y3Rvciwgb25seSB0aGVcbiAgICAgKiBudW1lcmljYWwgdmFsdWUgb2YgdGhpcyBgQmlnRGVjaW1hbGAgd2lsbCBuZWNlc3NhcmlseSBiZVxuICAgICAqIHJlY292ZXJlZDsgdGhlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBuZXcgYEJpZ0RlY2ltYWxgXG4gICAgICogbWF5IGhhdmUgYSBkaWZmZXJlbnQgc2NhbGUuICBJbiBwYXJ0aWN1bGFyLCBpZiB0aGlzXG4gICAgICogYEJpZ0RlY2ltYWxgIGhhcyBhIG5lZ2F0aXZlIHNjYWxlLCB0aGUgc3RyaW5nIHJlc3VsdGluZ1xuICAgICAqIGZyb20gdGhpcyBtZXRob2Qgd2lsbCBoYXZlIGEgc2NhbGUgb2YgemVybyB3aGVuIHByb2Nlc3NlZCBieVxuICAgICAqIHRoZSBzdHJpbmcgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYEJpZ0RlY2ltYWxgXG4gICAgICogd2l0aG91dCBhbiBleHBvbmVudCBmaWVsZC5cbiAgICAgKiBAc2VlIHtAbGluayB0b1N0cmluZ31cbiAgICAgKiBAc2VlIHtAbGluayB0b0VuZ2luZWVyaW5nU3RyaW5nfVxuICAgICAqL1xuICAgIHRvUGxhaW5TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludENvbXBhY3QudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludFZhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSA8IDApIHsgLy8gTm8gZGVjaW1hbCBwb2ludFxuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhaWxpbmdaZXJvcyA9IHRoaXMuY2hlY2tTY2FsZSgtdGhpcy5fc2NhbGUpO1xuICAgICAgICAgICAgbGV0IGJ1ZiA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50Q29tcGFjdCAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgIGJ1ZiArPSB0aGlzLmludENvbXBhY3QudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZiArPSB0aGlzLmludFZhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbGluZ1plcm9zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWYgKz0gJzAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBpZiAodGhpcy5pbnRDb21wYWN0ICE9PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICBzdHIgPSBNYXRoLmFicyh0aGlzLmludENvbXBhY3QpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBCaWdEZWNpbWFsLmJpZ0ludEFicyh0aGlzLmludFZhbCkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5nZXRWYWx1ZVN0cmluZyh0aGlzLnNpZ251bSgpLCBzdHIsIHRoaXMuX3NjYWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRpZ2l0LmRpZ2l0IHN0cmluZ1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRWYWx1ZVN0cmluZyhzaWdudW0sIGludFN0cmluZywgc2NhbGUpIHtcbiAgICAgICAgLyogSW5zZXJ0IGRlY2ltYWwgcG9pbnQgKi9cbiAgICAgICAgbGV0IGJ1ZiA9ICcnO1xuICAgICAgICBjb25zdCBpbnNlcnRpb25Qb2ludCA9IGludFN0cmluZy5sZW5ndGggLSBzY2FsZTtcbiAgICAgICAgaWYgKGluc2VydGlvblBvaW50ID09PSAwKSB7IC8qIFBvaW50IGdvZXMgcmlnaHQgYmVmb3JlIGludFZhbCAqL1xuICAgICAgICAgICAgcmV0dXJuIChzaWdudW0gPCAwID8gJy0wLicgOiAnMC4nKSArIGludFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnNlcnRpb25Qb2ludCA+IDApIHsgLyogUG9pbnQgZ29lcyBpbnNpZGUgaW50VmFsICovXG4gICAgICAgICAgICBidWYgPSBpbnRTdHJpbmcuc2xpY2UoMCwgaW5zZXJ0aW9uUG9pbnQpICsgJy4nICsgaW50U3RyaW5nLnNsaWNlKGluc2VydGlvblBvaW50KTtcbiAgICAgICAgICAgIGlmIChzaWdudW0gPCAwKVxuICAgICAgICAgICAgICAgIGJ1ZiA9ICctJyArIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLyogV2UgbXVzdCBpbnNlcnQgemVyb3MgYmV0d2VlbiBwb2ludCBhbmQgaW50VmFsICovXG4gICAgICAgICAgICBidWYgKz0gc2lnbnVtIDwgMCA/ICctMC4nIDogJzAuJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgLWluc2VydGlvblBvaW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWYgKz0gJzAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmICs9IGludFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgYEJpZ0RlY2ltYWxgIHRvIGEgYEJpZ0ludGAuXG4gICAgICogQW55IGZyYWN0aW9uYWwgcGFydCBvZiB0aGlzIHdpbGwgYmUgZGlzY2FyZGVkLiAgTm90ZSB0aGF0IHRoaXNcbiAgICAgKiBjb252ZXJzaW9uIGNhbiBsb3NlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwcmVjaXNpb24gb2YgdGhlXG4gICAgICogYEJpZ0RlY2ltYWxgIHZhbHVlLlxuICAgICAqXG4gICAgICogVG8gaGF2ZSBhbiBleGNlcHRpb24gdGhyb3duIGlmIHRoZSBjb252ZXJzaW9uIGlzIGluZXhhY3QgKGluXG4gICAgICogb3RoZXIgd29yZHMgaWYgYSBub256ZXJvIGZyYWN0aW9uYWwgcGFydCBpcyBkaXNjYXJkZWQpLCB1c2UgdGhlXG4gICAgICoge0BsaW5rIHRvQmlnSW50RXhhY3R9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpcyBgQmlnRGVjaW1hbGAgY29udmVydGVkIHRvIGEgYEJpZ0ludGAuXG4gICAgICovXG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIC8vIGZvcmNlIHRvIGFuIGludGVnZXIsIHF1aWV0bHlcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0U2NhbGUoMCwgUm91bmRpbmdNb2RlLkRPV04pLmluZmxhdGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgYEJpZ0RlY2ltYWxgIHRvIGEgYEJpZ0ludGAsXG4gICAgICogY2hlY2tpbmcgZm9yIGxvc3QgaW5mb3JtYXRpb24uICBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoaXNcbiAgICAgKiBgQmlnRGVjaW1hbGAgaGFzIGEgbm9uemVybyBmcmFjdGlvbmFsIHBhcnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXMgYEJpZ0RlY2ltYWxgIGNvbnZlcnRlZCB0byBhIGBCaWdJbnRgLlxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBgdGhpc2AgaGFzIGEgbm9uemVybyBmcmFjdGlvbmFsIHBhcnQuXG4gICAgICovXG4gICAgdG9CaWdJbnRFeGFjdCgpIHtcbiAgICAgICAgLy8gcm91bmQgdG8gYW4gaW50ZWdlciwgd2l0aCBFeGNlcHRpb24gaWYgZGVjaW1hbCBwYXJ0IG5vbi0wXG4gICAgICAgIHJldHVybiB0aGlzLnNldFNjYWxlKDAsIFJvdW5kaW5nTW9kZS5VTk5FQ0VTU0FSWSkuaW5mbGF0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBgQmlnSW50YCB2YWx1ZSBieSBudW1iZXIgdmFsdWUgYW5kXG4gICAgICogZG8gcm91bmRpbmcgYmFzZWQgb24gdGhlIHBhc3NlZCBpbiByb3VuZGluZ01vZGUuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGRpdmlkZUFuZFJvdW5kNShiZGl2aWRlbmQsIGxkaXZpc29yLCByb3VuZGluZ01vZGUpIHtcbiAgICAgICAgY29uc3QgZGl2aWRlbmRTaWdudW0gPSBCaWdEZWNpbWFsLmJpZ0ludFNpZ251bShiZGl2aWRlbmQpO1xuICAgICAgICBjb25zdCBkaXZpc29yTmVnYXRpdmUgPSBsZGl2aXNvciA8IDA7XG4gICAgICAgIGlmIChkaXZpZGVuZFNpZ251bSA9PT0gLTEpXG4gICAgICAgICAgICBiZGl2aWRlbmQgPSBiZGl2aWRlbmQudmFsdWVPZigpICogQmlnRGVjaW1hbC5taW51c09uZUJpZ0ludDtcbiAgICAgICAgaWYgKGRpdmlzb3JOZWdhdGl2ZSlcbiAgICAgICAgICAgIGxkaXZpc29yICo9IC0xO1xuICAgICAgICBsZXQgbXEgPSBiZGl2aWRlbmQudmFsdWVPZigpIC8gQmlnSW50KGxkaXZpc29yKTtcbiAgICAgICAgbGV0IHI7XG4gICAgICAgIGNvbnN0IGJEaXZpZGVuZE51bWJlciA9IE51bWJlcihiZGl2aWRlbmQpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIoYkRpdmlkZW5kTnVtYmVyKSkge1xuICAgICAgICAgICAgciA9IGJEaXZpZGVuZE51bWJlciAlIGxkaXZpc29yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgciA9IE51bWJlcihiZGl2aWRlbmQudmFsdWVPZigpICUgQmlnSW50KGxkaXZpc29yKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb3JkIHJlbWFpbmRlciBpcyB6ZXJvIG9yIG5vdFxuICAgICAgICBjb25zdCBpc1JlbWFpbmRlclplcm8gPSAociA9PT0gMCk7XG4gICAgICAgIC8vIHF1b3RpZW50IHNpZ25cbiAgICAgICAgY29uc3QgcXNpZ24gPSBkaXZpc29yTmVnYXRpdmUgPyAoZGl2aWRlbmRTaWdudW0gKiAtMSkgOiBkaXZpZGVuZFNpZ251bTtcbiAgICAgICAgaWYgKCFpc1JlbWFpbmRlclplcm8pIHtcbiAgICAgICAgICAgIGlmIChCaWdEZWNpbWFsLm5lZWRJbmNyZW1lbnQzKGxkaXZpc29yLCByb3VuZGluZ01vZGUsIHFzaWduLCBtcSwgcikpIHtcbiAgICAgICAgICAgICAgICBtcSArPSBCaWdEZWNpbWFsLm9uZUJpZ0ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXEgKiBCaWdJbnQocXNpZ24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGBCaWdJbnRgIHZhbHVlIGJ5IGBCaWdJbnRgIHZhbHVlIGFuZFxuICAgICAqIGRvIHJvdW5kaW5nIGJhc2VkIG9uIHRoZSBwYXNzZWQgaW4gcm91bmRpbmdNb2RlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBkaXZpZGVBbmRSb3VuZDYoYmRpdmlkZW5kLCBiZGl2aXNvciwgcm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGNvbnN0IGJkaXZpZGVuZFNpZ251bSA9IEJpZ0RlY2ltYWwuYmlnSW50U2lnbnVtKGJkaXZpZGVuZCk7XG4gICAgICAgIGNvbnN0IGJkaXZpc29yU2lnbnVtID0gQmlnRGVjaW1hbC5iaWdJbnRTaWdudW0oYmRpdmlzb3IpO1xuICAgICAgICBpZiAoYmRpdmlkZW5kIDwgQmlnRGVjaW1hbC56ZXJvQmlnSW50KVxuICAgICAgICAgICAgYmRpdmlkZW5kID0gYmRpdmlkZW5kLnZhbHVlT2YoKSAqIEJpZ0RlY2ltYWwubWludXNPbmVCaWdJbnQ7XG4gICAgICAgIGlmIChiZGl2aXNvciA8IEJpZ0RlY2ltYWwuemVyb0JpZ0ludClcbiAgICAgICAgICAgIGJkaXZpc29yID0gYmRpdmlzb3IudmFsdWVPZigpICogQmlnRGVjaW1hbC5taW51c09uZUJpZ0ludDtcbiAgICAgICAgbGV0IG1xID0gYmRpdmlkZW5kLnZhbHVlT2YoKSAvIGJkaXZpc29yLnZhbHVlT2YoKTtcbiAgICAgICAgY29uc3QgbXIgPSBiZGl2aWRlbmQudmFsdWVPZigpICUgYmRpdmlzb3IudmFsdWVPZigpO1xuICAgICAgICBjb25zdCBpc1JlbWFpbmRlclplcm8gPSBtciA9PT0gQmlnRGVjaW1hbC56ZXJvQmlnSW50OyAvLyByZWNvcmQgcmVtYWluZGVyIGlzIHplcm8gb3Igbm90XG4gICAgICAgIGNvbnN0IHFzaWduID0gKGJkaXZpZGVuZFNpZ251bSAhPT0gYmRpdmlzb3JTaWdudW0pID8gLTEgOiAxOyAvLyBxdW90aWVudCBzaWduXG4gICAgICAgIGlmICghaXNSZW1haW5kZXJaZXJvKSB7XG4gICAgICAgICAgICBpZiAoQmlnRGVjaW1hbC5uZWVkSW5jcmVtZW50MihiZGl2aXNvciwgcm91bmRpbmdNb2RlLCBxc2lnbiwgbXEsIG1yKSkge1xuICAgICAgICAgICAgICAgIG1xICs9IEJpZ0RlY2ltYWwub25lQmlnSW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtcSAqIEJpZ0ludChxc2lnbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQmlnRGVjaW1hbGAgd2hvc2UgdmFsdWUgaXMgYCh4cyAvXG4gICAgICogeXMpYCwgd2l0aCByb3VuZGluZyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRleHQgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBGYXN0IHBhdGggLSB1c2VkIG9ubHkgd2hlbiAoeHNjYWxlIDw9IHlzY2FsZSAmJiB5c2NhbGUgPCAxNVxuICAgICAqICYmIG1jLnByZXNpc2lvbjwxNSlcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZGl2aWRlU21hbGxGYXN0UGF0aCh4cywgeHNjYWxlLCB5cywgeXNjYWxlLCBwcmVmZXJyZWRTY2FsZSwgbWMpIHtcbiAgICAgICAgY29uc3QgbWNwID0gbWMucHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBtYy5yb3VuZGluZ01vZGU7XG4gICAgICAgIGNvbnN0IHhyYWlzZSA9IHlzY2FsZSAtIHhzY2FsZTsgLy8geHJhaXNlID49MFxuICAgICAgICBjb25zdCBzY2FsZWRYID0gKHhyYWlzZSA9PT0gMCkgPyB4cyA6IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeHMsIHhyYWlzZSk7IC8vIGNhbid0IG92ZXJmbG93IGhlcmUhXG4gICAgICAgIGxldCBxdW90aWVudDtcbiAgICAgICAgY29uc3QgY21wID0gQmlnRGVjaW1hbC5pbnRlZ2VyQ29tcGFyZU1hZ25pdHVkZShzY2FsZWRYLCB5cyk7XG4gICAgICAgIGlmIChjbXAgPiAwKSB7IC8vIHNhdGlzZnkgY29uc3RyYWludCAoYilcbiAgICAgICAgICAgIHlzY2FsZSAtPSAxOyAvLyBbdGhhdCBpcywgZGl2aXNvciAqPSAxMF1cbiAgICAgICAgICAgIGNvbnN0IHNjbCA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUgKyB5c2NhbGUgLSB4c2NhbGUgKyBtY3ApO1xuICAgICAgICAgICAgaWYgKEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8obWNwICsgeXNjYWxlIC0geHNjYWxlKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYWlzZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8obWNwICsgeXNjYWxlIC0geHNjYWxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZWRYcyA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeHMsIHJhaXNlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGVkWHMgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGllbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKG1jcCAtIDEpID49IDAgJiYgKG1jcCAtIDEpIDwgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGllbnQgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kNChCaWdJbnQoQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFW21jcCAtIDFdKSAqIEJpZ0ludChzY2FsZWRYKSwgeXMsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1b3RpZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYiA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjIoc2NhbGVkWCwgbWNwIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQ0KHJiLCB5cywgc2NsLCByb3VuZGluZ01vZGUsIEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGllbnQgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMihzY2FsZWRYcywgeXMsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHhzY2FsZSAtIG1jcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1NjYWxlID09PSB5c2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGllbnQgPSBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMih4cywgeXMsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWlzZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8obmV3U2NhbGUgLSB5c2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsZWRZcyA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeXMsIHJhaXNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlZFlzID09PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYiA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjIoeXMsIHJhaXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDMoQmlnSW50KHhzKSwgcmIsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQyKHhzLCBzY2FsZWRZcywgc2NsLCByb3VuZGluZ01vZGUsIEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFicyhzY2FsZWRYKSA8PSBhYnMoeXMpXG4gICAgICAgICAgICAvLyByZXN1bHQgaXMgXCJzY2FsZWRYICogMTBebXNwIC8geXNcIlxuICAgICAgICAgICAgY29uc3Qgc2NsID0gQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhwcmVmZXJyZWRTY2FsZSArIHlzY2FsZSAtIHhzY2FsZSArIG1jcCk7XG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYWJzKHNjYWxlWCk9PSBhYnMoeXMpID0+IHJlc3VsdCB3aWxsIGJlIHNjYWxlZCAxMF5tY3AgKyBjb3JyZWN0IHNpZ25cbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwucm91bmRlZFRlblBvd2VyKCgoc2NhbGVkWCA8IDApID09PSAoeXMgPCAwKSkgPyAxIDogLTEsIG1jcCwgc2NsLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhYnMoc2NhbGVkWCkgPCBhYnMoeXMpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVkWHMgPSBCaWdEZWNpbWFsLmludGVnZXJNdWx0aXBseVBvd2VyVGVuKHNjYWxlZFgsIG1jcCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlZFhzID09PSBCaWdEZWNpbWFsLklORkxBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1jcCA8IEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDQoQmlnSW50KEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRVttY3BdKSAqIEJpZ0ludChzY2FsZWRYKSwgeXMsIHNjbCwgcm91bmRpbmdNb2RlLCBCaWdEZWNpbWFsLmNoZWNrU2NhbGVOb25aZXJvKHByZWZlcnJlZFNjYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1b3RpZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYiA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjIoc2NhbGVkWCwgbWNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDQocmIsIHlzLCBzY2wsIHJvdW5kaW5nTW9kZSwgQmlnRGVjaW1hbC5jaGVja1NjYWxlTm9uWmVybyhwcmVmZXJyZWRTY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdW90aWVudCA9IEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQyKHNjYWxlZFhzLCB5cywgc2NsLCByb3VuZGluZ01vZGUsIEJpZ0RlY2ltYWwuY2hlY2tTY2FsZU5vblplcm8ocHJlZmVycmVkU2NhbGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9Sb3VuZCwgaGVyZSwgb25seSBhZmZlY3RzIDEwMDAwMDAwMDAgY2FzZS5cbiAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZG9Sb3VuZChxdW90aWVudCwgbWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgZGl2aWRlQW5kUm91bmQgZm9yIGxkaXZpZGVuZCoxMF5yYWlzZSAvIGRpdmlzb3JcbiAgICAgKiB3aGVuIGFicyhkaXZpZGVuZCk9PWFicyhkaXZpc29yKTtcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgcm91bmRlZFRlblBvd2VyKHFzaWduLCByYWlzZSwgc2NhbGUsIHByZWZlcnJlZFNjYWxlKSB7XG4gICAgICAgIGlmIChzY2FsZSA+IHByZWZlcnJlZFNjYWxlKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gc2NhbGUgLSBwcmVmZXJyZWRTY2FsZTtcbiAgICAgICAgICAgIGlmIChkaWZmIDwgcmFpc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5zY2FsZWRUZW5Qb3cocmFpc2UgLSBkaWZmLCBxc2lnbiwgcHJlZmVycmVkU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUludGVnZXIzKHFzaWduLCBzY2FsZSAtIHJhaXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLnNjYWxlZFRlblBvdyhyYWlzZSwgcXNpZ24sIHNjYWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIHNjYWxlZFRlblBvdyhuLCBzaWduLCBzY2FsZSkge1xuICAgICAgICBpZiAobiA8IEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5mcm9tSW50ZWdlcjMoc2lnbiAqIEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRVtuXSwgc2NhbGUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB1bnNjYWxlZFZhbCA9IEJpZ0ludCgxMCkgKiogQmlnSW50KG4pO1xuICAgICAgICAgICAgaWYgKHNpZ24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdW5zY2FsZWRWYWwgPSB1bnNjYWxlZFZhbCAqIEJpZ0RlY2ltYWwubWludXNPbmVCaWdJbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwodW5zY2FsZWRWYWwsIEJpZ0RlY2ltYWwuSU5GTEFURUQsIHNjYWxlLCBuICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBOb3JtYWxpemUgZGl2aWRlbmQgJiBkaXZpc29yIHNvIHRoYXQgYm90aCBmYWxsIGludG8gWzAuMSwgMC45OTkuLi5dXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVNYWduaXR1ZGVOb3JtYWxpemVkKHhzLCB4c2NhbGUsIHlzLCB5c2NhbGUpIHtcbiAgICAgICAgY29uc3Qgc2RpZmYgPSB4c2NhbGUgLSB5c2NhbGU7XG4gICAgICAgIGlmIChzZGlmZiAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKHNkaWZmIDwgMCkge1xuICAgICAgICAgICAgICAgIHhzID0gQmlnRGVjaW1hbC5pbnRlZ2VyTXVsdGlwbHlQb3dlclRlbih4cywgLXNkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlzID0gQmlnRGVjaW1hbC5pbnRlZ2VyTXVsdGlwbHlQb3dlclRlbih5cywgc2RpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4cyAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRClcbiAgICAgICAgICAgIHJldHVybiAoeXMgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpID8gQmlnRGVjaW1hbC5pbnRlZ2VyQ29tcGFyZU1hZ25pdHVkZSh4cywgeXMpIDogLTE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIE5vcm1hbGl6ZSBkaXZpZGVuZCAmIGRpdmlzb3Igc28gdGhhdCBib3RoIGZhbGwgaW50byBbMC4xLCAwLjk5OS4uLl1cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZU1hZ25pdHVkZU5vcm1hbGl6ZWQyKHhzLCB4c2NhbGUsIHlzLCB5c2NhbGUpIHtcbiAgICAgICAgaWYgKHhzID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjb25zdCBzZGlmZiA9IHhzY2FsZSAtIHlzY2FsZTtcbiAgICAgICAgaWYgKHNkaWZmIDwgMCkge1xuICAgICAgICAgICAgaWYgKEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeHMsIC1zZGlmZikgPT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5iaWdJbnRDb21wYXJlTWFnbml0dWRlKEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjIoeHMsIC1zZGlmZiksIHlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgTm9ybWFsaXplIGRpdmlkZW5kICYgZGl2aXNvciBzbyB0aGF0IGJvdGggZmFsbCBpbnRvIFswLjEsIDAuOTk5Li4uXVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlTWFnbml0dWRlTm9ybWFsaXplZDMoeHMsIHhzY2FsZSwgeXMsIHlzY2FsZSkge1xuICAgICAgICBjb25zdCBzZGlmZiA9IHhzY2FsZSAtIHlzY2FsZTtcbiAgICAgICAgaWYgKHNkaWZmIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuYmlnSW50Q29tcGFyZU1hZ25pdHVkZShCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4zKHhzLCAtc2RpZmYpLCB5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIHNkaWZmID49IDBcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmJpZ0ludENvbXBhcmVNYWduaXR1ZGUoeHMsIEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjMoeXMsIHNkaWZmKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBkaXZpZGU3KGRpdmlkZW5kLCBkaXZpZGVuZFNjYWxlLCBkaXZpc29yLCBkaXZpc29yU2NhbGUsIHNjYWxlLCByb3VuZGluZ01vZGUpIHtcbiAgICAgICAgaWYgKEJpZ0RlY2ltYWwuY2hlY2tTY2FsZTIoZGl2aWRlbmQsIHNjYWxlICsgZGl2aXNvclNjYWxlKSA+IGRpdmlkZW5kU2NhbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjYWxlID0gc2NhbGUgKyBkaXZpc29yU2NhbGU7XG4gICAgICAgICAgICBjb25zdCByYWlzZSA9IG5ld1NjYWxlIC0gZGl2aWRlbmRTY2FsZTtcbiAgICAgICAgICAgIGlmIChyYWlzZSA8IEJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeHMgPSBkaXZpZGVuZDtcbiAgICAgICAgICAgICAgICBpZiAoKHhzID0gQmlnRGVjaW1hbC5pbnRlZ2VyTXVsdGlwbHlQb3dlclRlbih4cywgcmFpc2UpKSAhPT0gQmlnRGVjaW1hbC5JTkZMQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDIoeHMsIGRpdmlzb3IsIHNjYWxlLCByb3VuZGluZ01vZGUsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY2FsZWREaXZpZGVuZCA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjIoZGl2aWRlbmQsIHJhaXNlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kNChzY2FsZWREaXZpZGVuZCwgZGl2aXNvciwgc2NhbGUsIHJvdW5kaW5nTW9kZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGUyKGRpdmlzb3IsIGRpdmlkZW5kU2NhbGUgLSBzY2FsZSk7XG4gICAgICAgICAgICBjb25zdCByYWlzZSA9IG5ld1NjYWxlIC0gZGl2aXNvclNjYWxlO1xuICAgICAgICAgICAgaWYgKHJhaXNlIDwgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB5cyA9IGRpdmlzb3I7XG4gICAgICAgICAgICAgICAgaWYgKCh5cyA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeXMsIHJhaXNlKSkgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQyKGRpdmlkZW5kLCB5cywgc2NhbGUsIHJvdW5kaW5nTW9kZSwgc2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZERpdmlzb3IgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4yKGRpdmlzb3IsIHJhaXNlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMyhCaWdJbnQoZGl2aWRlbmQpLCBzY2FsZWREaXZpc29yLCBzY2FsZSwgcm91bmRpbmdNb2RlLCBzY2FsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBkaXZpZGU4KGRpdmlkZW5kLCBkaXZpZGVuZFNjYWxlLCBkaXZpc29yLCBkaXZpc29yU2NhbGUsIHNjYWxlLCByb3VuZGluZ01vZGUpIHtcbiAgICAgICAgaWYgKEJpZ0RlY2ltYWwuY2hlY2tTY2FsZTIoZGl2aWRlbmQsIHNjYWxlICsgZGl2aXNvclNjYWxlKSA+IGRpdmlkZW5kU2NhbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjYWxlID0gc2NhbGUgKyBkaXZpc29yU2NhbGU7XG4gICAgICAgICAgICBjb25zdCByYWlzZSA9IG5ld1NjYWxlIC0gZGl2aWRlbmRTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZERpdmlkZW5kID0gQmlnRGVjaW1hbC5iaWdNdWx0aXBseVBvd2VyVGVuMihkaXZpZGVuZCwgcmFpc2UpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQzKHNjYWxlZERpdmlkZW5kLCBkaXZpc29yLCBzY2FsZSwgcm91bmRpbmdNb2RlLCBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTY2FsZSA9IEJpZ0RlY2ltYWwuY2hlY2tTY2FsZTMoZGl2aXNvciwgZGl2aWRlbmRTY2FsZSAtIHNjYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IHJhaXNlID0gbmV3U2NhbGUgLSBkaXZpc29yU2NhbGU7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWREaXZpc29yID0gQmlnRGVjaW1hbC5iaWdNdWx0aXBseVBvd2VyVGVuMyhkaXZpc29yLCByYWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDMoQmlnSW50KGRpdmlkZW5kKSwgc2NhbGVkRGl2aXNvciwgc2NhbGUsIHJvdW5kaW5nTW9kZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgZGl2aWRlOShkaXZpZGVuZCwgZGl2aWRlbmRTY2FsZSwgZGl2aXNvciwgZGl2aXNvclNjYWxlLCBzY2FsZSwgcm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChCaWdEZWNpbWFsLmNoZWNrU2NhbGUzKGRpdmlkZW5kLCBzY2FsZSArIGRpdmlzb3JTY2FsZSkgPiBkaXZpZGVuZFNjYWxlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTY2FsZSA9IHNjYWxlICsgZGl2aXNvclNjYWxlO1xuICAgICAgICAgICAgY29uc3QgcmFpc2UgPSBuZXdTY2FsZSAtIGRpdmlkZW5kU2NhbGU7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWREaXZpZGVuZCA9IEJpZ0RlY2ltYWwuYmlnTXVsdGlwbHlQb3dlclRlbjMoZGl2aWRlbmQsIHJhaXNlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kNChzY2FsZWREaXZpZGVuZCwgZGl2aXNvciwgc2NhbGUsIHJvdW5kaW5nTW9kZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSBCaWdEZWNpbWFsLmNoZWNrU2NhbGUyKGRpdmlzb3IsIGRpdmlkZW5kU2NhbGUgLSBzY2FsZSk7XG4gICAgICAgICAgICBjb25zdCByYWlzZSA9IG5ld1NjYWxlIC0gZGl2aXNvclNjYWxlO1xuICAgICAgICAgICAgaWYgKHJhaXNlIDwgQmlnRGVjaW1hbC5URU5fUE9XRVJTX1RBQkxFLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB5cyA9IGRpdmlzb3I7XG4gICAgICAgICAgICAgICAgaWYgKCh5cyA9IEJpZ0RlY2ltYWwuaW50ZWdlck11bHRpcGx5UG93ZXJUZW4oeXMsIHJhaXNlKSkgIT09IEJpZ0RlY2ltYWwuSU5GTEFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0RlY2ltYWwuZGl2aWRlQW5kUm91bmQ0KGRpdmlkZW5kLCB5cywgc2NhbGUsIHJvdW5kaW5nTW9kZSwgc2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZERpdmlzb3IgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4yKGRpdmlzb3IsIHJhaXNlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMyhkaXZpZGVuZCwgc2NhbGVkRGl2aXNvciwgc2NhbGUsIHJvdW5kaW5nTW9kZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgZGl2aWRlMTAoZGl2aWRlbmQsIGRpdmlkZW5kU2NhbGUsIGRpdmlzb3IsIGRpdmlzb3JTY2FsZSwgc2NhbGUsIHJvdW5kaW5nTW9kZSkge1xuICAgICAgICBpZiAoQmlnRGVjaW1hbC5jaGVja1NjYWxlMyhkaXZpZGVuZCwgc2NhbGUgKyBkaXZpc29yU2NhbGUpID4gZGl2aWRlbmRTY2FsZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSBzY2FsZSArIGRpdmlzb3JTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHJhaXNlID0gbmV3U2NhbGUgLSBkaXZpZGVuZFNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkRGl2aWRlbmQgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4zKGRpdmlkZW5kLCByYWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnRGVjaW1hbC5kaXZpZGVBbmRSb3VuZDMoc2NhbGVkRGl2aWRlbmQsIGRpdmlzb3IsIHNjYWxlLCByb3VuZGluZ01vZGUsIHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjYWxlID0gQmlnRGVjaW1hbC5jaGVja1NjYWxlMyhkaXZpc29yLCBkaXZpZGVuZFNjYWxlIC0gc2NhbGUpO1xuICAgICAgICAgICAgY29uc3QgcmFpc2UgPSBuZXdTY2FsZSAtIGRpdmlzb3JTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZERpdmlzb3IgPSBCaWdEZWNpbWFsLmJpZ011bHRpcGx5UG93ZXJUZW4zKGRpdmlzb3IsIHJhaXNlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdEZWNpbWFsLmRpdmlkZUFuZFJvdW5kMyhkaXZpZGVuZCwgc2NhbGVkRGl2aXNvciwgc2NhbGUsIHJvdW5kaW5nTW9kZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CaWdEZWNpbWFsID0gQmlnRGVjaW1hbDtcbi8qKiBAaW50ZXJuYWwgKi9cbkJpZ0RlY2ltYWwuemVyb0JpZ0ludCA9IEJpZ0ludCgwKTtcbi8qKiBAaW50ZXJuYWwgKi9cbkJpZ0RlY2ltYWwub25lQmlnSW50ID0gQmlnSW50KDEpO1xuLyoqIEBpbnRlcm5hbCAqL1xuQmlnRGVjaW1hbC50d29CaWdJbnQgPSBCaWdJbnQoMik7XG4vKiogQGludGVybmFsICovXG5CaWdEZWNpbWFsLm1pbnVzT25lQmlnSW50ID0gQmlnSW50KC0xKTtcbi8qKlxuICogU2VudGluZWwgdmFsdWUgZm9yIHtAbGluayBpbnRDb21wYWN0fSBpbmRpY2F0aW5nIHRoZVxuICogc2lnbmlmaWNhbmQgaW5mb3JtYXRpb24gaXMgb25seSBhdmFpbGFibGUgZnJvbSBpbnRWYWwuXG4gKiBAaW50ZXJuYWxcbiAqL1xuQmlnRGVjaW1hbC5JTkZMQVRFRCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuLyoqIEBpbnRlcm5hbCAqL1xuQmlnRGVjaW1hbC5JTkZMQVRFRF9CSUdJTlQgPSBCaWdJbnQoQmlnRGVjaW1hbC5JTkZMQVRFRCk7XG4vKiogQGludGVybmFsICovXG5CaWdEZWNpbWFsLk1BWF9JTlRfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuLyoqIEBpbnRlcm5hbCAqL1xuQmlnRGVjaW1hbC5NSU5fSU5UX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG4vKiogQGludGVybmFsICovXG5CaWdEZWNpbWFsLk1BWF9DT01QQUNUX0RJR0lUUyA9IDE1O1xuLyoqIEBpbnRlcm5hbCAqL1xuQmlnRGVjaW1hbC5aRVJPX1RIUk9VR0hfVEVOID0gW1xuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgMCwgMSksXG4gICAgbmV3IEJpZ0RlY2ltYWwoQmlnRGVjaW1hbC5vbmVCaWdJbnQsIDEsIDAsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwudHdvQmlnSW50LCAyLCAwLCAxKSxcbiAgICBuZXcgQmlnRGVjaW1hbChCaWdJbnQoMyksIDMsIDAsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0ludCg0KSwgNCwgMCwgMSksXG4gICAgbmV3IEJpZ0RlY2ltYWwoQmlnSW50KDUpLCA1LCAwLCAxKSxcbiAgICBuZXcgQmlnRGVjaW1hbChCaWdJbnQoNiksIDYsIDAsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0ludCg3KSwgNywgMCwgMSksXG4gICAgbmV3IEJpZ0RlY2ltYWwoQmlnSW50KDgpLCA4LCAwLCAxKSxcbiAgICBuZXcgQmlnRGVjaW1hbChCaWdJbnQoOSksIDksIDAsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0ludCgxMCksIDEwLCAwLCAyKSxcbl07XG4vKiogQGludGVybmFsICovXG5CaWdEZWNpbWFsLlpFUk8gPSBCaWdEZWNpbWFsLlpFUk9fVEhST1VHSF9URU5bMF07XG4vKiogQGludGVybmFsICovXG5CaWdEZWNpbWFsLk9ORSA9IEJpZ0RlY2ltYWwuWkVST19USFJPVUdIX1RFTlsxXTtcbi8qKiBAaW50ZXJuYWwgKi9cbkJpZ0RlY2ltYWwuWkVST19TQ0FMRURfQlkgPSBbXG4gICAgQmlnRGVjaW1hbC5aRVJPX1RIUk9VR0hfVEVOWzBdLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgMSwgMSksXG4gICAgbmV3IEJpZ0RlY2ltYWwoQmlnRGVjaW1hbC56ZXJvQmlnSW50LCAwLCAyLCAxKSxcbiAgICBuZXcgQmlnRGVjaW1hbChCaWdEZWNpbWFsLnplcm9CaWdJbnQsIDAsIDMsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgNCwgMSksXG4gICAgbmV3IEJpZ0RlY2ltYWwoQmlnRGVjaW1hbC56ZXJvQmlnSW50LCAwLCA1LCAxKSxcbiAgICBuZXcgQmlnRGVjaW1hbChCaWdEZWNpbWFsLnplcm9CaWdJbnQsIDAsIDYsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgNywgMSksXG4gICAgbmV3IEJpZ0RlY2ltYWwoQmlnRGVjaW1hbC56ZXJvQmlnSW50LCAwLCA4LCAxKSxcbiAgICBuZXcgQmlnRGVjaW1hbChCaWdEZWNpbWFsLnplcm9CaWdJbnQsIDAsIDksIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgMTAsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgMTEsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgMTIsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgMTMsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgMTQsIDEpLFxuICAgIG5ldyBCaWdEZWNpbWFsKEJpZ0RlY2ltYWwuemVyb0JpZ0ludCwgMCwgMTUsIDEpLFxuXTtcbi8qKiBAaW50ZXJuYWwgKi9cbkJpZ0RlY2ltYWwuVEVOX1BPV0VSU19UQUJMRSA9IFtcbiAgICAxLFxuICAgIDEwLFxuICAgIDEwMCxcbiAgICAxMDAwLFxuICAgIDEwMDAwLFxuICAgIDEwMDAwMCxcbiAgICAxMDAwMDAwLFxuICAgIDEwMDAwMDAwLFxuICAgIDEwMDAwMDAwMCxcbiAgICAxMDAwMDAwMDAwLFxuICAgIDEwMDAwMDAwMDAwLFxuICAgIDEwMDAwMDAwMDAwMCxcbiAgICAxMDAwMDAwMDAwMDAwLFxuICAgIDEwMDAwMDAwMDAwMDAwLFxuICAgIDEwMDAwMDAwMDAwMDAwMCxcbiAgICAxMDAwMDAwMDAwMDAwMDAwLFxuXTtcbi8qKiBAaW50ZXJuYWwgKi9cbkJpZ0RlY2ltYWwuSEFMRl9OVU1CRVJfTUFYX1ZBTFVFID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLyAyO1xuLyoqIEBpbnRlcm5hbCAqL1xuQmlnRGVjaW1hbC5IQUxGX05VTUJFUl9NSU5fVkFMVUUgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiAvIDI7XG4vKiogQGludGVybmFsICovXG5CaWdEZWNpbWFsLk9ORV9URU5USCA9IEJpZ0RlY2ltYWwuZnJvbUludGVnZXIzKDEsIDEpO1xuLyoqIEBpbnRlcm5hbCAqL1xuQmlnRGVjaW1hbC5PTkVfSEFMRiA9IEJpZ0RlY2ltYWwuZnJvbUludGVnZXIzKDUsIDEpO1xuLyoqIEBpbnRlcm5hbCAqL1xuQmlnRGVjaW1hbC5OVU1CRVJfMTBfUE9XID0gW1xuICAgIDFlMCwgMWUxLCAxZTIsIDFlMywgMWU0LCAxZTUsXG4gICAgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLFxuICAgIDFlMTIsIDFlMTMsIDFlMTQsIDFlMTVcbl07XG4vKiogQGludGVybmFsICovXG5CaWdEZWNpbWFsLlRIUkVTSE9MRFNfVEFCTEUgPSBbXG4gICAgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLyAxMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAsXG4gICAgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLyAxMDAwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAwMDAsXG4gICAgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLyAxMDAwMDAwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAwMDAwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAwMDAwMDAsXG4gICAgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLyAxMDAwMDAwMDAwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAwMDAwMDAwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAwMDAwMDAwMDAsXG4gICAgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLyAxMDAwMDAwMDAwMDAwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAwMDAwMDAwMDAwMCxcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAvIDEwMDAwMDAwMDAwMDAwMDAsXG5dO1xuLyoqIEBpbnRlcm5hbCAqL1xuQmlnRGVjaW1hbC5ESUdJVF9URU5TID0gW1xuICAgICcwJywgJzAnLCAnMCcsICcwJywgJzAnLCAnMCcsICcwJywgJzAnLCAnMCcsICcwJyxcbiAgICAnMScsICcxJywgJzEnLCAnMScsICcxJywgJzEnLCAnMScsICcxJywgJzEnLCAnMScsXG4gICAgJzInLCAnMicsICcyJywgJzInLCAnMicsICcyJywgJzInLCAnMicsICcyJywgJzInLFxuICAgICczJywgJzMnLCAnMycsICczJywgJzMnLCAnMycsICczJywgJzMnLCAnMycsICczJyxcbiAgICAnNCcsICc0JywgJzQnLCAnNCcsICc0JywgJzQnLCAnNCcsICc0JywgJzQnLCAnNCcsXG4gICAgJzUnLCAnNScsICc1JywgJzUnLCAnNScsICc1JywgJzUnLCAnNScsICc1JywgJzUnLFxuICAgICc2JywgJzYnLCAnNicsICc2JywgJzYnLCAnNicsICc2JywgJzYnLCAnNicsICc2JyxcbiAgICAnNycsICc3JywgJzcnLCAnNycsICc3JywgJzcnLCAnNycsICc3JywgJzcnLCAnNycsXG4gICAgJzgnLCAnOCcsICc4JywgJzgnLCAnOCcsICc4JywgJzgnLCAnOCcsICc4JywgJzgnLFxuICAgICc5JywgJzknLCAnOScsICc5JywgJzknLCAnOScsICc5JywgJzknLCAnOScsICc5Jyxcbl07XG4vKiogQGludGVybmFsICovXG5CaWdEZWNpbWFsLkRJR0lUX09ORVMgPSBbXG4gICAgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuICAgICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG4gICAgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuICAgICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG4gICAgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuICAgICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG4gICAgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuXTtcbi8qKlxuICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHtAbGluayBCaWdEZWNpbWFsfS4gQ2FuIGJlIGludm9rZWQgd2l0aCBuZXcgb3Igd2l0aG91dCBuZXcuXG4gKlxuICogVGhlIHZhbHVlcyBwYXNzZWQgbXVzdCBtYXRjaCBvbmUgb2YgSmF2YSBCaWdEZWNpbWFsJ3MgY29uc3RydWN0b3JzLCBzbyB0aGUgdmFsaWQgdXNhZ2VzIG9mIHRoaXMgZnVuY3Rpb24gaXMgbGlzdGVkIGJlbG93OlxuICogYGBgamF2YXNjcmlwdFxuICogQmlnKDEyM24pOyAvLyBiaWdpbnQsIDEyM1xuICogQmlnKDEyM24sIDMpOyAvLyBiaWdpbnQgYW5kIHNjYWxlLCAwLjEyM1xuICogQmlnKDEyM24sIDMsIE1DKDIsIFJvdW5kaW5nTW9kZS5IQUxGX1VQKSk7IC8vIGJpZ2ludCwgc2NhbGUgYW5kIG1jLCAwLjEyXG4gKiBCaWcoYUJpZ0RlY2ltYWwpIC8vIENvcGllcyB0aGUgQmlnRGVjaW1hbCBwYXNzZWQuIFwic2NhbGVcIiBhbmQgXCJtY1wiIGFyZ3VtZW50cyB3aWxsIG5vdCB1c2VkLlxuICogQmlnKDEyM24sIHVuZGVmaW5lZCwgTUMoMiwgUm91bmRpbmdNb2RlLkhBTEZfVVApKTsgLy8gYmlnaW50IGFuZCBtYywgMS4yRSsyXG4gKiBCaWcoJzEuMTNlMTInKTsgLy8gc3RyaW5nLCAxLjEzRSsxMlxuICogQmlnKCcxLjExZTExJywgdW5kZWZpbmVkLCBNQygyLCBSb3VuZGluZ01vZGUuSEFMRl9VUCkpOyAvLyBzdHJpbmcgYW5kIG1jLCAxLjFFKzExXG4gKiBCaWcoMTAwMDApOyAvLyBudW1iZXIsIDEwMDAwXG4gKiBCaWcoMTIzLCA1KTsgLy8gaW50ZWdlciBhbmQgc2NhbGUsIDAuMDAxMjNcbiAqIEJpZygxLjEyMzMsIHVuZGVmaW5lZCwgTUMoMiwgUm91bmRpbmdNb2RlLkhBTEZfVVApKTsgLy8gbnVtYmVyIGFuZCBzY2FsZSwgMS4xXG4gKiBgYGBcbiAqXG4gKiBTYW1wbGUgVXNhZ2U6XG4gKmBgYGphdmFzY3JpcHRcbiAqIC8vIFNpbmdsZSB1bmlmaWVkIGNvbnN0cnVjdG9yIGZvciBtdWx0aXBsZSB2YWx1ZXNcbiAqIGNvbnN0IHsgQmlnIH0gPSByZXF1aXJlKCdiaWdkZWNpbWFsLmpzJyk7XG4gKlxuICogLy8gQ29uc3RydWN0IGZyb20gYSBzdHJpbmcgYW5kIGNsb25lIGl0XG4gKiBjb25zdCB4ID0gQmlnKCcxLjExMTExMTExMTExMTExMTExMTExMTEnKTtcbiAqIGNvbnN0IHkgPSBuZXcgQmlnKHgpOyAvLyB5b3UgY2FuIGFsc28gdXNlICduZXcnXG4gKlxuICogY29uc3QgeiA9IHguYWRkKHkpO1xuICogY29uc29sZS5sb2coei50b1N0cmluZygpKTsgLy8gMi4yMjIyMjIyMjIyMjIyMjIyMjIyMjIyXG4gKlxuICogLy8gWW91IGNhbiBhbHNvIGNvbnN0cnVjdCBmcm9tIGEgbnVtYmVyIG9yIEJpZ0ludDpcbiAqIGNvbnN0IHUgPSBCaWcoMS4xKTtcbiAqIGNvbnN0IHYgPSBCaWcoMm4pO1xuICpcbiAqIGNvbnNvbGUubG9nKHUudG9TdHJpbmcoKSk7IC8vIDEuMVxuICogY29uc29sZS5sb2codi50b1N0cmluZygpKTsgLy8gMlxuICogYGBgXG4gKlxuICogQHBhcmFtIG4gQW55IHZhbHVlIHRvIGJ1aWxkIGEgQmlnRGVjaW1hbCBmcm9tLiBUeXBlcyBvdGhlciB0aGFuIGBOdW1iZXJgIChhcyBzYWZlIGludGVnZXIpLCBgQmlnSW50YCBhbmQgYEJpZ0RlY2ltYWxgXG4gKiB3aWxsIGJlIGludGVybmFsbHkgY29udmVydGVkIHRvIHN0cmluZyBhbmQgcGFyc2VkLlxuICogQHBhcmFtIHNjYWxlIFNjYWxlIHRvIHVzZSwgYnkgZGVmYXVsdCAwLlxuICogQHBhcmFtIG1jIE1hdGhDb250ZXh0IG9iamVjdCB3aGljaCBhbGxvd3MgeW91IHRvIHNldCBwcmVjaXNpb24gYW5kIHJvdW5kaW5nIG1vZGUuXG4gKiBAdGhyb3dzIFJhbmdlRXJyb3Igb24gZm9sbG93aW5nIHNpdHVhdGlvbnM6XG4gKiAqIElmIHZhbHVlIGlzIGEgbnVtYmVyOlxuICogICAgICogVmFsdWUgaXMgbm90IGluIHRoZSByYW5nZSBgWy1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFXWBcbiAqICAgICAqIEJvdGggYSBzY2FsZSBhbmQgYSBtYXRoIGNvbnRleHQgaXMgcHJvdmlkZWQuIFlvdSBjYW4gb25seSBnaXZlIG9uZSBvZiBzY2FsZSBhbmQgbWF0aCBjb250ZXh0LlxuICogICAgICAgUGFzc2luZyBgdW5kZWZpbmVkYCBpcyBzYW1lIGFzIG9taXR0aW5nIGFuIGFyZ3VtZW50LlxuICogICAgICogSWYgdmFsdWUgaXMgYSBkb3VibGUgYW5kIHNjYWxlIGlzIGdpdmVuLlxuICogKiBJZiB2YWx1ZSBpcyBub3QgYSBgc2FmZSBpbnRlZ2VyYCwgYSBgQmlnSW50YCBvciBhIGBCaWdEZWNpbWFsYCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5nLlxuICogICBBbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiB0aGUgc3RyaW5nIGZvcm1hdCBpcyBpbnZhbGlkLlxuICogKiBJZiB2YWx1ZSBpcyBub3QgYSBgQmlnSW50YCBvciBgbnVtYmVyYCwgYW5kIHNjYWxlIGlzIGdpdmVuLlxuICovXG5leHBvcnRzLkJpZyA9IGZ1bmN0aW9uIF9CaWcobiwgc2NhbGUsIG1jKSB7XG4gICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbVZhbHVlKG4sIHNjYWxlLCBtYyk7XG59O1xuLyoqXG4gKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3Ige0BsaW5rIE1hdGhDb250ZXh0fS4gQ2FuIGJlIGludm9rZWQgd2l0aCBuZXcgb3Igd2l0aG91dCBuZXcuXG4gKlxuICogU2FtcGxlIFVzYWdlOlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgeyBCaWcsIE1DLCBSb3VuZGluZ01vZGUgfSA9IHJlcXVpcmUoJ2JpZ2RlY2ltYWwuanMnKTtcbiAqXG4gKiBjb25zdCB4ID0gQmlnKCcxJyk7XG4gKiBjb25zdCB5ID0gQmlnKCczJyk7XG4gKlxuICogY29uc3QgcmVzMSA9IHguZGl2aWRlV2l0aE1hdGhDb250ZXh0KHksIG5ldyBNQygzKSk7XG4gKiBjb25zb2xlLmxvZyhyZXMxLnRvU3RyaW5nKCkpOyAvLyAwLjMzM1xuICpcbiAqIC8vIFlvdSBjYW4gYWxzbyB1c2Ugd2l0aG91dCBgbmV3YCBvcGVyYXRvclxuICogY29uc3QgcmVzMiA9IHguZGl2aWRlV2l0aE1hdGhDb250ZXh0KHksIE1DKDMsIFJvdW5kaW5nTW9kZS5VUCkpO1xuICogY29uc29sZS5sb2cocmVzMi50b1N0cmluZygpKTsgLy8gMC4zMzRcbiAqXG4gKiB0cnkge1xuICogICAgIHguZGl2aWRlKHkpO1xuICogICAgIC8vIHRocm93cyBzaW5jZSBmdWxsIHByZWNpc2lvbiBpcyByZXF1ZXN0ZWQgYnV0IGl0IGlzIG5vdCBwb3NzaWJsZVxuICogfSBjYXRjaCAoZSkge1xuICogICAgIGNvbnNvbGUubG9nKGUpOyAvLyBSYW5nZUVycm9yOiBOb24tdGVybWluYXRpbmcgZGVjaW1hbCBleHBhbnNpb247IG5vIGV4YWN0IHJlcHJlc2VudGFibGUgZGVjaW1hbCByZXN1bHQuXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHJlY2lzaW9uIFByZWNpc2lvbiB2YWx1ZVxuICogQHBhcmFtIHJvdW5kaW5nTW9kZSBPcHRpb25hbCByb3VuZGluZyBNb2RlLiBCeSBkZWZhdWx0IFJvdW5kaW5nTW9kZS5IQUxGX1VQLlxuICovXG5leHBvcnRzLk1DID0gZnVuY3Rpb24gX01DKHByZWNpc2lvbiwgcm91bmRpbmdNb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRoQ29udGV4dChwcmVjaXNpb24sIHJvdW5kaW5nTW9kZSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnZGVjaW1hbC5qcy5tYXAiLCIvKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcbmV4cG9ydCB2YXIgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0IHZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCB2YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MiBmcm9tIFwiLi9tYXQyLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQyZCBmcm9tIFwiLi9tYXQyZC5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MyBmcm9tIFwiLi9tYXQzLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL21hdDQuanNcIjtcbmltcG9ydCAqIGFzIHF1YXQgZnJvbSBcIi4vcXVhdC5qc1wiO1xuaW1wb3J0ICogYXMgcXVhdDIgZnJvbSBcIi4vcXVhdDIuanNcIjtcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSBcIi4vdmVjMi5qc1wiO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tIFwiLi92ZWMzLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzQuanNcIjtcbmV4cG9ydCB7IGdsTWF0cml4LCBtYXQyLCBtYXQyZCwgbWF0MywgbWF0NCwgcXVhdCwgcXVhdDIsIHZlYzIsIHZlYzMsIHZlYzQgfTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxuICogMngyIE1hdHJpeFxuICogQG1vZHVsZSBtYXQyXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTEwO1xuICBvdXRbM10gPSBtMTE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTEwO1xuICBvdXRbM10gPSBtMTE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGVcbiAgLy8gc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMSA9IGFbMV07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhMTtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYVsxXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGEzICogZGV0O1xuICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gIG91dFsyXSA9IC1hMiAqIGRldDtcbiAgb3V0WzNdID0gYTAgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIHZhciBhMCA9IGFbMF07XG4gIG91dFswXSA9IGFbM107XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGEwICogYyArIGEyICogcztcbiAgb3V0WzFdID0gYTEgKiBjICsgYTMgKiBzO1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbn1cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIExEVShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdIC8gYVswXTtcbiAgVVswXSA9IGFbMF07XG4gIFVbMV0gPSBhWzFdO1xuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdO1xuICByZXR1cm4gW0wsIEQsIFVdO1xufVxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiAyeDMgTWF0cml4XG4gKiBAbW9kdWxlIG1hdDJkXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGIsXG4gKiAgYywgZCxcbiAqICB0eCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYiwgMCxcbiAqICBjLCBkLCAwLFxuICogIHR4LCB0eSwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3QgY29sdW1uIGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MmQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDJkIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgb3V0WzJdID0gYztcbiAgb3V0WzNdID0gZDtcbiAgb3V0WzRdID0gdHg7XG4gIG91dFs1XSA9IHR5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYWEgPSBhWzBdLFxuICAgICAgYWIgPSBhWzFdLFxuICAgICAgYWMgPSBhWzJdLFxuICAgICAgYWQgPSBhWzNdO1xuICB2YXIgYXR4ID0gYVs0XSxcbiAgICAgIGF0eSA9IGFbNV07XG4gIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMV0gKiBhWzJdO1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgb3V0WzRdID0gYTQ7XG4gIG91dFs1XSA9IGE1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgb3V0WzRdID0gYTQ7XG4gIG91dFs1XSA9IGE1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTA7XG4gIG91dFsxXSA9IGExO1xuICBvdXRbMl0gPSBhMjtcbiAgb3V0WzNdID0gYTM7XG4gIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gYztcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSB2WzFdO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB2WzBdO1xuICBvdXRbNV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MmQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIsIFwiICsgYVs0XSArIFwiLCBcIiArIGFbNV0gKyBcIilcIjtcbn1cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgMSk7XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxuICogM3gzIE1hdHJpeFxuICogQG1vZHVsZSBtYXQzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVs0XTtcbiAgb3V0WzRdID0gYVs1XTtcbiAgb3V0WzVdID0gYVs2XTtcbiAgb3V0WzZdID0gYVs4XTtcbiAgb3V0WzddID0gYVs5XTtcbiAgb3V0WzhdID0gYVsxMF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMiA9IGFbNV07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGEwMTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGEwMjtcbiAgICBvdXRbN10gPSBhMTI7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYVsxXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYVsyXTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IGFbOF07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XG4gIHZhciBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICB2YXIgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gIG91dFszXSA9IGIxMSAqIGRldDtcbiAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgb3V0WzZdID0gYjIxICogZGV0O1xuICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgb3V0WzBdID0gYTExICogYTIyIC0gYTEyICogYTIxO1xuICBvdXRbMV0gPSBhMDIgKiBhMjEgLSBhMDEgKiBhMjI7XG4gIG91dFsyXSA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgb3V0WzNdID0gYTEyICogYTIwIC0gYTEwICogYTIyO1xuICBvdXRbNF0gPSBhMDAgKiBhMjIgLSBhMDIgKiBhMjA7XG4gIG91dFs1XSA9IGEwMiAqIGExMCAtIGEwMCAqIGExMjtcbiAgb3V0WzZdID0gYTEwICogYTIxIC0gYTExICogYTIwO1xuICBvdXRbN10gPSBhMDEgKiBhMjAgLSBhMDAgKiBhMjE7XG4gIG91dFs4XSA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDAgPSBiWzBdLFxuICAgICAgYjAxID0gYlsxXSxcbiAgICAgIGIwMiA9IGJbMl07XG4gIHZhciBiMTAgPSBiWzNdLFxuICAgICAgYjExID0gYls0XSxcbiAgICAgIGIxMiA9IGJbNV07XG4gIHZhciBiMjAgPSBiWzZdLFxuICAgICAgYjIxID0gYls3XSxcbiAgICAgIGIyMiA9IGJbOF07XG4gIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG4gIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG4gIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDA7XG4gIG91dFsxXSA9IGEwMTtcbiAgb3V0WzJdID0gYTAyO1xuICBvdXRbM10gPSBhMTA7XG4gIG91dFs0XSA9IGExMTtcbiAgb3V0WzVdID0gYTEyO1xuICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcbiAgb3V0WzZdID0gYTIwO1xuICBvdXRbN10gPSBhMjE7XG4gIG91dFs4XSA9IGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IHggKiBhWzBdO1xuICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgb3V0WzJdID0geCAqIGFbMl07XG4gIG91dFszXSA9IHkgKiBhWzNdO1xuICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgb3V0WzVdID0geSAqIGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSB2WzBdO1xuICBvdXRbN10gPSB2WzFdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IC1zO1xuICBvdXRbNF0gPSBjO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB2WzFdO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDJkKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSBhWzJdO1xuICBvdXRbNF0gPSBhWzNdO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSBhWzRdO1xuICBvdXRbN10gPSBhWzVdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzddID0genkgLSB3eDtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIDJEIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB5b3VyIGdsIGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGdsIGNvbnRleHRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgb3V0WzBdID0gMiAvIHdpZHRoO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtMiAvIGhlaWdodDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gLTE7XG4gIG91dFs3XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIsIFwiICsgYVs4XSArIFwiKVwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSk7XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDMncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdICogc2NhbGU7XG4gIG91dFs3XSA9IGFbN10gKyBiWzddICogc2NhbGU7XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddLFxuICAgICAgYTggPSBhWzhdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddLFxuICAgICAgYjggPSBiWzhdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxuICogQG1vZHVsZSBtYXQ0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICB2YXIgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICBvdXRbMF0gPSBhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMik7XG4gIG91dFsxXSA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdID0gYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbM10gPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs0XSA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdID0gYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpO1xuICBvdXRbNl0gPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs3XSA9IGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzhdID0gYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpO1xuICBvdXRbOV0gPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gIG91dFsxMF0gPSBhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSk7XG4gIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gIG91dFsxM10gPSBhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSk7XG4gIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIG91dFsxNV0gPSBhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIHZhciBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIHZhciBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIHZhciBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgaWYgKGEgPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IGFbMF07XG4gICAgYTAxID0gYVsxXTtcbiAgICBhMDIgPSBhWzJdO1xuICAgIGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTtcbiAgICBhMTEgPSBhWzVdO1xuICAgIGExMiA9IGFbNl07XG4gICAgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdO1xuICAgIGEyMSA9IGFbOV07XG4gICAgYTIyID0gYVsxMF07XG4gICAgYTIzID0gYVsxMV07XG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG4gICAgb3V0WzNdID0gYTAzO1xuICAgIG91dFs0XSA9IGExMDtcbiAgICBvdXRbNV0gPSBhMTE7XG4gICAgb3V0WzZdID0gYTEyO1xuICAgIG91dFs3XSA9IGExMztcbiAgICBvdXRbOF0gPSBhMjA7XG4gICAgb3V0WzldID0gYTIxO1xuICAgIG91dFsxMF0gPSBhMjI7XG4gICAgb3V0WzExXSA9IGEyMztcbiAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgICB5ID0gYXhpc1sxXSxcbiAgICAgIHogPSBheGlzWzJdO1xuICB2YXIgbGVuID0gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbiAgdmFyIHMsIGMsIHQ7XG4gIHZhciBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIHZhciBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIHZhciBhMjAsIGEyMSwgYTIyLCBhMjM7XG4gIHZhciBiMDAsIGIwMSwgYjAyO1xuICB2YXIgYjEwLCBiMTEsIGIxMjtcbiAgdmFyIGIyMCwgYjIxLCBiMjI7XG5cbiAgaWYgKGxlbiA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjO1xuICBhMDAgPSBhWzBdO1xuICBhMDEgPSBhWzFdO1xuICBhMDIgPSBhWzJdO1xuICBhMDMgPSBhWzNdO1xuICBhMTAgPSBhWzRdO1xuICBhMTEgPSBhWzVdO1xuICBhMTIgPSBhWzZdO1xuICBhMTMgPSBhWzddO1xuICBhMjAgPSBhWzhdO1xuICBhMjEgPSBhWzldO1xuICBhMjIgPSBhWzEwXTtcbiAgYTIzID0gYVsxMV07IC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuXG4gIGIwMCA9IHggKiB4ICogdCArIGM7XG4gIGIwMSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIGIxMSA9IHkgKiB5ICogdCArIGM7XG4gIGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICBiMjAgPSB4ICogeiAqIHQgKyB5ICogcztcbiAgYjIxID0geSAqIHogKiB0IC0geCAqIHM7XG4gIGIyMiA9IHogKiB6ICogdCArIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgdmFyIHggPSBheGlzWzBdLFxuICAgICAgeSA9IGF4aXNbMV0sXG4gICAgICB6ID0gYXhpc1syXTtcbiAgdmFyIGxlbiA9IE1hdGguaHlwb3QoeCwgeSwgeik7XG4gIHZhciBzLCBjLCB0O1xuXG4gIGlmIChsZW4gPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjO1xuICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogcztcbiAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzO1xuICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjO1xuICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHM7XG4gIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICBvdXRbMTBdID0geiAqIHogKiB0ICsgYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21ZUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gcztcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVpSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IC1zO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdikge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgZnJvbSBhIGR1YWwgcXVhdC5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBNYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHttYXQ0fSBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0MihvdXQsIGEpIHtcbiAgdmFyIHRyYW5zbGF0aW9uID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN107XG4gIHZhciBtYWduaXR1ZGUgPSBieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnogKyBidyAqIGJ3OyAvL09ubHkgc2NhbGUgaWYgaXQgbWFrZXMgc2Vuc2VcblxuICBpZiAobWFnbml0dWRlID4gMCkge1xuICAgIHRyYW5zbGF0aW9uWzBdID0gKGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnkpICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsxXSA9IChheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyIC8gbWFnbml0dWRlO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zbGF0aW9uWzBdID0gKGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnkpICogMjtcbiAgICB0cmFuc2xhdGlvblsxXSA9IChheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICB9XG5cbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBhLCB0cmFuc2xhdGlvbik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcbiAqICB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0gIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZVxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxuICogIHRoZSBzYW1lIGFzIHRoZSBzY2FsaW5nIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XG4gKiBAcGFyYW0gIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICB2YXIgbTExID0gbWF0WzBdO1xuICB2YXIgbTEyID0gbWF0WzFdO1xuICB2YXIgbTEzID0gbWF0WzJdO1xuICB2YXIgbTIxID0gbWF0WzRdO1xuICB2YXIgbTIyID0gbWF0WzVdO1xuICB2YXIgbTIzID0gbWF0WzZdO1xuICB2YXIgbTMxID0gbWF0WzhdO1xuICB2YXIgbTMyID0gbWF0WzldO1xuICB2YXIgbTMzID0gbWF0WzEwXTtcbiAgb3V0WzBdID0gTWF0aC5oeXBvdChtMTEsIG0xMiwgbTEzKTtcbiAgb3V0WzFdID0gTWF0aC5oeXBvdChtMjEsIG0yMiwgbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5oeXBvdChtMzEsIG0zMiwgbTMzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7cXVhdH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIHZhciBzY2FsaW5nID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIGdldFNjYWxpbmcoc2NhbGluZywgbWF0KTtcbiAgdmFyIGlzMSA9IDEgLyBzY2FsaW5nWzBdO1xuICB2YXIgaXMyID0gMSAvIHNjYWxpbmdbMV07XG4gIHZhciBpczMgPSAxIC8gc2NhbGluZ1syXTtcbiAgdmFyIHNtMTEgPSBtYXRbMF0gKiBpczE7XG4gIHZhciBzbTEyID0gbWF0WzFdICogaXMyO1xuICB2YXIgc20xMyA9IG1hdFsyXSAqIGlzMztcbiAgdmFyIHNtMjEgPSBtYXRbNF0gKiBpczE7XG4gIHZhciBzbTIyID0gbWF0WzVdICogaXMyO1xuICB2YXIgc20yMyA9IG1hdFs2XSAqIGlzMztcbiAgdmFyIHNtMzEgPSBtYXRbOF0gKiBpczE7XG4gIHZhciBzbTMyID0gbWF0WzldICogaXMyO1xuICB2YXIgc20zMyA9IG1hdFsxMF0gKiBpczM7XG4gIHZhciB0cmFjZSA9IHNtMTEgKyBzbTIyICsgc20zMztcbiAgdmFyIFMgPSAwO1xuXG4gIGlmICh0cmFjZSA+IDApIHtcbiAgICBTID0gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKSAqIDI7XG4gICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgb3V0WzBdID0gKHNtMjMgLSBzbTMyKSAvIFM7XG4gICAgb3V0WzFdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzJdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gIH0gZWxzZSBpZiAoc20xMSA+IHNtMjIgJiYgc20xMSA+IHNtMzMpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMTEgLSBzbTIyIC0gc20zMykgKiAyO1xuICAgIG91dFszXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgIG91dFsyXSA9IChzbTMxICsgc20xMykgLyBTO1xuICB9IGVsc2UgaWYgKHNtMjIgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTIyIC0gc20xMSAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICBvdXRbMF0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICBvdXRbMl0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgfSBlbHNlIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMzMgLSBzbTExIC0gc20yMikgKiAyO1xuICAgIG91dFszXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICAgIG91dFswXSA9IChzbTMxICsgc20xMykgLyBTO1xuICAgIG91dFsxXSA9IChzbTIzICsgc20zMikgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG5lZ2F0aXZlT3JpZ2luKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBvIFRoZSBvcmlnaW4gdmVjdG9yIGFyb3VuZCB3aGljaCB0byBzY2FsZSBhbmQgcm90YXRlXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4ob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIHZhciBveCA9IG9bMF07XG4gIHZhciBveSA9IG9bMV07XG4gIHZhciBveiA9IG9bMl07XG4gIHZhciBvdXQwID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIHZhciBvdXQxID0gKHh5ICsgd3opICogc3g7XG4gIHZhciBvdXQyID0gKHh6IC0gd3kpICogc3g7XG4gIHZhciBvdXQ0ID0gKHh5IC0gd3opICogc3k7XG4gIHZhciBvdXQ1ID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIHZhciBvdXQ2ID0gKHl6ICsgd3gpICogc3k7XG4gIHZhciBvdXQ4ID0gKHh6ICsgd3kpICogc3o7XG4gIHZhciBvdXQ5ID0gKHl6IC0gd3gpICogc3o7XG4gIHZhciBvdXQxMCA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICBvdXRbNl0gPSBvdXQ2O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBvdXQ4O1xuICBvdXRbOV0gPSBvdXQ5O1xuICBvdXRbMTBdID0gb3V0MTA7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dDAgKiBveCArIG91dDQgKiBveSArIG91dDggKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0MSAqIG94ICsgb3V0NSAqIG95ICsgb3V0OSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXQyICogb3ggKyBvdXQ2ICogb3kgKyBvdXQxMCAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeXggPSB5ICogeDI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHp4ID0geiAqIHgyO1xuICB2YXIgenkgPSB6ICogeTI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHl4IC0gd3o7XG4gIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbNl0gPSB6eSArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6eCArIHd5O1xuICBvdXRbOV0gPSB6eSAtIHd4O1xuICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZydXN0dW0ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XG4gIHZhciB0YiA9IDEgLyAodG9wIC0gYm90dG9tKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gbmVhciAqIDIgKiBybDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gbmVhciAqIDIgKiB0YjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IGZhciAqIG5lYXIgKiAyICogbmY7XG4gIG91dFsxNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBUaGUgbmVhci9mYXIgY2xpcCBwbGFuZXMgY29ycmVzcG9uZCB0byBhIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGUgWiByYW5nZSBvZiBbLTEsIDFdLFxuICogd2hpY2ggbWF0Y2hlcyBXZWJHTC9PcGVuR0wncyBjbGlwIHZvbHVtZS5cbiAqIFBhc3NpbmcgbnVsbC91bmRlZmluZWQvbm8gdmFsdWUgZm9yIGZhciB3aWxsIGdlbmVyYXRlIGluZmluaXRlIHByb2plY3Rpb24gbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtLCBjYW4gYmUgbnVsbCBvciBJbmZpbml0eVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZU5PKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuXG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTRdID0gMiAqIGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC0yICogbmVhcjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5wZXJzcGVjdGl2ZU5PfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBwZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlTk87XG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHN1aXRhYmxlIGZvciBXZWJHUFUgd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxuICogVGhlIG5lYXIvZmFyIGNsaXAgcGxhbmVzIGNvcnJlc3BvbmQgdG8gYSBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlIFogcmFuZ2Ugb2YgWzAsIDFdLFxuICogd2hpY2ggbWF0Y2hlcyBXZWJHUFUvVnVsa2FuL0RpcmVjdFgvTWV0YWwncyBjbGlwIHZvbHVtZS5cbiAqIFBhc3NpbmcgbnVsbC91bmRlZmluZWQvbm8gdmFsdWUgZm9yIGZhciB3aWxsIGdlbmVyYXRlIGluZmluaXRlIHByb2plY3Rpb24gbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtLCBjYW4gYmUgbnVsbCBvciBJbmZpbml0eVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZVpPKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuXG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSBmYXIgKiBuZjtcbiAgICBvdXRbMTRdID0gZmFyICogbmVhciAqIG5mO1xuICB9IGVsc2Uge1xuICAgIG91dFsxMF0gPSAtMTtcbiAgICBvdXRbMTRdID0gLW5lYXI7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbik7XG4gIHZhciB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcbiAgb3V0WzBdID0geFNjYWxlO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICBvdXRbNF0gPSAwLjA7XG4gIG91dFs1XSA9IHlTY2FsZTtcbiAgb3V0WzZdID0gMC4wO1xuICBvdXRbN10gPSAwLjA7XG4gIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICBvdXRbOV0gPSAodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNTtcbiAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzExXSA9IC0xLjA7XG4gIG91dFsxMl0gPSAwLjA7XG4gIG91dFsxM10gPSAwLjA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTVdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cbiAqIFRoZSBuZWFyL2ZhciBjbGlwIHBsYW5lcyBjb3JyZXNwb25kIHRvIGEgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZSBaIHJhbmdlIG9mIFstMSwgMV0sXG4gKiB3aGljaCBtYXRjaGVzIFdlYkdML09wZW5HTCdzIGNsaXAgdm9sdW1lLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBvcnRob05PKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5vcnRob05PfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBvcnRobyA9IG9ydGhvTk87XG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxuICogVGhlIG5lYXIvZmFyIGNsaXAgcGxhbmVzIGNvcnJlc3BvbmQgdG8gYSBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlIFogcmFuZ2Ugb2YgWzAsIDFdLFxuICogd2hpY2ggbWF0Y2hlcyBXZWJHUFUvVnVsa2FuL0RpcmVjdFgvTWV0YWwncyBjbGlwIHZvbHVtZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG9aTyhvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTtcbiAgdmFyIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSAtMiAqIGxyO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAtMiAqIGJ0O1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSBuZWFyICogbmY7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpcy5cbiAqIElmIHlvdSB3YW50IGEgbWF0cml4IHRoYXQgYWN0dWFsbHkgbWFrZXMgYW4gb2JqZWN0IGxvb2sgYXQgYW5vdGhlciBvYmplY3QsIHlvdSBzaG91bGQgdXNlIHRhcmdldFRvIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW47XG4gIHZhciBleWV4ID0gZXllWzBdO1xuICB2YXIgZXlleSA9IGV5ZVsxXTtcbiAgdmFyIGV5ZXogPSBleWVbMl07XG4gIHZhciB1cHggPSB1cFswXTtcbiAgdmFyIHVweSA9IHVwWzFdO1xuICB2YXIgdXB6ID0gdXBbMl07XG4gIHZhciBjZW50ZXJ4ID0gY2VudGVyWzBdO1xuICB2YXIgY2VudGVyeSA9IGNlbnRlclsxXTtcbiAgdmFyIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gIH1cblxuICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuICBsZW4gPSAxIC8gTWF0aC5oeXBvdCh6MCwgejEsIHoyKTtcbiAgejAgKj0gbGVuO1xuICB6MSAqPSBsZW47XG4gIHoyICo9IGxlbjtcbiAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0gTWF0aC5oeXBvdCh4MCwgeDEsIHgyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHgwID0gMDtcbiAgICB4MSA9IDA7XG4gICAgeDIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuICBsZW4gPSBNYXRoLmh5cG90KHkwLCB5MSwgeTIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeTAgPSAwO1xuICAgIHkxID0gMDtcbiAgICB5MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB5MCAqPSBsZW47XG4gICAgeTEgKj0gbGVuO1xuICAgIHkyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB5MDtcbiAgb3V0WzJdID0gejA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHgxO1xuICBvdXRbNV0gPSB5MTtcbiAgb3V0WzZdID0gejE7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHgyO1xuICBvdXRbOV0gPSB5MjtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIG1hdHJpeCB0aGF0IG1ha2VzIHNvbWV0aGluZyBsb29rIGF0IHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gIHZhciBleWV4ID0gZXllWzBdLFxuICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICB1cHggPSB1cFswXSxcbiAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgdXB6ID0gdXBbMl07XG4gIHZhciB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG4gIHZhciBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cblxuICB2YXIgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIsIFwiICsgYVs0XSArIFwiLCBcIiArIGFbNV0gKyBcIiwgXCIgKyBhWzZdICsgXCIsIFwiICsgYVs3XSArIFwiLCBcIiArIGFbOF0gKyBcIiwgXCIgKyBhWzldICsgXCIsIFwiICsgYVsxMF0gKyBcIiwgXCIgKyBhWzExXSArIFwiLCBcIiArIGFbMTJdICsgXCIsIFwiICsgYVsxM10gKyBcIiwgXCIgKyBhWzE0XSArIFwiLCBcIiArIGFbMTVdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdLCBhWzldLCBhWzEwXSwgYVsxMV0sIGFbMTJdLCBhWzEzXSwgYVsxNF0sIGFbMTVdKTtcbn1cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICBvdXRbOV0gPSBhWzldICogYjtcbiAgb3V0WzEwXSA9IGFbMTBdICogYjtcbiAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgb3V0WzEyXSA9IGFbMTJdICogYjtcbiAgb3V0WzEzXSA9IGFbMTNdICogYjtcbiAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgb3V0WzE1XSA9IGFbMTVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGE4ID0gYVs4XSxcbiAgICAgIGE5ID0gYVs5XSxcbiAgICAgIGExMCA9IGFbMTBdLFxuICAgICAgYTExID0gYVsxMV07XG4gIHZhciBhMTIgPSBhWzEyXSxcbiAgICAgIGExMyA9IGFbMTNdLFxuICAgICAgYTE0ID0gYVsxNF0sXG4gICAgICBhMTUgPSBhWzE1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgdmFyIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgdmFyIGI4ID0gYls4XSxcbiAgICAgIGI5ID0gYls5XSxcbiAgICAgIGIxMCA9IGJbMTBdLFxuICAgICAgYjExID0gYlsxMV07XG4gIHZhciBiMTIgPSBiWzEyXSxcbiAgICAgIGIxMyA9IGJbMTNdLFxuICAgICAgYjE0ID0gYlsxNF0sXG4gICAgICBiMTUgPSBiWzE1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJiBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiYgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJiBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiYgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0My5qc1wiO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tIFwiLi92ZWMzLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzQuanNcIjtcbi8qKlxuICogUXVhdGVybmlvblxuICogQG1vZHVsZSBxdWF0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0QXhpc0FuZ2xlKG91dCwgYXhpcywgcmFkKSB7XG4gIHJhZCA9IHJhZCAqIDAuNTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZXRzIHRoZSByb3RhdGlvbiBheGlzIGFuZCBhbmdsZSBmb3IgYSBnaXZlblxuICogIHF1YXRlcm5pb24uIElmIGEgcXVhdGVybmlvbiBpcyBjcmVhdGVkIHdpdGhcbiAqICBzZXRBeGlzQW5nbGUsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lXG4gKiAgdmFsdWVzIGFzIHByb3ZpZGllZCBpbiB0aGUgb3JpZ2luYWwgcGFyYW1ldGVyIGxpc3RcbiAqICBPUiBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKiBFeGFtcGxlOiBUaGUgcXVhdGVybmlvbiBmb3JtZWQgYnkgYXhpcyBbMCwgMCwgMV0gYW5kXG4gKiAgYW5nbGUgLTkwIGlzIHRoZSBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieVxuICogIFswLCAwLCAxXSBhbmQgMjcwLiBUaGlzIG1ldGhvZCBmYXZvcnMgdGhlIGxhdHRlci5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dF9heGlzICBWZWN0b3IgcmVjZWl2aW5nIHRoZSBheGlzIG9mIHJvdGF0aW9uXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXR9IHEgICAgIFF1YXRlcm5pb24gdG8gYmUgZGVjb21wb3NlZFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSByb3RhdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzQW5nbGUob3V0X2F4aXMsIHEpIHtcbiAgdmFyIHJhZCA9IE1hdGguYWNvcyhxWzNdKSAqIDIuMDtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQgLyAyLjApO1xuXG4gIGlmIChzID4gZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIG91dF9heGlzWzBdID0gcVswXSAvIHM7XG4gICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICBvdXRfYXhpc1syXSA9IHFbMl0gLyBzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHMgaXMgemVybywgcmV0dXJuIGFueSBheGlzIChubyByb3RhdGlvbiAtIGF4aXMgZG9lcyBub3QgbWF0dGVyKVxuICAgIG91dF9heGlzWzBdID0gMTtcbiAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgb3V0X2F4aXNbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJhZDtcbn1cbi8qKlxuICogR2V0cyB0aGUgYW5ndWxhciBkaXN0YW5jZSBiZXR3ZWVuIHR3byB1bml0IHF1YXRlcm5pb25zXG4gKlxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0fSBhICAgICBPcmlnaW4gdW5pdCBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXR9IGIgICAgIERlc3RpbmF0aW9uIHVuaXQgcXVhdGVybmlvblxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIGJldHdlZW4gdGhlIHR3byBxdWF0ZXJuaW9uc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmdsZShhLCBiKSB7XG4gIHZhciBkb3Rwcm9kdWN0ID0gZG90KGEsIGIpO1xuICByZXR1cm4gTWF0aC5hY29zKDIgKiBkb3Rwcm9kdWN0ICogZG90cHJvZHVjdCAtIDEpO1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnkgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ6ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2YgYSB1bml0IHF1YXRlcm5pb24uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdLFxuICAgICAgdyA9IGFbM107XG4gIHZhciByID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHZhciBldCA9IE1hdGguZXhwKHcpO1xuICB2YXIgcyA9IHIgPiAwID8gZXQgKiBNYXRoLnNpbihyKSAvIHIgOiAwO1xuICBvdXRbMF0gPSB4ICogcztcbiAgb3V0WzFdID0geSAqIHM7XG4gIG91dFsyXSA9IHogKiBzO1xuICBvdXRbM10gPSBldCAqIE1hdGguY29zKHIpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxuKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdLFxuICAgICAgdyA9IGFbM107XG4gIHZhciByID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHZhciB0ID0gciA+IDAgPyBNYXRoLmF0YW4yKHIsIHcpIC8gciA6IDA7XG4gIG91dFswXSA9IHggKiB0O1xuICBvdXRbMV0gPSB5ICogdDtcbiAgb3V0WzJdID0geiAqIHQ7XG4gIG91dFszXSA9IDAuNSAqIE1hdGgubG9nKHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzY2FsYXIgcG93ZXIgb2YgYSB1bml0IHF1YXRlcm5pb24uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgcXVhdGVybmlvbiBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwb3cob3V0LCBhLCBiKSB7XG4gIGxuKG91dCwgYSk7XG4gIHNjYWxlKG91dCwgb3V0LCBiKTtcbiAgZXhwKG91dCwgb3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgLy8gYmVuY2htYXJrczpcbiAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXSxcbiAgICAgIGJ3ID0gYlszXTtcbiAgdmFyIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxOyAvLyBjYWxjIGNvc2luZVxuXG4gIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidzsgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG5cbiAgaWYgKGNvc29tIDwgMC4wKSB7XG4gICAgY29zb20gPSAtY29zb207XG4gICAgYnggPSAtYng7XG4gICAgYnkgPSAtYnk7XG4gICAgYnogPSAtYno7XG4gICAgYncgPSAtYnc7XG4gIH0gLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuXG5cbiAgaWYgKDEuMCAtIGNvc29tID4gZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICBzaW5vbSA9IE1hdGguc2luKG9tZWdhKTtcbiAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gIH0gZWxzZSB7XG4gICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZVxuICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgIHNjYWxlMSA9IHQ7XG4gIH0gLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuXG5cbiAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHVuaXQgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0KSB7XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcbiAgLy8gVE9ETzogQ2FsbGluZyByYW5kb20gMyB0aW1lcyBpcyBwcm9iYWJseSBub3QgdGhlIGZhc3Rlc3Qgc29sdXRpb25cbiAgdmFyIHUxID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciB1MiA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgdTMgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHNxcnQxTWludXNVMSA9IE1hdGguc3FydCgxIC0gdTEpO1xuICB2YXIgc3FydFUxID0gTWF0aC5zcXJ0KHUxKTtcbiAgb3V0WzBdID0gc3FydDFNaW51c1UxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzFdID0gc3FydDFNaW51c1UxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzJdID0gc3FydFUxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgb3V0WzNdID0gc3FydFUxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgZG90ID0gYTAgKiBhMCArIGExICogYTEgKyBhMiAqIGEyICsgYTMgKiBhMztcbiAgdmFyIGludkRvdCA9IGRvdCA/IDEuMCAvIGRvdCA6IDA7IC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgb3V0WzBdID0gLWEwICogaW52RG90O1xuICBvdXRbMV0gPSAtYTEgKiBpbnZEb3Q7XG4gIG91dFsyXSA9IC1hMiAqIGludkRvdDtcbiAgb3V0WzNdID0gYTMgKiBpbnZEb3Q7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSByb3RhdGlvbiBtYXRyaXhcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0MyhvdXQsIG0pIHtcbiAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gIHZhciBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gIHZhciBmUm9vdDtcblxuICBpZiAoZlRyYWNlID4gMC4wKSB7XG4gICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7IC8vIDJ3XG5cbiAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICBmUm9vdCA9IDAuNSAvIGZSb290OyAvLyAxLyg0dylcblxuICAgIG91dFswXSA9IChtWzVdIC0gbVs3XSkgKiBmUm9vdDtcbiAgICBvdXRbMV0gPSAobVs2XSAtIG1bMl0pICogZlJvb3Q7XG4gICAgb3V0WzJdID0gKG1bMV0gLSBtWzNdKSAqIGZSb290O1xuICB9IGVsc2Uge1xuICAgIC8vIHx3fCA8PSAxLzJcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKG1bNF0gPiBtWzBdKSBpID0gMTtcbiAgICBpZiAobVs4XSA+IG1baSAqIDMgKyBpXSkgaSA9IDI7XG4gICAgdmFyIGogPSAoaSArIDEpICUgMztcbiAgICB2YXIgayA9IChpICsgMikgJSAzO1xuICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSAqIDMgKyBpXSAtIG1baiAqIDMgKyBqXSAtIG1bayAqIDMgKyBrXSArIDEuMCk7XG4gICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICBvdXRbM10gPSAobVtqICogMyArIGtdIC0gbVtrICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtqXSA9IChtW2ogKiAzICsgaV0gKyBtW2kgKiAzICsgal0pICogZlJvb3Q7XG4gICAgb3V0W2tdID0gKG1bayAqIDMgKyBpXSArIG1baSAqIDMgKyBrXSkgKiBmUm9vdDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlIHgsIHksIHouXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3h9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge3l9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWSBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge3p9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWiBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV1bGVyKG91dCwgeCwgeSwgeikge1xuICB2YXIgaGFsZlRvUmFkID0gMC41ICogTWF0aC5QSSAvIDE4MC4wO1xuICB4ICo9IGhhbGZUb1JhZDtcbiAgeSAqPSBoYWxmVG9SYWQ7XG4gIHogKj0gaGFsZlRvUmFkO1xuICB2YXIgc3ggPSBNYXRoLnNpbih4KTtcbiAgdmFyIGN4ID0gTWF0aC5jb3MoeCk7XG4gIHZhciBzeSA9IE1hdGguc2luKHkpO1xuICB2YXIgY3kgPSBNYXRoLmNvcyh5KTtcbiAgdmFyIHN6ID0gTWF0aC5zaW4oeik7XG4gIHZhciBjeiA9IE1hdGguY29zKHopO1xuICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gIG91dFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgb3V0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICBvdXRbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJxdWF0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiKVwiO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgY2xvbmUgPSB2ZWM0LmNsb25lO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBjb3B5ID0gdmVjNC5jb3B5O1xuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNldCA9IHZlYzQuc2V0O1xuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgYWRkID0gdmVjNC5hZGQ7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNjYWxlID0gdmVjNC5zY2FsZTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZG90ID0gdmVjNC5kb3Q7XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGxlcnAgPSB2ZWM0LmxlcnA7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgdmFyIGxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgdmFyIGV4YWN0RXF1YWxzID0gdmVjNC5leGFjdEVxdWFscztcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCB2YXIgZXF1YWxzID0gdmVjNC5lcXVhbHM7XG4vKipcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcbiAqIHZlY3RvciB0byBhbm90aGVyLlxuICpcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgdmFyIHJvdGF0aW9uVG8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLCAwLCAwKTtcbiAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG5cbiAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICBpZiAodmVjMy5sZW4odG1wdmVjMykgPCAwLjAwMDAwMSkgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICBzZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgb3V0WzBdID0gMDtcbiAgICAgIG91dFsxXSA9IDA7XG4gICAgICBvdXRbMl0gPSAwO1xuICAgICAgb3V0WzNdID0gMTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgfVxuICB9O1xufSgpO1xuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCB2YXIgc3FsZXJwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGVtcDEgPSBjcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgc2xlcnAodGVtcDEsIGEsIGQsIHQpO1xuICAgIHNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBzbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpO1xuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCB2YXIgc2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICBtYXRyWzZdID0gcmlnaHRbMl07XG4gICAgbWF0clsxXSA9IHVwWzBdO1xuICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICBtYXRyWzddID0gdXBbMl07XG4gICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICBtYXRyWzhdID0gLXZpZXdbMl07XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIGZyb21NYXQzKG91dCwgbWF0cikpO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0ICogYXMgcXVhdCBmcm9tIFwiLi9xdWF0LmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL21hdDQuanNcIjtcbi8qKlxuICogRHVhbCBRdWF0ZXJuaW9uPGJyPlxuICogRm9ybWF0OiBbcmVhbCwgZHVhbF08YnI+XG4gKiBRdWF0ZXJuaW9uIGZvcm1hdDogWFlaVzxicj5cbiAqIE1ha2Ugc3VyZSB0byBoYXZlIG5vcm1hbGl6ZWQgZHVhbCBxdWF0ZXJuaW9ucywgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbnMgbWF5IG5vdCB3b3JrIGFzIGludGVuZGVkLjxicj5cbiAqIEBtb2R1bGUgcXVhdDJcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgZHVhbCBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXQyfSBhIG5ldyBkdWFsIHF1YXRlcm5pb24gW3JlYWwgLT4gcm90YXRpb24sIGR1YWwgLT4gdHJhbnNsYXRpb25dXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgZHFbMF0gPSAwO1xuICAgIGRxWzFdID0gMDtcbiAgICBkcVsyXSA9IDA7XG4gICAgZHFbNF0gPSAwO1xuICAgIGRxWzVdID0gMDtcbiAgICBkcVs2XSA9IDA7XG4gICAgZHFbN10gPSAwO1xuICB9XG5cbiAgZHFbM10gPSAxO1xuICByZXR1cm4gZHE7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG5ldyBkdWFsIHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IGFbMF07XG4gIGRxWzFdID0gYVsxXTtcbiAgZHFbMl0gPSBhWzJdO1xuICBkcVszXSA9IGFbM107XG4gIGRxWzRdID0gYVs0XTtcbiAgZHFbNV0gPSBhWzVdO1xuICBkcVs2XSA9IGFbNl07XG4gIGRxWzddID0gYVs3XTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHoxIFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkyIFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MiBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXQyfSBuZXcgZHVhbCBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6MiwgdzIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIGRxWzRdID0geDI7XG4gIGRxWzVdID0geTI7XG4gIGRxWzZdID0gejI7XG4gIGRxWzddID0gdzI7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBkdWFsIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gdmFsdWVzIChxdWF0IGFuZCB0cmFuc2xhdGlvbilcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHoxIFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBYIGNvbXBvbmVudCAodHJhbnNsYXRpb24pXG4gKiBAcGFyYW0ge051bWJlcn0geTIgWSBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50ICh0cmFuc2xhdGlvbilcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzKHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IHgxO1xuICBkcVsxXSA9IHkxO1xuICBkcVsyXSA9IHoxO1xuICBkcVszXSA9IHcxO1xuICB2YXIgYXggPSB4MiAqIDAuNSxcbiAgICAgIGF5ID0geTIgKiAwLjUsXG4gICAgICBheiA9IHoyICogMC41O1xuICBkcVs0XSA9IGF4ICogdzEgKyBheSAqIHoxIC0gYXogKiB5MTtcbiAgZHFbNV0gPSBheSAqIHcxICsgYXogKiB4MSAtIGF4ICogejE7XG4gIGRxWzZdID0gYXogKiB3MSArIGF4ICogeTEgLSBheSAqIHgxO1xuICBkcVs3XSA9IC1heCAqIHgxIC0gYXkgKiB5MSAtIGF6ICogejE7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGR1YWwgcXVhdCBmcm9tIGEgcXVhdGVybmlvbiBhbmQgYSB0cmFuc2xhdGlvblxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBhIG5vcm1hbGl6ZWQgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHQgdHJhbmxhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB0KSB7XG4gIHZhciBheCA9IHRbMF0gKiAwLjUsXG4gICAgICBheSA9IHRbMV0gKiAwLjUsXG4gICAgICBheiA9IHRbMl0gKiAwLjUsXG4gICAgICBieCA9IHFbMF0sXG4gICAgICBieSA9IHFbMV0sXG4gICAgICBieiA9IHFbMl0sXG4gICAgICBidyA9IHFbM107XG4gIG91dFswXSA9IGJ4O1xuICBvdXRbMV0gPSBieTtcbiAgb3V0WzJdID0gYno7XG4gIG91dFszXSA9IGJ3O1xuICBvdXRbNF0gPSBheCAqIGJ3ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFs1XSA9IGF5ICogYncgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbN10gPSAtYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZHVhbCBxdWF0IGZyb20gYSB0cmFuc2xhdGlvblxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdCB0cmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB0WzBdICogMC41O1xuICBvdXRbNV0gPSB0WzFdICogMC41O1xuICBvdXRbNl0gPSB0WzJdICogMC41O1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZHVhbCBxdWF0IGZyb20gYSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHRoZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHEpIHtcbiAgb3V0WzBdID0gcVswXTtcbiAgb3V0WzFdID0gcVsxXTtcbiAgb3V0WzJdID0gcVsyXTtcbiAgb3V0WzNdID0gcVszXTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBkdWFsIHF1YXQgZnJvbSBhIG1hdHJpeCAoNHg0KVxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgZHVhbCBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICAvL1RPRE8gT3B0aW1pemUgdGhpc1xuICB2YXIgb3V0ZXIgPSBxdWF0LmNyZWF0ZSgpO1xuICBtYXQ0LmdldFJvdGF0aW9uKG91dGVyLCBhKTtcbiAgdmFyIHQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgbWF0NC5nZXRUcmFuc2xhdGlvbih0LCBhKTtcbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBvdXRlciwgdCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBkdWFsIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBzb3VyY2UgZHVhbCBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCBhIGR1YWwgcXVhdCB0byB0aGUgaWRlbnRpdHkgZHVhbCBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHgxIFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geTEgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFcgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geDIgWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdzIgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIsIHcyKSB7XG4gIG91dFswXSA9IHgxO1xuICBvdXRbMV0gPSB5MTtcbiAgb3V0WzJdID0gejE7XG4gIG91dFszXSA9IHcxO1xuICBvdXRbNF0gPSB4MjtcbiAgb3V0WzVdID0geTI7XG4gIG91dFs2XSA9IHoyO1xuICBvdXRbN10gPSB3MjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2V0cyB0aGUgcmVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XG4gKiBAcGFyYW0gIHtxdWF0fSBvdXQgcmVhbCBwYXJ0XG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvblxuICogQHJldHVybiB7cXVhdH0gcmVhbCBwYXJ0XG4gKi9cblxuZXhwb3J0IHZhciBnZXRSZWFsID0gcXVhdC5jb3B5O1xuLyoqXG4gKiBHZXRzIHRoZSBkdWFsIHBhcnQgb2YgYSBkdWFsIHF1YXRcbiAqIEBwYXJhbSAge3F1YXR9IG91dCBkdWFsIHBhcnRcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXG4gKiBAcmV0dXJuIHtxdWF0fSBkdWFsIHBhcnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHVhbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVs0XTtcbiAgb3V0WzFdID0gYVs1XTtcbiAgb3V0WzJdID0gYVs2XTtcbiAgb3V0WzNdID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSByZWFsIGNvbXBvbmVudCBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJlYWwgcGFydFxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc2V0UmVhbCA9IHF1YXQuY29weTtcbi8qKlxuICogU2V0IHRoZSBkdWFsIGNvbXBvbmVudCBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIGR1YWwgcGFydFxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXREdWFsKG91dCwgcSkge1xuICBvdXRbNF0gPSBxWzBdO1xuICBvdXRbNV0gPSBxWzFdO1xuICBvdXRbNl0gPSBxWzJdO1xuICBvdXRbN10gPSBxWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZXRzIHRoZSB0cmFuc2xhdGlvbiBvZiBhIG5vcm1hbGl6ZWQgZHVhbCBxdWF0XG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgdHJhbnNsYXRpb25cbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcbiAqIEByZXR1cm4ge3ZlYzN9IHRyYW5zbGF0aW9uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgYSkge1xuICB2YXIgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdO1xuICBvdXRbMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICBvdXRbMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICBvdXRbMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2xhdGVzIGEgZHVhbCBxdWF0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYXgxID0gYVswXSxcbiAgICAgIGF5MSA9IGFbMV0sXG4gICAgICBhejEgPSBhWzJdLFxuICAgICAgYXcxID0gYVszXSxcbiAgICAgIGJ4MSA9IHZbMF0gKiAwLjUsXG4gICAgICBieTEgPSB2WzFdICogMC41LFxuICAgICAgYnoxID0gdlsyXSAqIDAuNSxcbiAgICAgIGF4MiA9IGFbNF0sXG4gICAgICBheTIgPSBhWzVdLFxuICAgICAgYXoyID0gYVs2XSxcbiAgICAgIGF3MiA9IGFbN107XG4gIG91dFswXSA9IGF4MTtcbiAgb3V0WzFdID0gYXkxO1xuICBvdXRbMl0gPSBhejE7XG4gIG91dFszXSA9IGF3MTtcbiAgb3V0WzRdID0gYXcxICogYngxICsgYXkxICogYnoxIC0gYXoxICogYnkxICsgYXgyO1xuICBvdXRbNV0gPSBhdzEgKiBieTEgKyBhejEgKiBieDEgLSBheDEgKiBiejEgKyBheTI7XG4gIG91dFs2XSA9IGF3MSAqIGJ6MSArIGF4MSAqIGJ5MSAtIGF5MSAqIGJ4MSArIGF6MjtcbiAgb3V0WzddID0gLWF4MSAqIGJ4MSAtIGF5MSAqIGJ5MSAtIGF6MSAqIGJ6MSArIGF3MjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGhvdyBmYXIgc2hvdWxkIHRoZSByb3RhdGlvbiBiZVxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVYKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgaG93IGZhciBzaG91bGQgdGhlIHJvdGF0aW9uIGJlXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBheDEgPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxuICAgICAgYXkxID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcbiAgICAgIGF6MSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsXG4gICAgICBhdzEgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICBxdWF0LnJvdGF0ZVkob3V0LCBhLCByYWQpO1xuICBieCA9IG91dFswXTtcbiAgYnkgPSBvdXRbMV07XG4gIGJ6ID0gb3V0WzJdO1xuICBidyA9IG91dFszXTtcbiAgb3V0WzRdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFs1XSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbNl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzddID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGF4MSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksXG4gICAgICBheTEgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxuICAgICAgYXoxID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgIGF3MSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHF1YXQucm90YXRlWihvdXQsIGEsIHJhZCk7XG4gIGJ4ID0gb3V0WzBdO1xuICBieSA9IG91dFsxXTtcbiAgYnogPSBvdXRbMl07XG4gIGJ3ID0gb3V0WzNdO1xuICBvdXRbNF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzVdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFs2XSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbN10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKGEgKiBxKVxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZSBieVxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlQnlRdWF0QXBwZW5kKG91dCwgYSwgcSkge1xuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdLFxuICAgICAgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCAqIHF3ICsgYXcgKiBxeCArIGF5ICogcXogLSBheiAqIHF5O1xuICBvdXRbMV0gPSBheSAqIHF3ICsgYXcgKiBxeSArIGF6ICogcXggLSBheCAqIHF6O1xuICBvdXRbMl0gPSBheiAqIHF3ICsgYXcgKiBxeiArIGF4ICogcXkgLSBheSAqIHF4O1xuICBvdXRbM10gPSBhdyAqIHF3IC0gYXggKiBxeCAtIGF5ICogcXkgLSBheiAqIHF6O1xuICBheCA9IGFbNF07XG4gIGF5ID0gYVs1XTtcbiAgYXogPSBhWzZdO1xuICBhdyA9IGFbN107XG4gIG91dFs0XSA9IGF4ICogcXcgKyBhdyAqIHF4ICsgYXkgKiBxeiAtIGF6ICogcXk7XG4gIG91dFs1XSA9IGF5ICogcXcgKyBhdyAqIHF5ICsgYXogKiBxeCAtIGF4ICogcXo7XG4gIG91dFs2XSA9IGF6ICogcXcgKyBhdyAqIHF6ICsgYXggKiBxeSAtIGF5ICogcXg7XG4gIG91dFs3XSA9IGF3ICogcXcgLSBheCAqIHF4IC0gYXkgKiBxeSAtIGF6ICogcXo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYnkgYSBnaXZlbiBxdWF0ZXJuaW9uIChxICogYSlcbiAqXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdFByZXBlbmQob3V0LCBxLCBhKSB7XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM10sXG4gICAgICBieCA9IGFbMF0sXG4gICAgICBieSA9IGFbMV0sXG4gICAgICBieiA9IGFbMl0sXG4gICAgICBidyA9IGFbM107XG4gIG91dFswXSA9IHF4ICogYncgKyBxdyAqIGJ4ICsgcXkgKiBieiAtIHF6ICogYnk7XG4gIG91dFsxXSA9IHF5ICogYncgKyBxdyAqIGJ5ICsgcXogKiBieCAtIHF4ICogYno7XG4gIG91dFsyXSA9IHF6ICogYncgKyBxdyAqIGJ6ICsgcXggKiBieSAtIHF5ICogYng7XG4gIG91dFszXSA9IHF3ICogYncgLSBxeCAqIGJ4IC0gcXkgKiBieSAtIHF6ICogYno7XG4gIGJ4ID0gYVs0XTtcbiAgYnkgPSBhWzVdO1xuICBieiA9IGFbNl07XG4gIGJ3ID0gYVs3XTtcbiAgb3V0WzRdID0gcXggKiBidyArIHF3ICogYnggKyBxeSAqIGJ6IC0gcXogKiBieTtcbiAgb3V0WzVdID0gcXkgKiBidyArIHF3ICogYnkgKyBxeiAqIGJ4IC0gcXggKiBiejtcbiAgb3V0WzZdID0gcXogKiBidyArIHF3ICogYnogKyBxeCAqIGJ5IC0gcXkgKiBieDtcbiAgb3V0WzddID0gcXcgKiBidyAtIHF4ICogYnggLSBxeSAqIGJ5IC0gcXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgYSBnaXZlbiBheGlzLiBEb2VzIHRoZSBub3JtYWxpc2F0aW9uIGF1dG9tYXRpY2FsbHlcbiAqXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBob3cgZmFyIHRoZSByb3RhdGlvbiBzaG91bGQgYmVcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUFyb3VuZEF4aXMob3V0LCBhLCBheGlzLCByYWQpIHtcbiAgLy9TcGVjaWFsIGNhc2UgZm9yIHJhZCA9IDBcbiAgaWYgKE1hdGguYWJzKHJhZCkgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGNvcHkob3V0LCBhKTtcbiAgfVxuXG4gIHZhciBheGlzTGVuZ3RoID0gTWF0aC5oeXBvdChheGlzWzBdLCBheGlzWzFdLCBheGlzWzJdKTtcbiAgcmFkID0gcmFkICogMC41O1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBieCA9IHMgKiBheGlzWzBdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ5ID0gcyAqIGF4aXNbMV0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYnogPSBzICogYXhpc1syXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBidyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBheDEgPSBhWzBdLFxuICAgICAgYXkxID0gYVsxXSxcbiAgICAgIGF6MSA9IGFbMl0sXG4gICAgICBhdzEgPSBhWzNdO1xuICBvdXRbMF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzFdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFsyXSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbM10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgdmFyIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgb3V0WzRdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzVdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzddID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gZHVhbCBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gZHVhbCBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBheDAgPSBhWzBdLFxuICAgICAgYXkwID0gYVsxXSxcbiAgICAgIGF6MCA9IGFbMl0sXG4gICAgICBhdzAgPSBhWzNdLFxuICAgICAgYngxID0gYls0XSxcbiAgICAgIGJ5MSA9IGJbNV0sXG4gICAgICBiejEgPSBiWzZdLFxuICAgICAgYncxID0gYls3XSxcbiAgICAgIGF4MSA9IGFbNF0sXG4gICAgICBheTEgPSBhWzVdLFxuICAgICAgYXoxID0gYVs2XSxcbiAgICAgIGF3MSA9IGFbN10sXG4gICAgICBieDAgPSBiWzBdLFxuICAgICAgYnkwID0gYlsxXSxcbiAgICAgIGJ6MCA9IGJbMl0sXG4gICAgICBidzAgPSBiWzNdO1xuICBvdXRbMF0gPSBheDAgKiBidzAgKyBhdzAgKiBieDAgKyBheTAgKiBiejAgLSBhejAgKiBieTA7XG4gIG91dFsxXSA9IGF5MCAqIGJ3MCArIGF3MCAqIGJ5MCArIGF6MCAqIGJ4MCAtIGF4MCAqIGJ6MDtcbiAgb3V0WzJdID0gYXowICogYncwICsgYXcwICogYnowICsgYXgwICogYnkwIC0gYXkwICogYngwO1xuICBvdXRbM10gPSBhdzAgKiBidzAgLSBheDAgKiBieDAgLSBheTAgKiBieTAgLSBhejAgKiBiejA7XG4gIG91dFs0XSA9IGF4MCAqIGJ3MSArIGF3MCAqIGJ4MSArIGF5MCAqIGJ6MSAtIGF6MCAqIGJ5MSArIGF4MSAqIGJ3MCArIGF3MSAqIGJ4MCArIGF5MSAqIGJ6MCAtIGF6MSAqIGJ5MDtcbiAgb3V0WzVdID0gYXkwICogYncxICsgYXcwICogYnkxICsgYXowICogYngxIC0gYXgwICogYnoxICsgYXkxICogYncwICsgYXcxICogYnkwICsgYXoxICogYngwIC0gYXgxICogYnowO1xuICBvdXRbNl0gPSBhejAgKiBidzEgKyBhdzAgKiBiejEgKyBheDAgKiBieTEgLSBheTAgKiBieDEgKyBhejEgKiBidzAgKyBhdzEgKiBiejAgKyBheDEgKiBieTAgLSBheTEgKiBieDA7XG4gIG91dFs3XSA9IGF3MCAqIGJ3MSAtIGF4MCAqIGJ4MSAtIGF5MCAqIGJ5MSAtIGF6MCAqIGJ6MSArIGF3MSAqIGJ3MCAtIGF4MSAqIGJ4MCAtIGF5MSAqIGJ5MCAtIGF6MSAqIGJ6MDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIFNjYWxlcyBhIGR1YWwgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIGR1YWwgcXVhdCBieVxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gZHVhbCBxdWF0J3MgKFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgcmVhbCBwYXJ0cylcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZG90ID0gcXVhdC5kb3Q7XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gZHVhbCBxdWF0cydzXG4gKiBOT1RFOiBUaGUgcmVzdWx0aW5nIGR1YWwgcXVhdGVybmlvbnMgd29uJ3QgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgKFRoZSBlcnJvciBpcyBtb3N0IG5vdGljZWFibGUgd2hlbiB0ID0gMC41KVxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdFxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgbXQgPSAxIC0gdDtcbiAgaWYgKGRvdChhLCBiKSA8IDApIHQgPSAtdDtcbiAgb3V0WzBdID0gYVswXSAqIG10ICsgYlswXSAqIHQ7XG4gIG91dFsxXSA9IGFbMV0gKiBtdCArIGJbMV0gKiB0O1xuICBvdXRbMl0gPSBhWzJdICogbXQgKyBiWzJdICogdDtcbiAgb3V0WzNdID0gYVszXSAqIG10ICsgYlszXSAqIHQ7XG4gIG91dFs0XSA9IGFbNF0gKiBtdCArIGJbNF0gKiB0O1xuICBvdXRbNV0gPSBhWzVdICogbXQgKyBiWzVdICogdDtcbiAgb3V0WzZdID0gYVs2XSAqIG10ICsgYls2XSAqIHQ7XG4gIG91dFs3XSA9IGFbN10gKiBtdCArIGJbN10gKiB0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgZHVhbCBxdWF0LiBJZiB0aGV5IGFyZSBub3JtYWxpemVkLCBjb25qdWdhdGUgaXMgY2hlYXBlclxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgc3FsZW4gPSBzcXVhcmVkTGVuZ3RoKGEpO1xuICBvdXRbMF0gPSAtYVswXSAvIHNxbGVuO1xuICBvdXRbMV0gPSAtYVsxXSAvIHNxbGVuO1xuICBvdXRbMl0gPSAtYVsyXSAvIHNxbGVuO1xuICBvdXRbM10gPSBhWzNdIC8gc3FsZW47XG4gIG91dFs0XSA9IC1hWzRdIC8gc3FsZW47XG4gIG91dFs1XSA9IC1hWzVdIC8gc3FsZW47XG4gIG91dFs2XSA9IC1hWzZdIC8gc3FsZW47XG4gIG91dFs3XSA9IGFbN10gLyBzcWxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgZHVhbCBxdWF0XG4gKiBJZiB0aGUgZHVhbCBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdDIuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gLWFbNF07XG4gIG91dFs1XSA9IC1hWzVdO1xuICBvdXRbNl0gPSAtYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgZHVhbCBxdWF0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBsZW5ndGggPSBxdWF0Lmxlbmd0aDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBkdWFsIHF1YXRcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXVhcmVkTGVuZ3RoID0gcXVhdC5zcXVhcmVkTGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcbiAqIE5vcm1hbGl6ZSBhIGR1YWwgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgbWFnbml0dWRlID0gc3F1YXJlZExlbmd0aChhKTtcblxuICBpZiAobWFnbml0dWRlID4gMCkge1xuICAgIG1hZ25pdHVkZSA9IE1hdGguc3FydChtYWduaXR1ZGUpO1xuICAgIHZhciBhMCA9IGFbMF0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGExID0gYVsxXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTIgPSBhWzJdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMyA9IGFbM10gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGIwID0gYVs0XTtcbiAgICB2YXIgYjEgPSBhWzVdO1xuICAgIHZhciBiMiA9IGFbNl07XG4gICAgdmFyIGIzID0gYVs3XTtcbiAgICB2YXIgYV9kb3RfYiA9IGEwICogYjAgKyBhMSAqIGIxICsgYTIgKiBiMiArIGEzICogYjM7XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gKGIwIC0gYTAgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbNV0gPSAoYjEgLSBhMSAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs2XSA9IChiMiAtIGEyICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzddID0gKGIzIC0gYTMgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkdWFsIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGR1YWwgcXVhdFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJxdWF0MihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGR1YWwgcXVhdGVybmlvbnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3QgZHVhbCBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgZHVhbCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdGVybmlvbnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZHVhbCBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXQuXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBkdWFsIHF1YXQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgZHVhbCBxdWF0cyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSk7XG59IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcbiAqIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbW9kdWxlIHZlYzJcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSkge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGIsIHJhZCkge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgY29zQyA9IE1hdGguY29zKHJhZCk7IC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSBwMCAqIGNvc0MgLSBwMSAqIHNpbkMgKyBiWzBdO1xuICBvdXRbMV0gPSBwMCAqIHNpbkMgKyBwMSAqIGNvc0MgKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIHgxID0gYVswXSxcbiAgICAgIHkxID0gYVsxXSxcbiAgICAgIHgyID0gYlswXSxcbiAgICAgIHkyID0gYlsxXSxcbiAgICAgIC8vIG1hZyBpcyB0aGUgcHJvZHVjdCBvZiB0aGUgbWFnbml0dWRlcyBvZiBhIGFuZCBiXG4gIG1hZyA9IE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSkgKiBNYXRoLnNxcnQoeDIgKiB4MiArIHkyICogeTIpLFxuICAgICAgLy8gbWFnICYmLi4gc2hvcnQgY2lyY3VpdHMgaWYgbWFnID09IDBcbiAgY29zaW5lID0gbWFnICYmICh4MSAqIHgyICsgeTEgKiB5MikgLyBtYWc7IC8vIE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSBjbGFtcHMgdGhlIGNvc2luZSBiZXR3ZWVuIC0xIGFuZCAxXG5cbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHplcm9cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl07XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl07XG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICB2YXIgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wO1xuICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkdWFsIHF1YXRlcm5pb25zLiAoTXVsdGlwbHkgaXQgd2l0aCB0aGUgcmVhbCBwYXJ0KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTsgLy8gdmFyIHF2ZWMgPSBbcXgsIHF5LCBxel07XG4gIC8vIHZhciB1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIGEpO1xuXG4gIHZhciB1dnggPSBxeSAqIHogLSBxeiAqIHksXG4gICAgICB1dnkgPSBxeiAqIHggLSBxeCAqIHosXG4gICAgICB1dnogPSBxeCAqIHkgLSBxeSAqIHg7IC8vIHZhciB1dXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCB1dik7XG5cbiAgdmFyIHV1dnggPSBxeSAqIHV2eiAtIHF6ICogdXZ5LFxuICAgICAgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dnosXG4gICAgICB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDsgLy8gdmVjMy5zY2FsZSh1diwgdXYsIDIgKiB3KTtcblxuICB2YXIgdzIgPSBxdyAqIDI7XG4gIHV2eCAqPSB3MjtcbiAgdXZ5ICo9IHcyO1xuICB1dnogKj0gdzI7IC8vIHZlYzMuc2NhbGUodXV2LCB1dXYsIDIpO1xuXG4gIHV1dnggKj0gMjtcbiAgdXV2eSAqPSAyO1xuICB1dXZ6ICo9IDI7IC8vIHJldHVybiB2ZWMzLmFkZChvdXQsIGEsIHZlYzMuYWRkKG91dCwgdXYsIHV1dikpO1xuXG4gIG91dFswXSA9IHggKyB1dnggKyB1dXZ4O1xuICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgb3V0WzJdID0geiArIHV2eiArIHV1dno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKHJhZCkgLSBwWzJdICogTWF0aC5zaW4ocmFkKTtcbiAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihyYWQpICsgcFsyXSAqIE1hdGguY29zKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzJdID0gcFsyXTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopLFxuICAgICAgbWFnMiA9IE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnopLFxuICAgICAgbWFnID0gbWFnMSAqIG1hZzIsXG4gICAgICBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWM0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6LCB3KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeiwgdykge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguY2VpbChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgdmFyIHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xufVxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSB4ICogbGVuO1xuICBvdXRbMV0gPSB5ICogbGVuO1xuICBvdXRbMl0gPSB6ICogbGVuO1xuICBvdXRbM10gPSB3ICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGNyb3NzLXByb2R1Y3Qgb2YgdGhyZWUgdmVjdG9ycyBpbiBhIDQtZGltZW5zaW9uYWwgc3BhY2VcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gcmVzdWx0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gVSB0aGUgZmlyc3QgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gViB0aGUgc2Vjb25kIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFcgdGhlIHRoaXJkIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IHJlc3VsdFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIHUsIHYsIHcpIHtcbiAgdmFyIEEgPSB2WzBdICogd1sxXSAtIHZbMV0gKiB3WzBdLFxuICAgICAgQiA9IHZbMF0gKiB3WzJdIC0gdlsyXSAqIHdbMF0sXG4gICAgICBDID0gdlswXSAqIHdbM10gLSB2WzNdICogd1swXSxcbiAgICAgIEQgPSB2WzFdICogd1syXSAtIHZbMl0gKiB3WzFdLFxuICAgICAgRSA9IHZbMV0gKiB3WzNdIC0gdlszXSAqIHdbMV0sXG4gICAgICBGID0gdlsyXSAqIHdbM10gLSB2WzNdICogd1syXTtcbiAgdmFyIEcgPSB1WzBdO1xuICB2YXIgSCA9IHVbMV07XG4gIHZhciBJID0gdVsyXTtcbiAgdmFyIEogPSB1WzNdO1xuICBvdXRbMF0gPSBIICogRiAtIEkgKiBFICsgSiAqIEQ7XG4gIG91dFsxXSA9IC0oRyAqIEYpICsgSSAqIEMgLSBKICogQjtcbiAgb3V0WzJdID0gRyAqIEUgLSBIICogQyArIEogKiBBO1xuICBvdXRbM10gPSAtKEcgKiBEKSArIEggKiBCIC0gSSAqIEE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgdmFyIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wOyAvLyBNYXJzYWdsaWEsIEdlb3JnZS4gQ2hvb3NpbmcgYSBQb2ludCBmcm9tIHRoZSBTdXJmYWNlIG9mIGFcbiAgLy8gU3BoZXJlLiBBbm4uIE1hdGguIFN0YXRpc3QuIDQzICgxOTcyKSwgbm8uIDIsIDY0NS0tNjQ2LlxuICAvLyBodHRwOi8vcHJvamVjdGV1Y2xpZC5vcmcvZXVjbGlkLmFvbXMvMTE3NzY5MjY0NDtcblxuICB2YXIgdjEsIHYyLCB2MywgdjQ7XG4gIHZhciBzMSwgczI7XG5cbiAgZG8ge1xuICAgIHYxID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2MiA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczEgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgfSB3aGlsZSAoczEgPj0gMSk7XG5cbiAgZG8ge1xuICAgIHYzID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2NCA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczIgPSB2MyAqIHYzICsgdjQgKiB2NDtcbiAgfSB3aGlsZSAoczIgPj0gMSk7XG5cbiAgdmFyIGQgPSBNYXRoLnNxcnQoKDEgLSBzMSkgLyBzMik7XG4gIG91dFswXSA9IHNjYWxlICogdjE7XG4gIG91dFsxXSA9IHNjYWxlICogdjI7XG4gIG91dFsyXSA9IHNjYWxlICogdjMgKiBkO1xuICBvdXRbM10gPSBzY2FsZSAqIHY0ICogZDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdLFxuICAgICAgdyA9IGFbM107XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM107IC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG5cbiAgdmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgdmFyIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejsgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICB2ZWNbM10gPSBhW2kgKyAzXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgICBhW2kgKyAzXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgeyBzaG93RXJyb3IsIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlciwgZ2V0Q29udGV4dCwgY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIsIGNyZWF0ZVByb2dyYW19IGZyb20gXCIuL3V0aWxzL2dsLXV0aWxzXCJcbmltcG9ydCB7IENVQkVfSU5ESUNFUywgQ1VCRV9WRVJUSUNFUywgVEFCTEVfVkVSVElDRVMsIFRBQkxFX0lORElDRVMsIGNyZWF0ZTNkUG9zQ29sb3JJbnRlcmxlYXZlZFZhbywgUFlSQU1JRF9JTkRJQ0VTLCBQWVJBTUlEX1ZFUlRJQ0VTLCBTcGhlcmUgfSBmcm9tIFwiLi9nZW9tZXRyeVwiO1xuaW1wb3J0IHsgZ2xNYXRyaXgsIG1hdDQsIHF1YXQsIFJlYWRvbmx5VmVjMywgdmVjMywgdmVjNCB9IGZyb20gXCJnbC1tYXRyaXhcIjtcbmltcG9ydCB7IFVzZXJDb250cm9sbGVyIH0gZnJvbSBcIi4vY29udHJvbGxlcnMvVXNlckNvbnRyb2xsZXJcIjtcbmltcG9ydCB7IEFwaUNsaWVudCB9IGZyb20gXCIuL3NlcnZpY2VzL0FwaUNsaWVudFwiO1xuaW1wb3J0IHBsYW5ldERhdGEgZnJvbSBcIi4vY29uZmlnL2FzdHJvb2JqZWN0ZGF0YS5qc29uXCI7XG5pbXBvcnQgeyBBc3Ryb09iamVjdENvbmZpZyB9IGZyb20gXCIuL2ludGVyZmFjZXMvQXN0cm9PYmplY3RDb25maWdcIjtcbmltcG9ydCB7IExPRE1hbmFnZXIgfSBmcm9tIFwiLi9tb2RlbHMvTE9ETWFuYWdlclwiO1xuaW1wb3J0IHsgV2ViR0xTaGFwZSB9IGZyb20gXCIuL21vZGVscy9XZWJHTFNoYXBlXCI7XG5pbXBvcnQgeyBBc3Ryb09iamVjdCB9IGZyb20gXCIuL21vZGVscy9Bc3Ryb09iamVjdFwiO1xuaW1wb3J0IHsgQXN0cm9TeXN0ZW0gfSBmcm9tIFwiLi9tb2RlbHMvQXN0cm9TeXN0ZW1cIjtcbmltcG9ydCAgKiBhcyBiVmVjMyAgZnJvbSBcIi4vdXRpbHMvYmlnLXZlYzNcIjtcbmltcG9ydCB7IEJpZ0RlY2ltYWwsIEJpZywgTWF0aENvbnRleHQsIE1DIH0gZnJvbSBcImJpZ2RlY2ltYWwuanNcIjtcblxuY29uc3QgRyA9ICg2LjY3NDMqKDEwKiotMTEpKTtcblxuY29uc3QgdmVydGV4U2hhZGVyU291cmNlQ29kZSA9IGAjdmVyc2lvbiAzMDAgZXNcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBcbiAgICBpbiB2ZWMzIHZlcnRleFBvc2l0aW9uO1xuICAgIGluIHZlYzMgdmVydGV4Q29sb3I7XG5cbiAgICBvdXQgdmVjMyBmcmFnbWVudENvbG9yO1xuXG4gICAgdW5pZm9ybSBtYXQ0IG1hdFdvcmxkO1xuICAgIHVuaWZvcm0gbWF0NCBtYXRWaWV3UHJvajtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZnJhZ21lbnRDb2xvciA9IHZlcnRleENvbG9yO1xuXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gbWF0Vmlld1Byb2ogKiBtYXRXb3JsZCAqIHZlYzQodmVydGV4UG9zaXRpb24sIDEuMCk7XG4gICAgfWA7XG5cbmNvbnN0IGZyYWdtZW50U2hhZGVyU291cmNlQ29kZSA9IGAjdmVyc2lvbiAzMDAgZXNcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBcbiAgICBpbiB2ZWMzIGZyYWdtZW50Q29sb3I7XG4gICAgb3V0IHZlYzQgb3V0cHV0Q29sb3I7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIG91dHB1dENvbG9yID0gdmVjNChmcmFnbWVudENvbG9yLCAxLjApO1xuICAgIH1gO1xuXG5sZXQgdXNlciA9IG5ldyBVc2VyQ29udHJvbGxlcigpO1xuXG5cbmZ1bmN0aW9uIHNjcm9sbEZ1bmMoKSB7XG59XG5sZXQgbW92ZUZvcndhcmQgPSBmYWxzZVxubGV0IG1vdmVCYWNrd2FyZCA9IGZhbHNlXG5sZXQgbW92ZVJpZ2h0ID0gZmFsc2VcbmxldCBtb3ZlTGVmdCA9IGZhbHNlXG5sZXQgbW92ZVVwID0gZmFsc2VcbmxldCBtb3ZlRG93biA9IGZhbHNlXG5mdW5jdGlvbiBrZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpe1xuICAgIGlmKHVzZXIuaXNNb3ZpbmcgPT0gZmFsc2UpIHtcbiAgICAgICAgdXNlci5pc01vdmluZyA9IHRydWVcbiAgICB9XG4gICAgaWYoZS5jb2RlID09IFwiS2V5V1wiKSB7XG4gICAgICAgIHVzZXIudmVsb2NpdHlbMl0gPSB1c2VyLnNwZWVkXG4gICAgfVxuICAgIGlmKGUuY29kZSA9PSBcIktleVNcIikge1xuICAgICAgICB1c2VyLnZlbG9jaXR5WzJdID0gLXVzZXIuc3BlZWRcbiAgICB9XG4gICAgaWYoZS5jb2RlID09IFwiS2V5RFwiKSB7XG4gICAgICAgIHVzZXIudmVsb2NpdHlbMF0gPSB1c2VyLnNwZWVkXG4gICAgfVxuICAgIGlmKGUuY29kZSA9PSBcIktleUFcIikge1xuICAgICAgICB1c2VyLnZlbG9jaXR5WzBdID0gLXVzZXIuc3BlZWRcbiAgICB9XG4gICAgaWYoZS5jb2RlID09IFwiU3BhY2VcIikge1xuICAgICAgICB1c2VyLnZlbG9jaXR5WzFdID0gdXNlci5zcGVlZFxuICAgIH1cbiAgICBpZihlLmNvZGUgPT0gXCJDb250cm9sTGVmdFwiKSB7XG4gICAgICAgIHVzZXIudmVsb2NpdHlbMV0gPSAtdXNlci5zcGVlZFxuICAgIH1cbiAgICBpZihlLmNvZGUgPT0gXCJLZXlCXCIpIHtcbiAgICBcdGlmKHVzZXIuc3BlZWQgPj0gMC4xKSB7XG5cdFx0dXNlci5zcGVlZCAtPSAwLjFcblx0fSBlbHNlIHtcblx0XHR1c2VyLnNwZWVkIC09IDAuMDAxXG5cdH1cbiAgICB9XG59XG5mdW5jdGlvbiBrZXlVcChlOiBLZXlib2FyZEV2ZW50KXtcbiAgICBpZihlLmNvZGUgPT0gXCJLZXlXXCIpIHtcbiAgICAgICAgdXNlci52ZWxvY2l0eVsyXSA9IDBcbiAgICB9XG4gICAgaWYoZS5jb2RlID09IFwiS2V5U1wiKSB7XG4gICAgICAgIHVzZXIudmVsb2NpdHlbMl0gPSAwXG4gICAgfVxuICAgIGlmKGUuY29kZSA9PSBcIktleURcIikge1xuICAgICAgICB1c2VyLnZlbG9jaXR5WzBdID0gMFxuICAgIH1cbiAgICBpZihlLmNvZGUgPT0gXCJLZXlBXCIpIHtcbiAgICAgICAgdXNlci52ZWxvY2l0eVswXSA9IDBcbiAgICB9XG4gICAgaWYoZS5jb2RlID09IFwiU3BhY2VcIikge1xuICAgICAgICB1c2VyLnZlbG9jaXR5WzFdID0gMFxuICAgIH1cbiAgICBpZihlLmNvZGUgPT0gXCJDb250cm9sTGVmdFwiKSB7XG4gICAgICAgIHVzZXIudmVsb2NpdHlbMV0gPSAwXG4gICAgfSBcbn1cbmxldCByb3RhdGluZyA9IGZhbHNlXG5mdW5jdGlvbiBjbGljayhlOiBNb3VzZUV2ZW50KXtcbiAgICBpZihlLmJ1dHRvbiA9PSAxKSB7XG4gICAgICAgIGlmKHJvdGF0aW5nID09IGZhbHNlKSB7XG4gICAgICAgICAgICB1c2VyLnNldFVzZXJPcmllbnRhdGlvblswXSA9IGUub2Zmc2V0WFxuICAgICAgICAgICAgdXNlci5zZXRVc2VyT3JpZW50YXRpb25bMV0gPSBlLm9mZnNldFlcbiAgICAgICAgICAgIHVzZXIudGFyZ2V0VXNlck9yaWVudGF0aW9uWzBdID0gdXNlci5zZXRVc2VyT3JpZW50YXRpb25bMF1cbiAgICAgICAgICAgIHVzZXIudGFyZ2V0VXNlck9yaWVudGF0aW9uWzFdID0gdXNlci5zZXRVc2VyT3JpZW50YXRpb25bMV1cbiAgICAgICAgICAgIHJvdGF0aW5nID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2xpY2syKGU6IE1vdXNlRXZlbnQpe1xuICAgIGlmKGUuYnV0dG9uID09IDEpIHtcbiAgICAgICAgdXNlci50YXJnZXRVc2VyT3JpZW50YXRpb25bMF0gPSB1c2VyLnNldFVzZXJPcmllbnRhdGlvblswXVxuICAgICAgICB1c2VyLnRhcmdldFVzZXJPcmllbnRhdGlvblsxXSA9IHVzZXIuc2V0VXNlck9yaWVudGF0aW9uWzFdXG4gICAgICAgIHVzZXIucm90YXRpb25WZWNbMF0gPSAwXG4gICAgICAgIHVzZXIucm90YXRpb25WZWNbMV0gPSAwXG4gICAgICAgIHJvdGF0aW5nID0gZmFsc2VcbiAgICB9XG59XG5mdW5jdGlvbiByb3RhdGVDYW1lcmEoZTogTW91c2VFdmVudCl7XG4gICAgaWYocm90YXRpbmcgPT0gdHJ1ZSkge1xuICAgICAgICB1c2VyLnRhcmdldFVzZXJPcmllbnRhdGlvblswXSA9IGUub2Zmc2V0WFxuICAgICAgICB1c2VyLnRhcmdldFVzZXJPcmllbnRhdGlvblsxXSA9IGUub2Zmc2V0WVxuICAgICAgICAvL2NvbnNvbGUubG9nKHVzZXIuc2V0VXNlck9yaWVudGF0aW9uWzBdIC0gdXNlci50YXJnZXRVc2VyT3JpZW50YXRpb25bMF0sICB1c2VyLnNldFVzZXJPcmllbnRhdGlvblsxXSAtIHVzZXIudGFyZ2V0VXNlck9yaWVudGF0aW9uWzFdKVxuICAgICAgICB1c2VyLnJvdGF0aW9uVmVjWzBdID0gZS5tb3ZlbWVudFhcbiAgICAgICAgdXNlci5yb3RhdGlvblZlY1sxXSA9IGUubW92ZW1lbnRZXG4gICAgfVxufVxuZnVuY3Rpb24gd2hlZShlOiBXaGVlbEV2ZW50KSB7XG4gICAgaWYoZS5kZWx0YVkgPD0gLTEwMCkge1xuICAgICAgICBtb3ZlQmFja3dhcmQgPSBmYWxzZVxuICAgICAgICBtb3ZlRm9yd2FyZCA9IHRydWVcbiAgICB9XG4gICAgaWYoZS5kZWx0YVkgPj0gMTAwKSB7XG4gICAgICAgIG1vdmVGb3J3YXJkID0gZmFsc2VcbiAgICAgICAgbW92ZUJhY2t3YXJkID0gdHJ1ZVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG5cdFxuXHRcbi8vXHR2YXIgbG9hZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNsb2FkZXJcIikhO1xuICAgIFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlbW8tY2FudmFzJyk7XG4gICAgaWYgKCFjYW52YXMgfHwgIShjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpIHtcbiAgICAgICAgc2hvd0Vycm9yKCdDb3VsZCBub3QgZ2V0IENhbnZhcyByZWZlcmVuY2UnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgIHZhciBsb2FkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2xvYWRlclwiKSE7IFxuIFxuICAgIHZhciBkaXZDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNkaXZjb250YWluZXJcIikhXG4gICAgdmFyIGRhdGFDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRhdGFjb250YWluZXJcIikhXG4gICAgdmFyIGRhdGFDb250YWluZXJOYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkYXRhY29udGFpbmVyTmFtZVwiKSFcbiAgICB2YXIgZGF0YUNvbnRhaW5lclBvc2l0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkYXRhY29udGFpbmVyUG9zaXRpb25cIikhXG4gICAgdmFyIGRhdGFDb250YWluZXJWZWxvY2l0eSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGF0YWNvbnRhaW5lclZlbG9jaXR5XCIpIVxuICAgIHZhciBkYXRhQ29udGFpbmVyQWNjZWxlcmF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkYXRhY29udGFpbmVyQWNjZWxlcmF0aW9uXCIpIVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleURvd24pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga2V5VXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGNsaWNrKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgY2xpY2syKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCByb3RhdGVDYW1lcmEpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgd2hlZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgIFxuIFxuICAgIGNvbnN0IGdsID0gZ2V0Q29udGV4dChjYW52YXMpO1xuICAgXG5cbiAgICBjb25zdCBkZW1vUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlclNvdXJjZUNvZGUsIGZyYWdtZW50U2hhZGVyU291cmNlQ29kZSk7XG4gICAgaWYgKCFkZW1vUHJvZ3JhbSkge1xuICAgICAgICBzaG93RXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIFdlYkdMIHByb2dyYW0nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc0F0dHJpYiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKGRlbW9Qcm9ncmFtLCAndmVydGV4UG9zaXRpb24nKTtcbiAgICBjb25zdCBjb2xvckF0dHJpYiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKGRlbW9Qcm9ncmFtLCAndmVydGV4Q29sb3InKTtcblxuICAgIGNvbnN0IG1hdFdvcmxkVW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihkZW1vUHJvZ3JhbSwgJ21hdFdvcmxkJyk7XG4gICAgY29uc3QgbWF0Vmlld1Byb2pVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGRlbW9Qcm9ncmFtLCAnbWF0Vmlld1Byb2onKTtcblxuICAgIGlmIChwb3NBdHRyaWIgPCAwIHx8IGNvbG9yQXR0cmliIDwgMCB8fCAhbWF0V29ybGRVbmlmb3JtIHx8ICFtYXRWaWV3UHJvalVuaWZvcm0pIHtcbiAgICAgICAgc2hvd0Vycm9yKGBGYWlsZWQgdG8gZ2V0IGF0dHJpYnMvdW5pZm9ybXM6IGArXG4gICAgICAgICAgICBgcG9zPSR7cG9zQXR0cmlifSwgY29sb3I9JHtjb2xvckF0dHJpYn0gYCtcbiAgICAgICAgICAgIGBtYXRXb3JsZD0keyEhbWF0V29ybGRVbmlmb3JtfSBtYXRWaWV3UHJvaj0keyEhbWF0Vmlld1Byb2pVbmlmb3JtfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhc3Ryb09iamVjdExpc3QgPSBhd2FpdCBidWlsZEFzdHJvT2JqZWN0cyhnbCwgcG9zQXR0cmliLCBjb2xvckF0dHJpYiwgdXNlcik7XG4gICAgbGV0IHN5c3RlbSA9IG5ldyBBc3Ryb1N5c3RlbShhc3Ryb09iamVjdExpc3QpO1xuXG4gICAgY29uc3QgbWF0V29ybGQgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgIGNvbnN0IG1hdFZpZXcgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgIGNvbnN0IG1hdFByb2ogPSBtYXQ0LmNyZWF0ZSgpO1xuICAgIFxuICAgIGNvbnN0IGxvYWRlclRleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGVyLXRleHQnKTtcbiAgICBpZiAobG9hZGVyVGV4dCAhPSBudWxsKSB7XG5cdGxvYWRlclRleHQuc3R5bGUuYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgPSAnMSc7XG4gICAgXHRsb2FkZXJUZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIChldmVudCkgPT4ge1xuXHRcdGxvYWRlci5jbGFzc0xpc3QuYWRkKFwibG9hZGVyLW92ZXJsYXktLWhpZGRlblwiKTtcbiAgICBcdH0pO1xuICAgIH0gZWxzZSB7XG4gICAgXHRsb2FkZXIuY2xhc3NMaXN0LmFkZChcImxvYWRlci1vdmVybGF5LS1oaWRkZW5cIik7XG4gICAgfVxuICAgIC8vbG9hZGVyLmNsYXNzTGlzdC5hZGQoXCJsb2FkZXItb3ZlcmxheS0taGlkZGVuXCIpO1xuICAgXG4gICAgbGV0IGxhc3RGcmFtZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBmcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXG5cdGNvbnN0IHRoaXNGcmFtZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgZHQgPSAodGhpc0ZyYW1lVGltZSAtIGxhc3RGcmFtZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgLy8gVXBkYXRlIHN5c3RlbSBoZXJlXG4gICAgICAgIGxhc3RGcmFtZVRpbWUgPSB0aGlzRnJhbWVUaW1lO1xuICAgICAgICB1c2VyLnRyYW5zbGF0ZShkdClcbiAgICAgICAgdXNlci5yb3RhdGUoZHQpXG5cbiAgICAgICAgY29uc3QgY2FtZXJhWCA9IHVzZXIudXNlclBvc2l0aW9uWzBdO1xuICAgICAgICBjb25zdCBjYW1lcmFZID0gdXNlci51c2VyUG9zaXRpb25bMV07XG4gICAgICAgIGNvbnN0IGNhbWVyYVogPSB1c2VyLnVzZXJQb3NpdGlvblsyXTtcblxuXHQvLyBVcGRhdGluZyBzeXN0ZW0gd2hlcmUgZXZlcnkgc2Vjb25kIHVwZGF0ZXMgYSBkYXlcbiAgICAgICAgc3lzdGVtLnVwZGF0ZUFzdHJvU3lzdGVtKGR0KVxuICAgICAgICBcbiAgICAgICAgbWF0NC5sb29rQXQoXG4gICAgICAgICAgICBtYXRWaWV3LFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKGNhbWVyYVgsIGNhbWVyYVksIGNhbWVyYVopLFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKHVzZXIudmlld1ZlY1swXSwgdXNlci52aWV3VmVjWzFdLCB1c2VyLnZpZXdWZWNbMl0pLFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApKTtcblxuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKFxuICAgICAgICAgICAgbWF0UHJvaixcbiAgICAgICAgICAgIGdsTWF0cml4LnRvUmFkaWFuKDUwKSxcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICAwLjAwMSwgMTAwLjApO1xuICAgICAgICAgICAgXG4gICAgICAgIGNvbnN0IG1hdFZpZXdQcm9qID0gbWF0NC5jcmVhdGUoKTtcblxuICAgICAgICBtYXQ0Lm11bHRpcGx5KG1hdFZpZXdQcm9qLCBtYXRQcm9qLCBtYXRWaWV3KTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCAqIGRldmljZVBpeGVsUmF0aW87XG5cbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLjAwMzksIDAuMDQyOSwgMC4wOTc2LCAxKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIFxuICAgICAgICBnbC5jdWxsRmFjZShnbC5CQUNLKTtcbiAgICAgICAgZ2wuZnJvbnRGYWNlKGdsLkNDVyk7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgZ2wudXNlUHJvZ3JhbShkZW1vUHJvZ3JhbSk7XG5cblxuICAgIFxuXG4gICAgICAgXG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihtYXRWaWV3UHJvalVuaWZvcm0sIGZhbHNlLCBtYXRWaWV3UHJvaik7XG4gICAgIFxuXG5cblx0c3lzdGVtLl9hc3Ryb09iamVjdExpc3QgPSBzeXN0ZW0uX2FzdHJvT2JqZWN0TGlzdC5zb3J0KChhLCBiKSA9PiB7XG5cdFx0bGV0IGJJVmVjQSA9IGJWZWMzLmNyZWF0ZSgpO1xuXHRcdGxldCBiSVZlY0IgPSBiVmVjMy5jcmVhdGUoKTtcblx0XHRiVmVjMy5zY2FsZShiSVZlY0EsIGEucG9zaXRpb24sIEJpZyhcIjEwXCIpLnBvdygtOSwgbmV3IE1DKDIwKSkpO1xuXHRcdGJWZWMzLnNjYWxlKGJJVmVjQiwgYi5wb3NpdGlvbiwgQmlnKFwiMTBcIikucG93KC05LCBuZXcgTUMoMjApKSk7XG5cdFx0bGV0IGlWZWNBID0gdmVjMy5mcm9tVmFsdWVzKE51bWJlcihiSVZlY0FbMF0udG9CaWdJbnQoKSksIE51bWJlcihiSVZlY0FbMV0udG9CaWdJbnQoKSksIE51bWJlcihiSVZlY0FbMl0udG9CaWdJbnQoKSkpO1xuXHRcdGxldCBpVmVjQiA9IHZlYzMuZnJvbVZhbHVlcyhOdW1iZXIoYklWZWNCWzBdLnRvQmlnSW50KCkpLCBOdW1iZXIoYklWZWNCWzFdLnRvQmlnSW50KCkpLCBOdW1iZXIoYklWZWNCWzJdLnRvQmlnSW50KCkpKTtcblx0XHRyZXR1cm4gdmVjMy5kaXN0YW5jZSh1c2VyLnVzZXJQb3NpdGlvbiwgaVZlY0IpLXZlYzMuZGlzdGFuY2UodXNlci51c2VyUG9zaXRpb24sIGlWZWNBKVxuXHR9KTtcdFxuXG5cdGlmKHVzZXIuY291cGxlZEFzdHJvT2JqZWN0ID09IG51bGwpIHtcblx0XHRkYXRhQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuXHR9IGVsc2Uge1xuXHRcdGRhdGFDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuXHRcdGRhdGFDb250YWluZXJOYW1lLmlubmVySFRNTCA9IHVzZXIuY291cGxlZEFzdHJvT2JqZWN0Lm5hbWU7XG5cdFx0ZGF0YUNvbnRhaW5lclBvc2l0aW9uLmlubmVySFRNTCA9IGAke3VzZXIuY291cGxlZEFzdHJvT2JqZWN0LnBvc2l0aW9uWzBdfSwgJHt1c2VyLmNvdXBsZWRBc3Ryb09iamVjdC5wb3NpdGlvblsxXX0sICR7dXNlci5jb3VwbGVkQXN0cm9PYmplY3QucG9zaXRpb25bMl19YDtcblx0XHRkYXRhQ29udGFpbmVyVmVsb2NpdHkuaW5uZXJIVE1MID0gYCR7dXNlci5jb3VwbGVkQXN0cm9PYmplY3QudmVsb2NpdHlbMF19LCAke3VzZXIuY291cGxlZEFzdHJvT2JqZWN0LnZlbG9jaXR5WzFdfSwgJHt1c2VyLmNvdXBsZWRBc3Ryb09iamVjdC52ZWxvY2l0eVsyXX1gO1xuXHRcdGRhdGFDb250YWluZXJBY2NlbGVyYXRpb24uaW5uZXJIVE1MID0gYCR7dXNlci5jb3VwbGVkQXN0cm9PYmplY3QuYWNjZWxlcmF0aW9uWzBdfSwgJHt1c2VyLmNvdXBsZWRBc3Ryb09iamVjdC5hY2NlbGVyYXRpb25bMV19LCAke3VzZXIuY291cGxlZEFzdHJvT2JqZWN0LmFjY2VsZXJhdGlvblsyXX1gO1xuXHR9XG5cblx0Ly8gSGVyZSBJIG5lZWQgdG8gY2hlY2sgZGlzdGFuY2UgZnJvbSBjYW1lcmEgZm9yIGVhY2ggaXRlbSBhbmQgY2hvb3NlIHRvIGRyYXcgSFRNTCBlbGVtZW50IG9yIDNkIG1vZGVsXG4gICAgICAgIGxldCBpID0gMFxuXHRsZXQgcmV0TGlzdCA9IHN5c3RlbS5nZXREcmF3TGlzdCh1c2VyLnVzZXJQb3NpdGlvbilcblx0bGV0IHYxID0gYlZlYzMuY3JlYXRlKCk7XG5cdGxldCB2MiA9IGJWZWMzLmNyZWF0ZSgpO1xuXHRzeXN0ZW0uX2FzdHJvT2JqZWN0TGlzdC5mb3JFYWNoKChvYmopID0+IHtcblx0XHRsZXQgYklWZWNBID0gYlZlYzMuY3JlYXRlKCk7XG5cdFx0YlZlYzMuc2NhbGUoYklWZWNBLCBvYmoucG9zaXRpb24sIEJpZyhcIjEwXCIpLnBvdygtOSwgbmV3IE1DKDIwKSkpO1xuXHRcdG9iai5fbG9kTWFuYWdlci5kcmF3KGR0LCByZXRMaXN0LmluY2x1ZGVzKG9iaiksIGdsLCBtYXRXb3JsZFVuaWZvcm0sIHZlYzMuZnJvbVZhbHVlcyhOdW1iZXIoYklWZWNBWzBdLnRvRW5naW5lZXJpbmdTdHJpbmcoKSksIE51bWJlcihiSVZlY0FbMV0udG9FbmdpbmVlcmluZ1N0cmluZygpKSwgTnVtYmVyKGJJVmVjQVsyXS50b0VuZ2luZWVyaW5nU3RyaW5nKCkpKSwgbWF0Vmlld1Byb2osIGkpO1xuXHRcdGkrKztcblx0fSk7XG4gICAgICBcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYnVpbGRBc3Ryb09iamVjdHMoZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIHBvc0F0dHJpYjogbnVtYmVyLCBjb2xvckF0dHJpYjogbnVtYmVyLCB1c2VyOiBVc2VyQ29udHJvbGxlcik6IFByb21pc2U8QXN0cm9PYmplY3RbXT57XG5cdGxldCByZXQ6IEFzdHJvT2JqZWN0W10gPSBbXVxuXHRjb25zdCBhcGkgPSBuZXcgQXBpQ2xpZW50KCk7XG5cblx0Y29uc3QgY3VyRXBoZW1lcmlzID0gYXdhaXQgYXBpLmdldEVwaGVtZXJpcyhuZXcgRGF0ZShEYXRlLm5vdygpKSwgT2JqZWN0LmtleXMocGxhbmV0RGF0YSkpO1xuXG5cdFxuXG5cdFxuICAgIFx0dmFyIGRpdkNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2RpdmNvbnRhaW5lclwiKSFcblxuXHRjb25zdCBpbml0aWFsRGF0YSA9IHBsYW5ldERhdGEgYXMgUmVjb3JkPHN0cmluZywgQXN0cm9PYmplY3RDb25maWc+O1xuXHRPYmplY3QuZW50cmllcyhpbml0aWFsRGF0YSkuZm9yRWFjaCgoW2tleSwgZGF0YV0pID0+IHtcblx0XHQvLyBHZXQgV2ViR0xTaGFwZVxuXHRcdGxldCBzaXplID0gZGF0YS5yYWRpdXMvNjk2MzQ5XG5cdFx0bGV0IHRpbHQgPSBkYXRhLmF4aWFsVGlsdDtcblx0XHRsZXQgclNwZWVkID0gZGF0YS5yb3RhdGlvblNwZWVkO1xuXHRcdGxldCBzaGFwZSA9IG5ldyBXZWJHTFNoYXBlKHZlYzMuY3JlYXRlKCksIFxuXHRcdFx0XHRcdCAgc2l6ZSxcblx0XHRcdFx0XHR2ZWMzLmZyb21WYWx1ZXMoMCwxLDApLFxuXHRcdFx0XHRcdCAgZ2xNYXRyaXgudG9SYWRpYW4oMCksXG5cdFx0XHRcdFx0ICB0aWx0LFxuXHRcdFx0XHRcdCAgclNwZWVkLFxuXHRcdFx0XHRcdCAgZ2wsXG5cdFx0XHRcdFx0ICBwb3NBdHRyaWIsXG5cdFx0XHRcdFx0ICBjb2xvckF0dHJpYik7XG5cdFx0bGV0IGxvZE1hbmFnZXIgPSBuZXcgTE9ETWFuYWdlcihzaGFwZSwgZGl2Q29udGFpbmVyRWxlbWVudCwgZGF0YS5uYW1lLCB1c2VyKTtcblx0XHRsZXQgeDAgPSBCaWcoKGN1ckVwaGVtZXJpc1trZXldLnhQb3MpLnRvU3RyaW5nKCkpLm11bHRpcGx5KEJpZyhcIjEwXCIpLnBvdygoY3VyRXBoZW1lcmlzW2tleV0ueFBvc0V4cG4pLCBuZXcgTUMoMjApKSk7XG5cdFx0bGV0IHkwID0gQmlnKChjdXJFcGhlbWVyaXNba2V5XS55UG9zKS50b1N0cmluZygpKS5tdWx0aXBseShCaWcoXCIxMFwiKS5wb3coKGN1ckVwaGVtZXJpc1trZXldLnlQb3NFeHBuKSwgbmV3IE1DKDIwKSkpO1xuXHRcdGxldCB6MCA9IEJpZygoY3VyRXBoZW1lcmlzW2tleV0uelBvcykudG9TdHJpbmcoKSkubXVsdGlwbHkoQmlnKFwiMTBcIikucG93KChjdXJFcGhlbWVyaXNba2V5XS56UG9zRXhwbiksIG5ldyBNQygyMCkpKTtcblx0XHRsZXQgcG9zaXRpb24gPSBiVmVjMy5mcm9tVmFsdWVzKHgwLnRvU3RyaW5nKCksIHowLnRvU3RyaW5nKCksIHkwLm5lZ2F0ZSgpLnRvU3RyaW5nKCkpO1xuXHRcdGJWZWMzLnNjYWxlKHBvc2l0aW9uLCBwb3NpdGlvbiwgQmlnKFwiMTAwMFwiKSk7XG5cblx0XHRsZXQgeFYwID0gQmlnKChjdXJFcGhlbWVyaXNba2V5XS54VmVsKS50b1N0cmluZygpKS5tdWx0aXBseShCaWcoXCIxMFwiKS5wb3coKGN1ckVwaGVtZXJpc1trZXldLnhWZWxFeHBuKSwgbmV3IE1DKDIwKSkpO1xuXHRcdGxldCB5VjAgPSBCaWcoKGN1ckVwaGVtZXJpc1trZXldLnlWZWwpLnRvU3RyaW5nKCkpLm11bHRpcGx5KEJpZyhcIjEwXCIpLnBvdygoY3VyRXBoZW1lcmlzW2tleV0ueVZlbEV4cG4pLCBuZXcgTUMoMjApKSk7XG5cdFx0bGV0IHpWMCA9IEJpZygoY3VyRXBoZW1lcmlzW2tleV0uelZlbCkudG9TdHJpbmcoKSkubXVsdGlwbHkoQmlnKFwiMTBcIikucG93KChjdXJFcGhlbWVyaXNba2V5XS56VmVsRXhwbiksIG5ldyBNQygyMCkpKTtcblx0XHRsZXQgdmVsb2NpdHkgPSBiVmVjMy5mcm9tVmFsdWVzKHhWMC50b1N0cmluZygpLCB6VjAudG9TdHJpbmcoKSwgeVYwLm5lZ2F0ZSgpLnRvU3RyaW5nKCkpO1xuXHRcdGJWZWMzLnNjYWxlKHZlbG9jaXR5LCB2ZWxvY2l0eSwgQmlnKFwiMTAwMFwiKSk7XG5cblx0XHRsZXQgYWNjZWxlcmF0aW9uID0gYlZlYzMuY3JlYXRlKCk7XG5cblx0XHRsZXQgbmFtZSA9IGRhdGEubmFtZTtcblx0XHRsZXQgbWFzcyA9IEJpZyhldmFsKGRhdGEubWFzcykudG9TdHJpbmcoKSk7XG5cdFx0bGV0IHBSYWRpdXMgPSAxO1xuXHRcdGxldCBlUmFkaXVzID0gMTtcblx0XHRsZXQgYXN0cm9PYmplY3QgPSBuZXcgQXN0cm9PYmplY3QocG9zaXRpb24sXG5cdFx0XHRcdFx0XHQgdmVsb2NpdHksXG5cdFx0XHRcdFx0XHQgYWNjZWxlcmF0aW9uLFxuXHRcdFx0XHRcdFx0IG5hbWUsXG5cdFx0XHRcdFx0XHQgbWFzcyxcblx0XHRcdFx0XHRcdCBkYXRhLnN5c3RlbVNwYWNlLFxuXHRcdFx0XHRcdFx0IGRhdGEuc3Vic3lzdGVtLFxuXHRcdFx0XHRcdFx0IHBSYWRpdXMsXG5cdFx0XHRcdFx0XHQgZVJhZGl1cyxcblx0XHRcdFx0XHRcdCBsb2RNYW5hZ2VyKTtcblx0XHRhc3Ryb09iamVjdC5fbG9kTWFuYWdlci5zZXRBc3Ryb09iamVjdChhc3Ryb09iamVjdCk7XG5cblxuXG5cdFx0Ly9sZXQgbmV3T2JqID0gbmV3IEFzdHJvT2JqZWN0KHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBuYW1lLCBtYXNzLCBwUmFkaXVzLCBlUmFkaXVzLCBsb2RNYW5hZ2VyKTtcblx0XHRyZXQucHVzaChhc3Ryb09iamVjdCk7XG5cdH0pO1xuXHRcblxuXG5cdHJldHVybiByZXRcbn1cblxudHJ5IHtcblx0bWFpbigpXG5cdC8vIEluaXRpYWxpemUgVXNlckNvbnRyb2xsZXJcblx0Ly8gSW5pdGlhbGl6ZSBBc3Ryb09iamVjdHNcblx0Ly8gSW5pdGlhbGl6ZSBBc3Ryb1N5c3RlbVxuXHQvL1xuXG59IGNhdGNoKGUpIHtcbiAgICBzaG93RXJyb3IoYFVuaGFuZGxlZCBKYXZhU2NyaXB0IGV4Y2VwdGlvbjogJHtlfWApXG59XG4iLCJcblxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcblx0YXBpVXJsOiBwcm9jZXNzLmVudi5BUElfVVJMLFxuXHRlbnZpcm9ubWVudDogcHJvY2Vzcy5lbnYuTk9ERV9FTlZcbn07XG4iLCJpbXBvcnQgeyBnbE1hdHJpeCwgbWF0NCwgcXVhdCwgUmVhZG9ubHlWZWMzLCB2ZWMzLCB2ZWM0IH0gZnJvbSBcImdsLW1hdHJpeFwiO1xuaW1wb3J0IHsgQXN0cm9PYmplY3QgfSBmcm9tIFwiLi4vbW9kZWxzL0FzdHJvT2JqZWN0XCI7XG5pbXBvcnQgKiBhcyBiVmVjMyBmcm9tIFwiLi4vdXRpbHMvYmlnLXZlYzNcIjtcblxuZXhwb3J0IGNsYXNzIFVzZXJDb250cm9sbGVyIHtcbiAgICBwdWJsaWMgdXNlclBvc2l0aW9uOiB2ZWMzO1xuICAgIHB1YmxpYyB2ZWxvY2l0eTogdmVjMztcbiAgICBwdWJsaWMgdXNlck9yaWVudGF0aW9uOiB2ZWMzO1xuICAgIHB1YmxpYyBzZXRVc2VyT3JpZW50YXRpb246IHZlYzM7XG4gICAgcHVibGljIHRhcmdldFVzZXJPcmllbnRhdGlvbjogdmVjMztcbiAgICBwdWJsaWMgcm90YXRpb25WZWM6IHZlYzM7XG4gICAgcHVibGljIGlzTW92aW5nOiBib29sZWFuO1xuICAgIHB1YmxpYyBzcGVlZDogbnVtYmVyO1xuICAgIHB1YmxpYyB2aWV3VmVjOiB2ZWMzO1xuICAgIHB1YmxpYyBjb3VwbGVkQXN0cm9PYmplY3Q6IEFzdHJvT2JqZWN0IHwgbnVsbDtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy51c2VyUG9zaXRpb24gPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMTAwMDApXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMClcbiAgICAgICAgdGhpcy51c2VyT3JpZW50YXRpb24gPSB2ZWMzLmZyb21WYWx1ZXMoMCwgLTkwLCAwKVxuXHR0aGlzLnZpZXdWZWMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgLTEpXG4gICAgICAgIHRoaXMuc2V0VXNlck9yaWVudGF0aW9uID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApXG4gICAgICAgIHRoaXMudGFyZ2V0VXNlck9yaWVudGF0aW9uID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApXG4gICAgICAgIHRoaXMucm90YXRpb25WZWMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMClcbiAgICAgICAgdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNwZWVkID0gMTAwMDBcblx0dGhpcy5jb3VwbGVkQXN0cm9PYmplY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyB0cmFuc2xhdGUoZHQ6IG51bWJlcikge1xuICAgICAgICBsZXQgbW92ZW1lbnRWZWMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwwLDApO1xuXHRsZXQgY3VyU3BlZWQgPSB0aGlzLl9nZXRDdXJTcGVlZCgpICogZHRcblx0Ly9jb25zb2xlLmxvZyhjdXJTcGVlZCk7XG4gICAgICAgIGlmKHRoaXMudmVsb2NpdHlbMl0gPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VwbGVkQXN0cm9PYmplY3QgIT0gbnVsbCkge1xuXHRcdGxldCBpVmVjID0gdmVjMy5jcmVhdGUoKTtcblx0XHRsZXQgdFZlYyA9IGJWZWMzLmdldFNjYWxlZFZlYzModGhpcy5jb3VwbGVkQXN0cm9PYmplY3QucG9zaXRpb24sIDEwLCAtOSk7XG5cdFx0dmVjMy5zdWJ0cmFjdChpVmVjLCB0VmVjLCB0aGlzLnVzZXJQb3NpdGlvbik7XG5cdFx0dmVjMy5ub3JtYWxpemUoaVZlYywgaVZlYyk7XG5cdFx0dmVjMy5zY2FsZShtb3ZlbWVudFZlYywgaVZlYywgY3VyU3BlZWQpO1xuXHQgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICBcdHZlYzMuc2NhbGUobW92ZW1lbnRWZWMsIHZlYzMuZnJvbVZhbHVlcyhNYXRoLmNvcyhnbE1hdHJpeC50b1JhZGlhbih0aGlzLnVzZXJPcmllbnRhdGlvblsxXSkpLCAwLCBNYXRoLnNpbihnbE1hdHJpeC50b1JhZGlhbih0aGlzLnVzZXJPcmllbnRhdGlvblsxXSkpKSwgY3VyU3BlZWQpXG5cdCAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmKHRoaXMudmVsb2NpdHlbMl0gPCAwKSB7XG5cdFx0aWYgKHRoaXMuY291cGxlZEFzdHJvT2JqZWN0ICE9IG51bGwpIHtcblx0XHRcdGxldCBpVmVjID0gdmVjMy5jcmVhdGUoKTtcblx0XHRcdGxldCB0VmVjID0gYlZlYzMuZ2V0U2NhbGVkVmVjMyh0aGlzLmNvdXBsZWRBc3Ryb09iamVjdC5wb3NpdGlvbiwgMTAsIC05KTtcblx0XHRcdHZlYzMuc3VidHJhY3QoaVZlYywgdFZlYywgdGhpcy51c2VyUG9zaXRpb24pO1xuXHRcdFx0dmVjMy5ub3JtYWxpemUoaVZlYywgaVZlYyk7XG5cdFx0XHR2ZWMzLnNjYWxlKG1vdmVtZW50VmVjLCBpVmVjLCAtY3VyU3BlZWQpO1xuXHRcdH0gZWxzZSB7XG4gICAgICAgICAgICBcdFx0dmVjMy5zY2FsZShtb3ZlbWVudFZlYywgdmVjMy5mcm9tVmFsdWVzKE1hdGguY29zKGdsTWF0cml4LnRvUmFkaWFuKHRoaXMudXNlck9yaWVudGF0aW9uWzFdKSksIDAsIE1hdGguc2luKGdsTWF0cml4LnRvUmFkaWFuKHRoaXMudXNlck9yaWVudGF0aW9uWzFdKSkpLCAtY3VyU3BlZWQpXG5cdFx0fVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy52ZWxvY2l0eVswXSA+IDApIHtcblx0XHRpZiAodGhpcy5jb3VwbGVkQXN0cm9PYmplY3QgIT0gbnVsbCkge1xuXHRcdFx0bGV0IGlWZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdFx0bGV0IHRWZWMgPSBiVmVjMy5nZXRTY2FsZWRWZWMzKHRoaXMuY291cGxlZEFzdHJvT2JqZWN0LnBvc2l0aW9uLCAxMCwgLTkpO1xuXHRcdFx0bGV0IHFWZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdFx0bGV0IGNWZWMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG5cdFx0XHR2ZWMzLnN1YnRyYWN0KGlWZWMsIHRWZWMsIHRoaXMudXNlclBvc2l0aW9uKTtcblx0XHRcdHZlYzMuY3Jvc3MocVZlYywgY1ZlYywgaVZlYylcblx0XHRcdHZlYzMubm9ybWFsaXplKHFWZWMsIHFWZWMpO1xuXHRcdFx0dmVjMy5zY2FsZShtb3ZlbWVudFZlYywgcVZlYywgLWN1clNwZWVkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmVjMy5zY2FsZShtb3ZlbWVudFZlYywgdmVjMy5mcm9tVmFsdWVzKE1hdGguY29zKGdsTWF0cml4LnRvUmFkaWFuKDkwK3RoaXMudXNlck9yaWVudGF0aW9uWzFdKSksIDAsIE1hdGguc2luKGdsTWF0cml4LnRvUmFkaWFuKDkwK3RoaXMudXNlck9yaWVudGF0aW9uWzFdKSkpLCBjdXJTcGVlZClcblx0XHR9XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnZlbG9jaXR5WzBdIDwgMCkge1xuXHRcdGlmICh0aGlzLmNvdXBsZWRBc3Ryb09iamVjdCAhPSBudWxsKSB7XG5cdFx0XHRsZXQgaVZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0XHRsZXQgdFZlYyA9IGJWZWMzLmdldFNjYWxlZFZlYzModGhpcy5jb3VwbGVkQXN0cm9PYmplY3QucG9zaXRpb24sIDEwLCAtOSk7XG5cdFx0XHRsZXQgcVZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0XHRsZXQgY1ZlYyA9IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKTtcblx0XHRcdHZlYzMuc3VidHJhY3QoaVZlYywgdFZlYywgdGhpcy51c2VyUG9zaXRpb24pO1xuXHRcdFx0dmVjMy5jcm9zcyhxVmVjLCBjVmVjLCBpVmVjKVxuXHRcdFx0dmVjMy5ub3JtYWxpemUocVZlYywgcVZlYyk7XG5cdFx0XHR2ZWMzLnNjYWxlKG1vdmVtZW50VmVjLCBxVmVjLCBjdXJTcGVlZCk7XG5cdFx0fSBlbHNlIHtcbiAgICAgICAgICAgIFx0XHR2ZWMzLnNjYWxlKG1vdmVtZW50VmVjLCB2ZWMzLmZyb21WYWx1ZXMoTWF0aC5jb3MoZ2xNYXRyaXgudG9SYWRpYW4oOTArdGhpcy51c2VyT3JpZW50YXRpb25bMV0pKSwgMCwgTWF0aC5zaW4oZ2xNYXRyaXgudG9SYWRpYW4oOTArdGhpcy51c2VyT3JpZW50YXRpb25bMV0pKSksIC1jdXJTcGVlZClcbiAgICAgICAgXG5cdFx0fVxuXHR9XG4gICAgICAgIGlmKHRoaXMudmVsb2NpdHlbMV0gPiAwKSB7XG5cblx0XHRpZiAodGhpcy5jb3VwbGVkQXN0cm9PYmplY3QgIT0gbnVsbCkge1xuXHRcdFx0bGV0IGlWZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdFx0bGV0IHRWZWMgPSBiVmVjMy5nZXRTY2FsZWRWZWMzKHRoaXMuY291cGxlZEFzdHJvT2JqZWN0LnBvc2l0aW9uLCAxMCwgLTkpO1xuXHRcdFx0bGV0IHFWZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdFx0bGV0IGNWZWMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG5cdFx0XHR2ZWMzLnN1YnRyYWN0KGlWZWMsIHRWZWMsIHRoaXMudXNlclBvc2l0aW9uKTtcblx0XHRcdHZlYzMuY3Jvc3MocVZlYywgY1ZlYywgaVZlYylcblx0XHRcdHZlYzMuY3Jvc3MoY1ZlYywgcVZlYywgaVZlYylcblx0XHRcdHZlYzMubm9ybWFsaXplKGNWZWMsIGNWZWMpXG5cdFx0XHR2ZWMzLnNjYWxlKG1vdmVtZW50VmVjLCBjVmVjLCAtY3VyU3BlZWQpO1xuXG5cdFx0fSBlbHNlIHtcbiAgICAgICAgICAgIFx0XHR2ZWMzLnNjYWxlKG1vdmVtZW50VmVjLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCksIGN1clNwZWVkKVxuXHRcdH1cblxuICAgICAgICB9IGVsc2UgaWYodGhpcy52ZWxvY2l0eVsxXSA8IDApIHtcblxuXHRcdGlmICh0aGlzLmNvdXBsZWRBc3Ryb09iamVjdCAhPSBudWxsKSB7XG5cdFx0XHRsZXQgaVZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0XHRsZXQgdFZlYyA9IGJWZWMzLmdldFNjYWxlZFZlYzModGhpcy5jb3VwbGVkQXN0cm9PYmplY3QucG9zaXRpb24sIDEwLCAtOSk7XG5cdFx0XHRsZXQgcVZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0XHRsZXQgY1ZlYyA9IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKTtcblx0XHRcdHZlYzMuc3VidHJhY3QoaVZlYywgdFZlYywgdGhpcy51c2VyUG9zaXRpb24pO1xuXHRcdFx0dmVjMy5jcm9zcyhxVmVjLCBjVmVjLCBpVmVjKVxuXHRcdFx0dmVjMy5jcm9zcyhjVmVjLCBxVmVjLCBpVmVjKVxuXHRcdFx0dmVjMy5ub3JtYWxpemUoY1ZlYywgY1ZlYylcblx0XHRcdHZlYzMuc2NhbGUobW92ZW1lbnRWZWMsIGNWZWMsIGN1clNwZWVkKTtcblx0XHR9IGVsc2Uge1x0XG4gICAgICAgICAgICBcdFx0dmVjMy5zY2FsZShtb3ZlbWVudFZlYywgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApLCAtY3VyU3BlZWQpXG5cdFx0fVxuXHR9XG5cbiAgICAgICAgdmVjMy5hZGQodGhpcy51c2VyUG9zaXRpb24sIHRoaXMudXNlclBvc2l0aW9uLCBtb3ZlbWVudFZlYykvLyh2ZWMzLnNjYWxlKHRoaXMudmVsb2NpdHksIHRoaXMudmVsb2NpdHksIGR0KSkpXG4gICAgfVxuICAgIHB1YmxpYyByb3RhdGUoZHQ6IG51bWJlcikge1xuICAgICAgICAvL3RoaXMudXNlck9yaWVudGF0aW9uWzBdICs9IDFcbiAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnNldFVzZXJPcmllbnRhdGlvblswXSwgdGhpcy50YXJnZXRVc2VyT3JpZW50YXRpb25bMF0pXG4gICAgICAgIGlmICh0aGlzLmNvdXBsZWRBc3Ryb09iamVjdCA9PSBudWxsKSB7XG5cdGxldCBkID0gTWF0aC5zcXJ0KCh0aGlzLnRhcmdldFVzZXJPcmllbnRhdGlvblswXS10aGlzLnNldFVzZXJPcmllbnRhdGlvblswXSkqKjIgKyAodGhpcy50YXJnZXRVc2VyT3JpZW50YXRpb25bMV0tdGhpcy5zZXRVc2VyT3JpZW50YXRpb25bMV0pKioyKVxuICAgICAgICBpZihkID49IDUpIHtcbiAgICAgICAgICAgIGxldCBuZXdYID0gdGhpcy5zZXRVc2VyT3JpZW50YXRpb25bMF0gKyAoMTAvZCkqKHRoaXMudGFyZ2V0VXNlck9yaWVudGF0aW9uWzBdLXRoaXMuc2V0VXNlck9yaWVudGF0aW9uWzBdKVxuICAgICAgICAgICAgbGV0IG5ld1kgPSB0aGlzLnNldFVzZXJPcmllbnRhdGlvblsxXSArICgxMC9kKSoodGhpcy50YXJnZXRVc2VyT3JpZW50YXRpb25bMV0tdGhpcy5zZXRVc2VyT3JpZW50YXRpb25bMV0pXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMudXNlck9yaWVudGF0aW9uWzBdLCB0aGlzLnVzZXJPcmllbnRhdGlvblsxXSlcbiAgICAgICAgICAgIHRoaXMudXNlck9yaWVudGF0aW9uWzFdIC09IChuZXdYIC0gdGhpcy5zZXRVc2VyT3JpZW50YXRpb25bMF0pLzVcbiAgICAgICAgICAgIHRoaXMudXNlck9yaWVudGF0aW9uWzBdICs9ICAobmV3WSAtIHRoaXMuc2V0VXNlck9yaWVudGF0aW9uWzFdKS81XG4gICAgLypcbiAgICAgICAgICAgIGNhbWVyYVgrKE1hdGguY29zKGdsTWF0cml4LnRvUmFkaWFuKHVzZXIudXNlck9yaWVudGF0aW9uWzBdKSkqTWF0aC5jb3MoZ2xNYXRyaXgudG9SYWRpYW4odXNlci51c2VyT3JpZW50YXRpb25bMV0pKSkgXG5cdCAgICBjYW1lcmFZK01hdGguc2luKGdsTWF0cml4LnRvUmFkaWFuKHVzZXIudXNlck9yaWVudGF0aW9uWzBdKSlcblx0ICAgIGNhbWVyYVorKE1hdGguY29zKGdsTWF0cml4LnRvUmFkaWFuKHVzZXIudXNlck9yaWVudGF0aW9uWzBdKSkqTWF0aC5zaW4oZ2xNYXRyaXgudG9SYWRpYW4odXNlci51c2VyT3JpZW50YXRpb25bMV0pKSlcbiovXHQgICAgXG4gICAgICAgICAgICAvL3RoaXMudmlld1ZlY1swXSA9IHRoaXMudXNlclBvc2l0aW9uWzBdKyhNYXRoLmNvcyhnbE1hdHJpeC50b1JhZGlhbih0aGlzLnVzZXJPcmllbnRhdGlvblswXSkpKk1hdGguY29zKGdsTWF0cml4LnRvUmFkaWFuKHRoaXMudXNlck9yaWVudGF0aW9uWzFdKSkpIFxuXHQgICAgLy90aGlzLnZpZXdWZWNbMV0gPSB0aGlzLnVzZXJQb3NpdGlvblsxXStNYXRoLnNpbihnbE1hdHJpeC50b1JhZGlhbih0aGlzLnVzZXJPcmllbnRhdGlvblswXSkpXG4gICAgICAgICAgICAvL3RoaXMudmlld1ZlY1syXSA9IHRoaXMudXNlclBvc2l0aW9uWzJdKyhNYXRoLmNvcyhnbE1hdHJpeC50b1JhZGlhbih0aGlzLnVzZXJPcmllbnRhdGlvblswXSkpKk1hdGguc2luKGdsTWF0cml4LnRvUmFkaWFuKHRoaXMudXNlck9yaWVudGF0aW9uWzFdKSkpXG5cdCAgICB0aGlzLnNldFVzZXJPcmllbnRhdGlvblswXSA9IG5ld1hcbiAgICAgICAgICAgIHRoaXMuc2V0VXNlck9yaWVudGF0aW9uWzFdID0gbmV3WVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRVc2VyT3JpZW50YXRpb25bMF0gPSB0aGlzLnNldFVzZXJPcmllbnRhdGlvblswXVxuICAgICAgICAgICAgdGhpcy50YXJnZXRVc2VyT3JpZW50YXRpb25bMV0gPSB0aGlzLnNldFVzZXJPcmllbnRhdGlvblsxXVxuICAgICAgICB9XG5cdHRoaXMudmlld1ZlY1swXSA9IHRoaXMudXNlclBvc2l0aW9uWzBdKyhNYXRoLmNvcyhnbE1hdHJpeC50b1JhZGlhbih0aGlzLnVzZXJPcmllbnRhdGlvblswXSkpKk1hdGguY29zKGdsTWF0cml4LnRvUmFkaWFuKHRoaXMudXNlck9yaWVudGF0aW9uWzFdKSkpIFxuXHR0aGlzLnZpZXdWZWNbMV0gPSB0aGlzLnVzZXJQb3NpdGlvblsxXStNYXRoLnNpbihnbE1hdHJpeC50b1JhZGlhbih0aGlzLnVzZXJPcmllbnRhdGlvblswXSkpXG4gICAgICAgIHRoaXMudmlld1ZlY1syXSA9IHRoaXMudXNlclBvc2l0aW9uWzJdKyhNYXRoLmNvcyhnbE1hdHJpeC50b1JhZGlhbih0aGlzLnVzZXJPcmllbnRhdGlvblswXSkpKk1hdGguc2luKGdsTWF0cml4LnRvUmFkaWFuKHRoaXMudXNlck9yaWVudGF0aW9uWzFdKSkpXG5cdH0gZWxzZSB7XG5cdFx0bGV0IGkxID0gYlZlYzMuZ2V0U2NhbGVkVmVjMyh0aGlzLmNvdXBsZWRBc3Ryb09iamVjdC5wb3NpdGlvbiwgMTAsIC05KTtcblx0XHR2ZWMzLnN1YnRyYWN0KHRoaXMudmlld1ZlYywgaTEsIHRoaXMudXNlclBvc2l0aW9uKTtcblx0XHR2ZWMzLmFkZCh0aGlzLnZpZXdWZWMsIHRoaXMudmlld1ZlYywgdGhpcy51c2VyUG9zaXRpb24pO1xuXHRcdGxldCB0VmVjID0gdmVjMy5jcmVhdGUoKVxuXHRcdHZlYzMubm9ybWFsaXplKHRWZWMsIHRoaXMudmlld1ZlYyk7XG5cdFx0bGV0IHRoZXRhID0gTWF0aC5hc2luKHRWZWNbMF0pXG5cdFx0bGV0IHBoaSA9IE1hdGguYXNpbigodFZlY1sxXSkvTWF0aC5jb3ModGhldGEpKVxuXHRcdHRoaXMudXNlck9yaWVudGF0aW9uWzBdID0gKHRoZXRhKjE4MCkvTWF0aC5QSVxuXHRcdHRoaXMudXNlck9yaWVudGF0aW9uWzFdID0gKHBoaSoxODApL01hdGguUElcblx0XHRcblx0fVxuICAgIH1cblxuXG4gICAgcHVibGljIHNldENvdXBsZWRBc3Ryb09iamVjdChvYmo6IEFzdHJvT2JqZWN0KSB7XG4gICAgXHR0aGlzLmNvdXBsZWRBc3Ryb09iamVjdCA9IG9iajtcblx0Ly9jb25zb2xlLmxvZyhgQ291cGxlZCBvYmplY3Qgc2V0IHRvICR7b2JqLm5hbWV9YCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0Q3VyU3BlZWQoKTogbnVtYmVyIHtcbiAgICBcdGxldCBjdXJTcGVlZCA9IHRoaXMuc3BlZWQ7XG5cdGlmICh0aGlzLmNvdXBsZWRBc3Ryb09iamVjdCAhPSBudWxsKSB7IFxuXHRcdGxldCBzY2FsZWRPYmpQb3MgPSBiVmVjMy5nZXRTY2FsZWRWZWMzKHRoaXMuY291cGxlZEFzdHJvT2JqZWN0LnBvc2l0aW9uLCAxMCwgLTkpO1xuXHRcdGxldCBkaXN0ID0gdmVjMy5kaXN0YW5jZSh0aGlzLnVzZXJQb3NpdGlvbiwgc2NhbGVkT2JqUG9zKVxuXHRcdGxldCBwb3NTcGVlZCA9IDEwMDAwMDAwMDtcblx0XHRcblx0XHRjdXJTcGVlZCA9IGRpc3QgXG5cdFx0Y29uc29sZS5sb2coXCJjdXJTcGVlZDpcIiwgY3VyU3BlZWQsIGRpc3QpXG5cdH1cblx0cmV0dXJuIGN1clNwZWVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IHNob3dFcnJvciB9IGZyb20gXCIuL3V0aWxzL2dsLXV0aWxzXCI7XHJcblxyXG4vLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBzZWN0b3JcclxuLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggc3RhY2tcclxuLy8gR2V0IHgsIHksIGFuZCB6IHZhbHVlcy4gTmVlZCB0byB0aWUgdGhlbSB0b2dldGhlciB0byBjcmVhdGUgZmFjZXNcclxuXHJcbmNsYXNzIFZlcnRleCB7XHJcbiAgICB4OiBudW1iZXI7XHJcbiAgICB5OiBudW1iZXI7XHJcbiAgICB6OiBudW1iZXI7XHJcbiAgICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMueiA9IHo7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTcGhlcmUge1xyXG4gICAgdmVydGljZXM6IEZsb2F0MzJBcnJheTtcclxuICAgIGluZGljZXM6IFVpbnQxNkFycmF5O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHN0YWNrczogbnVtYmVyLCBzZWN0b3JzOiBudW1iZXIsIHhTY2FsYXI6IG51bWJlciwgeVNjYWxhcjogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IHZlcnRpY2VzU2l6ZSA9ICg2KjMqc2VjdG9ycykrKDYqMypzZWN0b3JzKSsoNio0KnNlY3RvcnMqKHN0YWNrcy0yKSk7XHJcbiAgICAgICAgbGV0IGluZGljZXNTaXplID0gKDMqc2VjdG9ycykrKDMqc2VjdG9ycykrKDYqc2VjdG9ycyooc3RhY2tzLTIpKTsgLy8gbmVlZCB0byBhZGQgZXh0cmEgZm9yIGJvdHRvbSBpbmRpY2VzL3ZlcnRpY2VzXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXNTaXplKTtcclxuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlc1NpemUpO1xyXG5cclxuICAgICAgICBcclxuICAgICAgICBsZXQgdmVydHM6IGFueVtdID0gW107XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcyh2ZXJ0cywgc3RhY2tzLCBzZWN0b3JzLCB4U2NhbGFyLCB5U2NhbGFyKTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgXHJcblxyXG5cclxuICAgICAgICAvLyBsaW5rIHRvcFxyXG4gICAgICAgIGxldCBtID0gMDtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgbGV0IGwgPSAwO1xyXG4gICAgICAgIGxldCBxID0gMDtcclxuICAgICAgICB3aGlsZSAobCA8IHZlcnRzWzBdLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAwLjA7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDEuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAwLjA7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMS4wO1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXNbcV0gPSBxO1xyXG4gICAgICAgICAgICBxKys7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzWzBdW25dLng7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzWzBdW25dLnk7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzWzBdW25dLno7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAxLjA7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlc1txXSA9IHE7XHJcbiAgICAgICAgICAgIHErKztcclxuICAgICAgICAgICAgaWYgKG4rMSA+PSB2ZXJ0c1swXS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG4gPSAwXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuKytcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSB2ZXJ0c1swXVtuXS54O1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSB2ZXJ0c1swXVtuXS55O1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSB2ZXJ0c1swXVtuXS56O1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAwLjA7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMS4wO1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXNbcV0gPSBxO1xyXG4gICAgICAgICAgICBxKys7XHJcbiAgICAgICAgICAgIGwgKytcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRyYWNrZXIgPSBxXHJcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB2ZXJ0cy5sZW5ndGgtMTsgaysrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdmVydHNba10ubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wTiA9IG5cclxuICAgICAgICAgICAgICAgIGlmICh0ZW1wTiArIDEgPj0gdmVydHNba10ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcE4gPSAtMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gdmVydHNba11bbl0ueCAvLyBsZWZ0IGNvcm5lclxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gdmVydHNba11bbl0ueVxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gdmVydHNba11bbl0uelxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzW3FdID0gdHJhY2tlcjtcclxuICAgICAgICAgICAgICAgIHRyYWNrZXIrK1xyXG4gICAgICAgICAgICAgICAgcSsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gdmVydHNba11bdGVtcE4rMV0ueCAvLyByaWdodCBjb3JuZXJcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzW2tdW3RlbXBOKzFdLnlcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzW2tdW3RlbXBOKzFdLnpcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDEuMDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgIGxldCByaWdodENvcm5lckluZGV4ID0gdHJhY2tlcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc1txXSA9IHJpZ2h0Q29ybmVySW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0cmFja2VyKytcclxuICAgICAgICAgICAgICAgIHErKztcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzW2srMV1bbl0ueCAvLyBib3R0b20gbGVmdCBjb3JuZXJcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzW2srMV1bbl0ueVxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gdmVydHNbaysxXVtuXS56XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAxLjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICBsZXQgYm90dG9tTGVmdENvcm5lckluZGV4ID0gdHJhY2tlcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc1txXSA9IGJvdHRvbUxlZnRDb3JuZXJJbmRleDtcclxuICAgICAgICAgICAgICAgIHRyYWNrZXIrK1xyXG4gICAgICAgICAgICAgICAgcSsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzW3FdID0gcmlnaHRDb3JuZXJJbmRleDtcclxuICAgICAgICAgICAgICAgIHErKztcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc1txXSA9IGJvdHRvbUxlZnRDb3JuZXJJbmRleDtcclxuICAgICAgICAgICAgICAgIHErKztcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzW2srMV1bdGVtcE4rMV0ueCAvLyBib3R0b20gcmlnaHQgY29ybmVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSB2ZXJ0c1trKzFdW3RlbXBOKzFdLnlcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzW2srMV1bdGVtcE4rMV0uelxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzW3FdID0gdHJhY2tlcjtcclxuICAgICAgICAgICAgICAgIHRyYWNrZXIrK1xyXG4gICAgICAgICAgICAgICAgcSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGw9MDtcclxuICAgICAgICBjb25zb2xlLmxvZyh2ZXJ0c1t2ZXJ0cy5sZW5ndGgtMV0pXHJcbiAgICAgICAgd2hpbGUgKGwgPCB2ZXJ0c1t2ZXJ0cy5sZW5ndGgtMV0ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gLTEuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAxLjA7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXNbcV0gPSB0cmFja2VyO1xyXG4gICAgICAgICAgICB0cmFja2VyKytcclxuICAgICAgICAgICAgcSsrO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSB2ZXJ0c1t2ZXJ0cy5sZW5ndGgtMV1bbl0ueDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gdmVydHNbdmVydHMubGVuZ3RoLTFdW25dLnk7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzW3ZlcnRzLmxlbmd0aC0xXVtuXS56O1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAxLjA7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXNbcV0gPSB0cmFja2VyO1xyXG4gICAgICAgICAgICB0cmFja2VyKytcclxuICAgICAgICAgICAgcSsrO1xyXG4gICAgICAgICAgICBpZiAobisxID49IHZlcnRzWzBdLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbiA9IDBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG4rK1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IHZlcnRzW3ZlcnRzLmxlbmd0aC0xXVtuXS54O1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSB2ZXJ0c1t2ZXJ0cy5sZW5ndGgtMV1bbl0ueTtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gdmVydHNbdmVydHMubGVuZ3RoLTFdW25dLno7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbSsrXSA9IDEuMDtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttKytdID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW20rK10gPSAwLjA7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlc1txXSA9IHRyYWNrZXI7XHJcbiAgICAgICAgICAgIHRyYWNrZXIrK1xyXG4gICAgICAgICAgICBxKys7XHJcbiAgICAgICAgICAgIGwrK1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbGluayBtaWRkbGVcclxuICAgICAgICAvLyBsaW5rIGJvdHRvbVxcXHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlcylcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmluZGljZXMpXHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVZlcnRpY2VzKHZlcnRzOiBhbnlbXSwgc3RhY2tzOiBudW1iZXIsIHNlY3RvcnM6IG51bWJlciwgeFNjYWxhcjogbnVtYmVyLCB5U2NhbGFyOiBudW1iZXIpIHtcclxuICAgICAgICBsZXQgc3RhY2tTdGVwID0gMTgwL3N0YWNrcztcclxuICAgICAgICBsZXQgc2VjdG9yU3RlcCA9IDM2MC9zZWN0b3JzO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgdGhldGEgPSBzdGFja1N0ZXA7XHJcbiAgICAgICAgbGV0IHRoZXRhUmFkaWFuczogbnVtYmVyO1xyXG4gICAgICAgIGxldCBwaGk6IG51bWJlcjtcclxuICAgICAgICBsZXQgcGhpUmFkaWFuczogbnVtYmVyO1xyXG4gICAgICAgIGxldCB4LCB5LCB6OiBudW1iZXI7XHJcbiAgICAgICAgd2hpbGUgKHRoZXRhIDwgMTgwKSB7XHJcbiAgICAgICAgICAgIHZlcnRzW2ldID0gW10gYXMgVmVydGV4W107XHJcbiAgICAgICAgICAgIHBoaSA9IDA7XHJcbiAgICAgICAgICAgIHRoZXRhUmFkaWFucyA9ICg5MCAtIHRoZXRhKSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgICAgIHkgPSB5U2NhbGFyKk1hdGguc2luKHRoZXRhUmFkaWFucyk7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wWCA9IHhTY2FsYXIqTWF0aC5jb3ModGhldGFSYWRpYW5zKTtcclxuICAgICAgICAgICAgd2hpbGUgKHBoaSA8IDM2MCkge1xyXG4gICAgICAgICAgICAgICAgcGhpUmFkaWFucyA9IHBoaSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgICAgICAgICB4ID0gdGVtcFggKiBNYXRoLmNvcyhwaGlSYWRpYW5zKTtcclxuICAgICAgICAgICAgICAgIHogPSB0ZW1wWCAqIE1hdGguc2luKHBoaVJhZGlhbnMpO1xyXG4gICAgICAgICAgICAgICAgdmVydHNbaV0ucHVzaChuZXcgVmVydGV4KHgsIHksIHopKVxyXG4gICAgICAgICAgICAgICAgcGhpICs9IHNlY3RvclN0ZXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhldGEgKz0gc3RhY2tTdGVwO1xyXG4gICAgICAgICAgICBpKytcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgU1BIRVJFX1ZFUlRJQ0VTID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAwLCAxLCAwIC8vIFRvcCBwb2ludFxyXG5dKTtcclxuXHJcbmV4cG9ydCBjb25zdCBQWVJBTUlEX1ZFUlRJQ0VTID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAxLjAsIC0xLjAsIDEuMCwgMSwgMCwgMCxcclxuICAgIC0xLjAsIC0xLjAsIDEuMCwgMSwgMCwgMCwgXHJcbiAgICAwLjAsIDEuMCwgMC4wLCAxLCAwLCAwLCAvLyBmcm9udFxyXG5cclxuICAgIC0xLjAsIC0xLjAsIDEuMCwgMCwgMSwgMCxcclxuICAgIC0xLjAsIC0xLjAsIC0xLjAsIDAsIDEsIDAsXHJcbiAgICAwLjAsIDEuMCwgMC4wLCAwLCAxLCAwLCAvLyBsZWZ0XHJcblxyXG4gICAgMS4wLCAtMS4wLCAxLjAsIDAsIDAsIDEsXHJcbiAgICAxLjAsIC0xLjAsIC0xLjAsIDAsIDAsIDEsXHJcbiAgICAwLjAsIDEuMCwgMC4wLCAwLCAwLCAxLCAvLyByaWdodFxyXG5cclxuICAgIDEuMCwgLTEuMCwgLTEuMCwgMSwgMCwgMCxcclxuICAgIC0xLjAsIC0xLjAsIC0xLjAsIDEsIDAsIDAsXHJcbiAgICAwLjAsIDEuMCwgMC4wLCAxLCAwLCAwLCAvLyBiYWNrXHJcblxyXG4gICAgLTEuMCwgLTEuMCwgLTEuMCwgMCwgMSwgMCwgIFxyXG4gICAgMS4wLCAtMS4wLCAtMS4wLCAwLCAxLCAwLCAgXHJcbiAgICAxLjAsIC0xLjAsIDEuMCwgMCwgMSwgMCwgXHJcbiAgICAtMS4wLCAtMS4wLCAxLjAsIDAsIDEsIDAsIC8vIGJvdHRvbVxyXG5cclxuXSk7XHJcbmV4cG9ydCBjb25zdCBQWVJBTUlEX0lORElDRVMgPSBuZXcgVWludDE2QXJyYXkoW1xyXG4gICAgMCwgMSwgMixcclxuICAgIDMsIDQsIDUsXHJcbiAgICA2LCA3LCA4LCBcclxuICAgIDksIDEwLCAxMSxcclxuICAgIDEyLCAxMywgMTQsXHJcbiAgICAxMiwgMTQsIDE1LCAvLyBib3R0b21cclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgQ1VCRV9WRVJUSUNFUyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgLTEuMCwgLTEuMCwgMS4wLCAxLCAwLCAwLFxyXG4gICAgMS4wLCAtMS4wLCAxLjAsIDEsIDAsIDAsIFxyXG4gICAgMS4wLCAxLjAsIDEuMCwgMSwgMCwgMCwgXHJcbiAgICAtMS4wLCAxLjAsIDEuMCwgMSwgMCwgMCxcclxuXHJcbiAgLy8gQmFjayBmYWNlXHJcbiAgLTEuMCwgLTEuMCwgLTEuMCwgMSwgMCwgMCwgXHJcbiAgLTEuMCwgMS4wLCAtMS4wLCAxLCAwLCAwLCBcclxuICAxLjAsIDEuMCwgLTEuMCwgMSwgMCwgMCwgXHJcbiAgMS4wLCAtMS4wLCAtMS4wLCAxLCAwLCAwLFxyXG5cclxuICAvLyBUb3AgZmFjZVxyXG4gIC0xLjAsIDEuMCwgLTEuMCwgMCwgMSwgMCwgXHJcbiAgLTEuMCwgMS4wLCAxLjAsIDAsIDEsIDAsICBcclxuICAxLjAsIDEuMCwgMS4wLCAwLCAxLCAwLCAgXHJcbiAgMS4wLCAxLjAsIC0xLjAsIDAsIDEsIDAsIFxyXG5cclxuICAvLyBCb3R0b20gZmFjZVxyXG4gIC0xLjAsIC0xLjAsIC0xLjAsIDAsIDEsIDAsICBcclxuICAxLjAsIC0xLjAsIC0xLjAsIDAsIDEsIDAsICBcclxuICAxLjAsIC0xLjAsIDEuMCwgMCwgMSwgMCwgXHJcbiAgLTEuMCwgLTEuMCwgMS4wLCAwLCAxLCAwLCBcclxuXHJcbiAgLy8gUmlnaHQgZmFjZVxyXG4gIDEuMCwgLTEuMCwgLTEuMCwgMCwgMCwgMSwgIFxyXG4gIDEuMCwgMS4wLCAtMS4wLCAwLCAwLCAxLCAgXHJcbiAgMS4wLCAxLjAsIDEuMCwgMCwgMCwgMSwgIFxyXG4gIDEuMCwgLTEuMCwgMS4wLCAwLCAwLCAxLCBcclxuXHJcbiAgLy8gTGVmdCBmYWNlXHJcbiAgLTEuMCwgLTEuMCwgLTEuMCwgMCwgMCwgMSwgIFxyXG4gIC0xLjAsIC0xLjAsIDEuMCwgMCwgMCwgMSwgIFxyXG4gIC0xLjAsIDEuMCwgMS4wLCAwLCAwLCAxLCAgXHJcbiAgLTEuMCwgMS4wLCAtMS4wLCAwLCAwLCAxLCBcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgQ1VCRV9JTkRJQ0VTID0gbmV3IFVpbnQxNkFycmF5KFtcclxuICAgIDAsIDEsIDIsXHJcbiAgICAwLCAyLCAzLCAvLyBmcm9udFxyXG4gICAgNCwgNSwgNixcclxuICAgIDQsIDYsIDcsIC8vIGJhY2tcclxuICAgIDgsIDksIDEwLFxyXG4gICAgOCwgMTAsIDExLCAvLyB0b3BcclxuICAgIDEyLCAxMywgMTQsXHJcbiAgICAxMiwgMTQsIDE1LCAvLyBib3R0b21cclxuICAgIDE2LCAxNywgMTgsXHJcbiAgICAxNiwgMTgsIDE5LCAvLyByaWdodFxyXG4gICAgMjAsIDIxLCAyMixcclxuICAgIDIwLCAyMiwgMjMsIC8vIGxlZnRcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgVEFCTEVfVkVSVElDRVMgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgIC8vIFRvcCBmYWNlXHJcbiAgICAtMTAuMCwgMC4wLCAtMTAuMCwgMC4yLCAwLjIsIDAuMixcclxuICAgIC0xMC4wLCAwLjAsIDEwLjAsIDAuMiwgMC4yLCAwLjIsXHJcbiAgICAxMC4wLCAwLjAsIDEwLjAsIDAuMiwgMC4yLCAwLjIsXHJcbiAgICAxMC4wLCAwLjAsIC0xMC4wLCAwLjIsIDAuMiwgMC4yLFxyXG5dKTtcclxuXHJcbmV4cG9ydCBjb25zdCBUQUJMRV9JTkRJQ0VTID0gbmV3IFVpbnQxNkFycmF5KFtcclxuICAgIDAsIDEsIDIsXHJcbiAgICAwLCAyLCAzLCAvLyB0b3BcclxuXSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlM2RQb3NDb2xvckludGVybGVhdmVkVmFvKFxyXG4gICAgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsXHJcbiAgICB2ZXJ0ZXhCdWZmZXI6IFdlYkdMQnVmZmVyLCBpbmRleEJ1ZmZlcjogV2ViR0xCdWZmZXIsXHJcbiAgICBwb3NBdHRyaWI6IG51bWJlciwgY29sb3JBdHRyaWI6IG51bWJlcikge1xyXG4gICAgY29uc3QgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcclxuICAgIGlmICghdmFvKSB7XHJcbiAgICAgICAgc2hvd0Vycm9yKCdGYWlsZWQgdG8gY3JlYXRlIFZBTycpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xyXG5cclxuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc0F0dHJpYik7XHJcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckF0dHJpYik7XHJcblxyXG4gICAgLy8gSW50ZXJsZWF2ZWQgZm9ybWF0OiAoeCwgeSwgeiwgciwgZywgYikgKGFsbCBmMzIpXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgcG9zQXR0cmliLCAzLCBnbC5GTE9BVCwgZmFsc2UsXHJcbiAgICAgICAgNiAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMCk7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG4gICAgICAgIGNvbG9yQXR0cmliLCAzLCBnbC5GTE9BVCwgZmFsc2UsXHJcbiAgICAgICAgNiAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAzICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleEJ1ZmZlcik7XHJcbiAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcblxyXG4gICAgcmV0dXJuIHZhbztcclxufVxyXG4iLCJpbXBvcnQgeyB2ZWMzLCBSZWFkb25seVZlYzMgfSBmcm9tIFwiZ2wtbWF0cml4XCI7XG5pbXBvcnQgeyBMT0RNYW5hZ2VyIH0gZnJvbSBcIi4vTE9ETWFuYWdlclwiO1xuaW1wb3J0IHsgQmlnRGVjaW1hbCwgQmlnIH0gZnJvbSBcImJpZ2RlY2ltYWwuanNcIjtcbmltcG9ydCAqIGFzIGJWZWMzIGZyb20gXCIuLi91dGlscy9iaWctdmVjM1wiO1xuXG5leHBvcnQgY2xhc3MgQXN0cm9PYmplY3Qge1xuXHRcblxuXHRjb25zdHJ1Y3RvcihwdWJsaWMgcG9zaXRpb246IEJpZ0RlY2ltYWxbXSxcblx0XHQgICAgcHVibGljIHZlbG9jaXR5OiBCaWdEZWNpbWFsW10sXG5cdFx0ICAgIHB1YmxpYyBhY2NlbGVyYXRpb246IEJpZ0RlY2ltYWxbXSwgXG5cdFx0ICAgIHB1YmxpYyBuYW1lOiBzdHJpbmcsXG5cdFx0ICAgIHB1YmxpYyBtYXNzOiBCaWdEZWNpbWFsLFxuXHRcdCAgICBwdWJsaWMgc3lzdGVtU3BhY2U6IG51bWJlcixcblx0XHQgICAgcHVibGljIHN1YnN5c3RlbTogc3RyaW5nW10sXG5cdFx0ICAgIHB1YmxpYyBfcG9sYXJSYWRpdXM6IG51bWJlcixcblx0XHQgICAgcHJpdmF0ZSBfZXF1YXRvcmlhbFJhZGl1czogbnVtYmVyLFxuXHRcdCAgIHB1YmxpYyBfbG9kTWFuYWdlcjogTE9ETWFuYWdlcixcblx0XHQgICApIHtcblx0fVxuXG5cdHB1YmxpYyAgdXBkYXRlUGh5c2ljcyhkdDogbnVtYmVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oZHQpO1xuXHRcdHRoaXMuX3VwZGF0ZVZlbG9jaXR5KGR0KTtcblx0fVx0XG5cblx0Ly8gVXBkYXRlcyBBc3Ryb09iamVjdCBwb3NpdGlvbiBiYXNlZCBvbiBjaGFuZ2Ugb2YgdGltZSBhbmQgYWNjZWxlcmF0aW9uXG5cdHByaXZhdGUgX3VwZGF0ZVBvc2l0aW9uKGR0OiBudW1iZXIpIHtcblx0XHRjb25zdCBEVCA9IEJpZyhkdC50b1N0cmluZygpKTtcblx0XHRcblx0XHRsZXQgdjAgPSBiVmVjMy5jcmVhdGUoKTtcblx0XHRiVmVjMy5zY2FsZSh2MCwgdGhpcy52ZWxvY2l0eSwgRFQpO1xuXG5cdFx0bGV0IHIwID0gYlZlYzMuY3JlYXRlKCk7XG5cdFx0YlZlYzMuYWRkKHIwLCB0aGlzLnBvc2l0aW9uLCB2MCk7XG5cdFx0XG5cdFx0bGV0IGEwID0gYlZlYzMuY3JlYXRlKCk7XG5cdFx0bGV0IGFTY2FsZSA9IEJpZyhcIjAuNVwiKS5tdWx0aXBseShEVCk7XG5cdFx0YlZlYzMuc2NhbGUoYTAsIHRoaXMuYWNjZWxlcmF0aW9uLCBhU2NhbGUpO1xuXHRcdFxuXHRcdGJWZWMzLmFkZCh0aGlzLnBvc2l0aW9uLCByMCwgYTApO1xuXHR9XG5cblx0cHJpdmF0ZSBfdXBkYXRlVmVsb2NpdHkoZHQ6IG51bWJlcikge1xuXHRcdGNvbnN0IERUID0gQmlnKGR0LnRvU3RyaW5nKCkpO1xuXG5cdFx0Ly8gSW50ZXJtZWRpYXRlIHZlYzMncyB0byBjb3B5IHZlYzMgb3BlcmF0aW9ucyBpbnRvXG5cdFx0bGV0IGkxID0gYlZlYzMuY3JlYXRlKCk7XG5cblx0XHQvLyBDb3B5IGluaXRpYWwgdmVsb2NpdHkgdmFsdWVzXG5cdFx0bGV0IHYwID0gYlZlYzMuY3JlYXRlKCk7XG5cdFx0YlZlYzMuY29weSh2MCwgdGhpcy52ZWxvY2l0eSk7XG5cblx0XHQvLyBTZXQgbmV3IHZlbG9jaXR5XG5cdFx0YlZlYzMuc2NhbGUoaTEsIHRoaXMuYWNjZWxlcmF0aW9uLCBEVCk7XG5cdFx0YlZlYzMuYWRkKHRoaXMudmVsb2NpdHksIHYwLCBpMSk7XG5cdH1cblxufVxuIiwiaW1wb3J0IHsgdmVjMyB9IGZyb20gXCJnbC1tYXRyaXhcIjtcbmltcG9ydCB7IEFzdHJvT2JqZWN0IH0gZnJvbSBcIi4vQXN0cm9PYmplY3RcIjtcbmltcG9ydCB7IEJpZywgUm91bmRpbmdNb2RlLCBNQyB9IGZyb20gXCJiaWdkZWNpbWFsLmpzXCI7XG5pbXBvcnQgKiBhcyBiVmVjMyBmcm9tIFwiLi4vdXRpbHMvYmlnLXZlYzNcIjtcblxuLy8gR3Jhdml0YXRpb25hbCBjb25zdGFudCBpbiBtXjMqa2deLTEqc14tMlxuY29uc3QgRyA9ICg2LjY3NDMgKiAoMTAqKi0xMSkpO1xuXG4vLyBUaGlzIGhhbmRsZXMgcGh5c2ljcyBmb3IgYW4gZW50aXJlIEFzdHJvbm9taWNhbCBzeXN0ZW1cbi8vIEV4YW1wbGVzIHdvdWxkIGJlIFRoZSBTb2xhciBTeXN0ZW0gYW5kIEFscGhhIENlbnRhdXJpLlxuZXhwb3J0IGNsYXNzIEFzdHJvU3lzdGVtIHtcblxuXHRjb25zdHJ1Y3RvcihwdWJsaWMgX2FzdHJvT2JqZWN0TGlzdDogQXN0cm9PYmplY3RbXSkgeyB9XG5cblx0Ly8gQ2FsY3VsYXRlcyBuZXcgYWNjZWxlcmF0aW9uIHZhbHVlcyBkdWUgdG8gZ3Jhdml0eSBhbmQgY29tcHV0ZXMgbmV3IHBvc2l0aW9ucyBvZiBlYWNoIGFzdHJvIG9iamVjdCBpbiB0aGUgc3lzdGVtXG5cdHB1YmxpYyB1cGRhdGVBc3Ryb1N5c3RlbShkdDogbnVtYmVyKSB7XG5cdFx0XG5cdFx0dGhpcy5fY29tcHV0ZUdyYXZpdHlWZWN0b3JzKCk7XG5cblx0XHRjb25zdCB0ZnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuXHRcdGZvciAoY29uc3QgYXN0cm9PYmplY3Qgb2YgdGhpcy5fYXN0cm9PYmplY3RMaXN0KSB7XG5cdFx0XHRhc3Ryb09iamVjdC51cGRhdGVQaHlzaWNzKGR0KTtcdFxuXHRcdH1cblxuXHRcdGNvbnNvbGUubG9nKChwZXJmb3JtYW5jZS5ub3coKS10ZnQpLzEwMDApO1xuXHR9XG5cblx0cHJpdmF0ZSBfY29tcHV0ZUdyYXZpdHlWZWN0b3JzKCkge1xuXHRcdFxuXHRcdC8vIFplcm8gb3V0IGV2ZXJ5IEFzdHJvT2JqZWN0J3MgYWNjZWxlcmF0aW9uXG5cdFx0Zm9yIChjb25zdCBhc3Ryb09iamVjdCBvZiB0aGlzLl9hc3Ryb09iamVjdExpc3QpIHtcblx0XHRcdGJWZWMzLnplcm8oYXN0cm9PYmplY3QuYWNjZWxlcmF0aW9uKTtcblx0XHR9XG5cblx0XHQvLyBSZWNhbGN1bGF0ZSB0aGUgYWNjZWxlcmF0aW9uIGR1ZSB0byBncmF2aXR5IGZvciBldmVyeSBBc3Ryb09iamVjdCBpbiB0aGUgc3lzdGVtXG5cdFx0Ly8gVGhlIGludmFyaWFudCBpcyB0aGF0IHRoZSBncmF2aXR5IGlzIGNvbXBsZXRlbHkgY2FsY3VsYXRlZCBmb3IgZXZlcnkgQXN0cm9PYmplY3QgdG8gdGhlIGxlZnQgb2YgaVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgKHRoaXMuX2FzdHJvT2JqZWN0TGlzdC5sZW5ndGggLSAxKTsgaSsrKSB7XG5cdFx0XHRmb3IgKGxldCBqID0gKGkgKyAxKTsgaiA8IHRoaXMuX2FzdHJvT2JqZWN0TGlzdC5sZW5ndGg7IGorKykge1xuXHRcdFxuXHRcdFx0XHRsZXQgZ3Jhdml0eUFjY2VsSSA9IGJWZWMzLmNyZWF0ZSgpO1xuXHRcdFx0XHRsZXQgZ3Jhdml0eUFjY2VsSiA9IGJWZWMzLmNyZWF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHQvLyBGaW5kIGRpcmVjdGlvbmFsIHZlY3RvcnMgZm9yIHRoZSBmb3JjZSBvZiBncmF2aXR5IGJldHdlZW4gdGhlIDIgQXN0cm9PYmplY3RzXG5cdFx0XHRcdGJWZWMzLnN1YnRyYWN0KGdyYXZpdHlBY2NlbEksIHRoaXMuX2FzdHJvT2JqZWN0TGlzdFtqXS5wb3NpdGlvbiwgdGhpcy5fYXN0cm9PYmplY3RMaXN0W2ldLnBvc2l0aW9uKTtcblx0XHRcdFx0YlZlYzMubmVnYXRlKGdyYXZpdHlBY2NlbEosIGdyYXZpdHlBY2NlbEkpO1xuXG5cdFx0XHRcdC8vIE5vcm1hbGl6ZSB0aGUgZGlyZWN0aW9uYWwgdmVjdG9yc1xuXHRcdFx0XHRiVmVjMy5ub3JtYWxpemUoZ3Jhdml0eUFjY2VsSSwgZ3Jhdml0eUFjY2VsSSk7XG5cdFx0XHRcdGJWZWMzLm5vcm1hbGl6ZShncmF2aXR5QWNjZWxKLCBncmF2aXR5QWNjZWxKKTtcblxuXHRcdFx0XHRjb25zdCBzcURpc3RhbmNlID0gYlZlYzMuZGlzdGFuY2UodGhpcy5fYXN0cm9PYmplY3RMaXN0W2ldLnBvc2l0aW9uLCB0aGlzLl9hc3Ryb09iamVjdExpc3Rbal0ucG9zaXRpb24pO1xuXG5cdFx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgbWFnbml0dWRlIG9mIHRoZSBmb3JjZSBvZiBncmF2aXR5IGZvciBib3RoIG9iamVjdHNcdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBnTWFnSSA9IChCaWcoRy50b1N0cmluZygpKS5tdWx0aXBseSh0aGlzLl9hc3Ryb09iamVjdExpc3Rbal0ubWFzcykpLmRpdmlkZShzcURpc3RhbmNlLnBvdygyKSwgMjAsIFJvdW5kaW5nTW9kZS5DRUlMSU5HKTtcblx0XHRcdFx0Y29uc3QgZ01hZ0ogPSAoQmlnKEcudG9TdHJpbmcoKSkubXVsdGlwbHkodGhpcy5fYXN0cm9PYmplY3RMaXN0W2ldLm1hc3MpKS5kaXZpZGUoc3FEaXN0YW5jZS5wb3coMiksIDIwLCBSb3VuZGluZ01vZGUuQ0VJTElORyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0YlZlYzMuc2NhbGUoZ3Jhdml0eUFjY2VsSSwgZ3Jhdml0eUFjY2VsSSwgZ01hZ0kpO1xuXHRcdFx0XHRiVmVjMy5zY2FsZShncmF2aXR5QWNjZWxKLCBncmF2aXR5QWNjZWxKLCBnTWFnSik7XG5cblx0XHRcdFx0Ly8gQ29tcG91bmQgYWNjZWxlcmF0aW9uIGR1ZSB0byBncmF2aXR5IGZvciBib3RoIG9iamVjdHMgdG8gZ2V0IHRoZWlyIG92ZXJhbGwgYWNjZWxlcmF0aW9uXG5cdFx0XHRcdGJWZWMzLmFkZCh0aGlzLl9hc3Ryb09iamVjdExpc3RbaV0uYWNjZWxlcmF0aW9uLCB0aGlzLl9hc3Ryb09iamVjdExpc3RbaV0uYWNjZWxlcmF0aW9uLCBncmF2aXR5QWNjZWxJKTtcblx0XHRcdFx0YlZlYzMuYWRkKHRoaXMuX2FzdHJvT2JqZWN0TGlzdFtqXS5hY2NlbGVyYXRpb24sIHRoaXMuX2FzdHJvT2JqZWN0TGlzdFtqXS5hY2NlbGVyYXRpb24sIGdyYXZpdHlBY2NlbEopO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBnZXREcmF3TGlzdCh1c2VyUG9zaXRpb246IHZlYzMpOiBBc3Ryb09iamVjdFtdIHtcblx0XHRsZXQgZXZhbExpc3Q6IEFzdHJvT2JqZWN0W10gPSBbXVxuXHRcdGZvcihsZXQgayA9IDA7IGsgPCB0aGlzLl9hc3Ryb09iamVjdExpc3QubGVuZ3RoOyBrKyspIHtcblx0XHRcdGlmKHRoaXMuX2FzdHJvT2JqZWN0TGlzdFtrXS5uYW1lID09IFwiU3VuXCIpIHtcblx0XHRcdFx0ZXZhbExpc3QucHVzaCh0aGlzLl9hc3Ryb09iamVjdExpc3Rba10pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxldCByZXRMaXN0OiBBc3Ryb09iamVjdFtdID0gW11cblx0XHR3aGlsZSAoZXZhbExpc3QubGVuZ3RoICE9IDApIHtcblx0XHRcdHJldExpc3QucHVzaChldmFsTGlzdC5zaGlmdCgpISk7XG5cdFx0XHRsZXQgdiA9IGJWZWMzLmNyZWF0ZSgpXG5cdFx0XHRiVmVjMy5zY2FsZSh2LCByZXRMaXN0W3JldExpc3QubGVuZ3RoLTFdLnBvc2l0aW9uLCBCaWcoXCIxMFwiKS5wb3coLTksIG5ldyBNQygyMCkpKVxuXHRcdFx0aWYgKEJpZygocmV0TGlzdFtyZXRMaXN0Lmxlbmd0aC0xXS5zeXN0ZW1TcGFjZSkudG9TdHJpbmcoKSkuZ3JlYXRlclRoYW4oYlZlYzMuZGlzdGFuY2UoYlZlYzMuZnJvbVZhbHVlcyh1c2VyUG9zaXRpb25bMF0udG9TdHJpbmcoKSwgdXNlclBvc2l0aW9uWzFdLnRvU3RyaW5nKCksIHVzZXJQb3NpdGlvblsyXS50b1N0cmluZygpKSwgdikpKSB7XG5cdFx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9hc3Ryb09iamVjdExpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgcmV0TGlzdFtyZXRMaXN0Lmxlbmd0aC0xXS5zdWJzeXN0ZW0ubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmIChyZXRMaXN0W3JldExpc3QubGVuZ3RoLTFdLnN1YnN5c3RlbVtqXSA9PSB0aGlzLl9hc3Ryb09iamVjdExpc3RbaV0ubmFtZSkge1xuXHRcdFx0XHRcdFx0XHRldmFsTGlzdC5wdXNoKHRoaXMuX2FzdHJvT2JqZWN0TGlzdFtpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc29sZS5sb2cocmV0TGlzdClcblx0XHRyZXR1cm4gcmV0TGlzdDtcblx0fVxufVxuIiwiaW1wb3J0IHsgdmVjMywgdmVjNCwgbWF0NCB9IGZyb20gXCJnbC1tYXRyaXhcIjtcbmltcG9ydCB7IFdlYkdMU2hhcGUgfSBmcm9tIFwiLi9XZWJHTFNoYXBlXCI7XG5pbXBvcnQgeyBVc2VyQ29udHJvbGxlciB9IGZyb20gXCIuLi9jb250cm9sbGVycy9Vc2VyQ29udHJvbGxlclwiO1xuaW1wb3J0IHsgQXN0cm9PYmplY3QgfSBmcm9tIFwiLi9Bc3Ryb09iamVjdFwiO1xuXG5cbmV4cG9ydCBjbGFzcyBMT0RNYW5hZ2VyIHtcblx0cHJpdmF0ZSBfZGl2OiBIVE1MRGl2RWxlbWVudDtcdFxuXHRwdWJsaWMgYXN0cm9PYmplY3Q6IEFzdHJvT2JqZWN0IHwgbnVsbDtcblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSBfc2hhcGU6IFdlYkdMU2hhcGUsXHRcblx0XHRkaXZDb250YWluZXJFbGVtZW50OiBFbGVtZW50LCBcblx0bmFtZTogc3RyaW5nLCBwdWJsaWMgdXNlckNvbnRyb2xsZXI6IFVzZXJDb250cm9sbGVyKSB7XG5cdFx0dGhpcy5fZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRpZiAobmFtZSA9PSBcIlN1blwiKSB7XG5cdFx0XHR0aGlzLl9kaXYuY2xhc3NOYW1lID0gXCJzdW5cIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZGl2LmNsYXNzTmFtZSA9IFwicGxhbmV0XCI7XG5cdFx0fVxuXHRcdGxldCB0eHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdHR4dC5jbGFzc05hbWUgPSBcInRleHQtbm9kZVwiO1xuXHRcdGxldCBkb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdGxldCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5hbWUpO1xuXHRcdHR4dC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG5cdFx0dGhpcy5fZGl2LmFwcGVuZENoaWxkKHR4dCk7XG5cdFx0ZGl2Q29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9kaXYpO1xuXHRcdHRoaXMuYXN0cm9PYmplY3QgPSBudWxsO1xuXHRcdH1cblx0cHVibGljIHNldEFzdHJvT2JqZWN0KGFzdDogQXN0cm9PYmplY3QpIHtcdFxuXHRcdHRoaXMuYXN0cm9PYmplY3QgPSBhc3Q7XG5cdFx0bGV0IHRoYXQgPSB0aGlzO1xuXHRcdHRoaXMuX2Rpdi5vbmNsaWNrID0gZnVuY3Rpb24oKSB7IGlmKHRoYXQuYXN0cm9PYmplY3QgIT0gbnVsbCkge3RoYXQudXNlckNvbnRyb2xsZXIuc2V0Q291cGxlZEFzdHJvT2JqZWN0KHRoYXQuYXN0cm9PYmplY3QpfX07XG5cdH1cblx0cHVibGljIHRlc3RDbGljaygpIHtcblx0XHRpZiAodGhpcy5hc3Ryb09iamVjdCAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLnVzZXJDb250cm9sbGVyLnNldENvdXBsZWRBc3Ryb09iamVjdCh0aGlzLmFzdHJvT2JqZWN0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coXCJObyBjb3VwbGVkIG9iamVjdFwiLCB0aGlzLmFzdHJvT2JqZWN0KTtcblx0XHR9XG5cdH1cblx0cHVibGljIGRyYXcoZHQ6IG51bWJlcixcblx0XHQgICAgaXNWaXNpYmxlOiBib29sZWFuLFxuXHRcdCAgICBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCxcblx0XHQgICAgbWF0V29ybGRVbmlmb3JtOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbixcblx0XHQgICAgZHJhd1BvczogdmVjMyxcblx0XHQgICAgbXZwOiBtYXQ0LFxuXHRcdCAgIGRyYXdPcmRlcjogbnVtYmVyKSB7XG5cblx0XHR0aGlzLl9zaGFwZS5kcmF3KGdsLCBtYXRXb3JsZFVuaWZvcm0sIGRyYXdQb3MsIGR0KTtcblx0XHRpZiAoIWlzVmlzaWJsZSkge1xuXHRcdFx0dGhpcy5fZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGNsaXBzcGFjZSA9IHZlYzQuY3JlYXRlKCk7XG5cdFx0XHR2ZWM0LnRyYW5zZm9ybU1hdDQoY2xpcHNwYWNlLCBbZHJhd1Bvc1swXSwgZHJhd1Bvc1sxXSwgZHJhd1Bvc1syXSwgMV0sIG12cCk7XG5cdFx0XHRjbGlwc3BhY2VbMF0gLz0gY2xpcHNwYWNlWzJdO1xuXHRcdFx0Y2xpcHNwYWNlWzFdIC89IGNsaXBzcGFjZVsyXTtcblxuXHRcdFx0bGV0IHBpeGVsWCA9IChjbGlwc3BhY2VbMF0gKiAwLjUgKyAwLjUpICogZ2wuY2FudmFzLndpZHRoO1xuXHRcdFx0bGV0IHBpeGVsWSA9IChjbGlwc3BhY2VbMV0gKiAtMC41ICsgMC41KSAqIGdsLmNhbnZhcy5oZWlnaHQ7XG5cdFx0XHRpZiAoY2xpcHNwYWNlWzJdID49IDApIHtcblx0XHRcdFx0dGhpcy5fZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG5cdFx0XHRcdHRoaXMuX2Rpdi5zdHlsZS56SW5kZXggPSBgJHtkcmF3T3JkZXJ9YDtcblx0XHRcdFx0dGhpcy5fZGl2LnN0eWxlLmxlZnQgPSBgJHtNYXRoLmZsb29yKHBpeGVsWCl9cHhgO1xuXHRcdFx0XHR0aGlzLl9kaXYuc3R5bGUudG9wID0gYCR7TWF0aC5mbG9vcihwaXhlbFkpfXB4YDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2Rpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cbn1cbiIsImltcG9ydCB7IHZlYzMsIFJlYWRvbmx5VmVjMywgbWF0NCwgcXVhdCB9IGZyb20gXCJnbC1tYXRyaXhcIjtcbmltcG9ydCB7IHNob3dFcnJvciwgY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyLCBjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlciB9IGZyb20gXCIuLi91dGlscy9nbC11dGlsc1wiO1xuaW1wb3J0IHsgU3BoZXJlLCBjcmVhdGUzZFBvc0NvbG9ySW50ZXJsZWF2ZWRWYW8gfSBmcm9tIFwiLi4vZ2VvbWV0cnlcIjtcblxuZXhwb3J0IGNsYXNzIFdlYkdMU2hhcGUge1xuXHRcblx0cHJpdmF0ZSBfbWF0V29ybGQ6IG1hdDQ7XG5cdHByaXZhdGUgX3NjYWxlVmVjOiB2ZWMzO1xuXHRwcml2YXRlIF9yb3RhdGlvbjogcXVhdDtcblx0cHVibGljIHJlYWRvbmx5IHZhbzogV2ViR0xWZXJ0ZXhBcnJheU9iamVjdDtcblx0cHVibGljIHJlYWRvbmx5IG51bUluZGljZXM6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIF9wb3M6IHZlYzMsXG5cdFx0cHJpdmF0ZSBfc2NhbGU6IG51bWJlcixcblx0XHRwcml2YXRlIF9yb3RhdGlvbkF4aXM6IHZlYzMsXG5cdFx0cHJpdmF0ZSBfeVJvdGF0aW9uQW5nbGU6IG51bWJlcixcblx0XHRwcml2YXRlIF96Um90YXRpb25BbmdsZTogbnVtYmVyLFxuXHRcdHByaXZhdGUgX3JvdGF0aW9uU3BlZWQ6IG51bWJlcixcblx0XHRnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCxcblx0XHRwb3NBdHRyaWI6IG51bWJlciwgXG5cdFx0Y29sb3JBdHRyaWI6IG51bWJlcikge1xuXG5cdFx0dGhpcy5fbWF0V29ybGQgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3NjYWxlVmVjID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0aGlzLl9yb3RhdGlvbiA9IHF1YXQuY3JlYXRlKCk7XG5cblx0XHRsZXQgZWxsaXBzb2lkID0gbmV3IFNwaGVyZSgzNiwgMzYsIDEsIDEpO1xuXHRcdGxldCBlbGxpcHNvaWRWZXJ0aWNlcyA9IGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihnbCwgZWxsaXBzb2lkLnZlcnRpY2VzKTtcblx0XHRsZXQgZWxsaXBzb2lkSW5kaWNlcyA9IGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGdsLCBlbGxpcHNvaWQuaW5kaWNlcyk7XG5cblx0XHRpZiAoIWVsbGlwc29pZFZlcnRpY2VzIHx8ICFlbGxpcHNvaWRJbmRpY2VzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgZ2VvOiBlbGxpcHNvaWQgKHY9JHshIWVsbGlwc29pZFZlcnRpY2VzfSwgaT0ke2VsbGlwc29pZEluZGljZXN9KWApO1xuXHRcdH1cblx0XHRcblx0XHRsZXQgZWxsaXBzb2lkVmFvID0gY3JlYXRlM2RQb3NDb2xvckludGVybGVhdmVkVmFvKGdsLCBlbGxpcHNvaWRWZXJ0aWNlcywgZWxsaXBzb2lkSW5kaWNlcywgcG9zQXR0cmliLCBjb2xvckF0dHJpYik7XG5cdFx0aWYgKCFlbGxpcHNvaWRWYW8pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBnZW86IGVsbGlwc29pZD0keyEhZWxsaXBzb2lkVmFvfWApO1xuXHRcdH1cblx0XHR0aGlzLnZhbyA9IGVsbGlwc29pZFZhbztcblx0XHR0aGlzLm51bUluZGljZXMgPSBlbGxpcHNvaWQuaW5kaWNlcy5sZW5ndGg7XG5cdH1cblxuXHRwdWJsaWMgZHJhdyhcblx0XHRnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgXG5cdFx0bWF0V29ybGRVbmlmb3JtOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbixcblx0XHRkcmF3UG9zOiB2ZWMzLCBcblx0XHRkdDogbnVtYmVyKSB7XG5cdFx0dGhpcy5fcm90YXRlKGR0KTtcblxuXHRcdGxldCBpUXVhdCA9IHF1YXQuY3JlYXRlKCk7XG5cdFx0bGV0IHlRdWF0ID0gcXVhdC5jcmVhdGUoKTtcblx0XHRsZXQgelF1YXQgPSBxdWF0LmNyZWF0ZSgpO1xuXG5cdFx0cXVhdC5zZXRBeGlzQW5nbGUoeVF1YXQsIHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKSwgdGhpcy5feVJvdGF0aW9uQW5nbGUpO1xuXHRcdHF1YXQuc2V0QXhpc0FuZ2xlKHpRdWF0LCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMSksIHRoaXMuX3pSb3RhdGlvbkFuZ2xlKTtcblx0XHRxdWF0Lm11bHRpcGx5KHRoaXMuX3JvdGF0aW9uLCB6UXVhdCwgeVF1YXQpO1xuXHRcdFxuXHRcdHZlYzMuc2V0KHRoaXMuX3NjYWxlVmVjLCB0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUsIHRoaXMuX3NjYWxlKTtcblxuXG5cdFx0bWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKFxuXHRcdFx0dGhpcy5fbWF0V29ybGQsXG5cdFx0XHR0aGlzLl9yb3RhdGlvbixcblx0XHRcdGRyYXdQb3MsXG5cdFx0XHR0aGlzLl9zY2FsZVZlYyk7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KG1hdFdvcmxkVW5pZm9ybSwgZmFsc2UsIHRoaXMuX21hdFdvcmxkKTtcblxuXHRcdGdsLmJpbmRWZXJ0ZXhBcnJheSh0aGlzLnZhbyk7XG5cdFx0Z2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5udW1JbmRpY2VzLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG5cdFx0Z2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuXG5cblxuXHR9XG5cblx0cHJpdmF0ZSBfcm90YXRlKGR0OiBudW1iZXIpIHtcblx0XHR0aGlzLl95Um90YXRpb25BbmdsZSArPSAodGhpcy5fcm90YXRpb25TcGVlZCAqIGR0KTtcblx0XHRpZiAodGhpcy5feVJvdGF0aW9uQW5nbGUgPj0gKDIgKiBNYXRoLlBJKSkge1xuXHRcdFx0dGhpcy5feVJvdGF0aW9uQW5nbGUgLT0gKDIgKiBNYXRoLlBJKVxuXHRcdH1cblx0fVxuXG5cblxufVxuXG4iLCJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcvY29uZmlnJztcbmltcG9ydCB7IEFzdHJvT2JqZWN0U3RhdGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL0FzdHJvT2JqZWN0U3RhdGUnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1plcm9lcyB9IGZyb20gJy4uL3V0aWxzL2FwaS11dGlscyc7XG5cblxuXG5leHBvcnQgY2xhc3MgQXBpQ2xpZW50IHtcblx0XG5cdHByaXZhdGUgX2Jhc2VBcGlVcmw6IHN0cmluZztcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9iYXNlQXBpVXJsID0gYCR7Y29uZmlnLmFwaVVybH1gO1xuXHR9XG5cblx0Ly8gQ2FsbHMgQXBpIHRvIGdldCB0aGUgcG9zaXRpb25zIGFuZCB2ZWxvY2l0aWVzIG9mIEFzdHJvT2JqZWN0cyBhdCBhIGNlcnRhaW4gdGltZS4gUmV0dXJucyBhIGRpY3Rpb25hcnkgd2hlcmUgdGhlIGtleSBpcyB0aGUgQXN0cm9PYmplY3QgSWQgYW5kIHRoZSB2YWx1ZSBoYXMgdGhlIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eSBkYXRhXG5cdGFzeW5jIGdldEVwaGVtZXJpcyhkYXRlVGltZTogRGF0ZSwgYXN0cm9JZExpc3Q6IHN0cmluZ1tdKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBBc3Ryb09iamVjdFN0YXRlPj4ge1xuXHRcdGxldCBlcGhlbWVyaXNEaWN0OiBSZWNvcmQ8c3RyaW5nLCBBc3Ryb09iamVjdFN0YXRlPiA9IHt9O1xuXHRcdGNvbnN0IGRhdGVUaW1lU3RyID0gdGhpcy5fZm9ybWF0RGF0ZVRpbWUoZGF0ZVRpbWUpO1xuXHRcdFxuXHRcdC8vIENhbGxzIHRoZSBBcGkgZm9yIGVhY2ggQXN0cm9PYmplY3QgSWRcblx0XHRmb3IgKGNvbnN0IGlkIG9mIGFzdHJvSWRMaXN0KSB7XG5cdFx0XHRsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLl9iYXNlQXBpVXJsfS9wbGFuZXQtc3RhdGU/aWQ9JHtpZH0mdGltZXN0YW1wPSR7ZGF0ZVRpbWVTdHJ9YCwgeyBtZXRob2Q6ICdHRVQnfSk7XG5cdFx0XHRpZiAoIXJlc3BvbnNlLm9rKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcblx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRsZXQgZGF0YTogQXN0cm9PYmplY3RTdGF0ZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblx0XHRcdGVwaGVtZXJpc0RpY3RbaWRdID0gZGF0YTtcblx0XHR9XG5cdFx0cmV0dXJuIGVwaGVtZXJpc0RpY3Q7XG5cdH1cblxuXHQvLyBGb3JtYXRzIERhdGUgb2JqZWN0IGludG8gc3RyaW5nIG9mIGZvcm1hdCBZWVlZLU1NLURELUhIOm1tXG5cdHByaXZhdGUgX2Zvcm1hdERhdGVUaW1lKGRhdGVUaW1lOiBEYXRlKTogc3RyaW5nIHtcblx0XHRjb25zdCB5ZWFyID0gYWRkTGVhZGluZ1plcm9lcyhTdHJpbmcoZGF0ZVRpbWUuZ2V0RnVsbFllYXIoKSksIDQpO1xuXHRcdGNvbnN0IG1vbnRoID0gYWRkTGVhZGluZ1plcm9lcyhTdHJpbmcoZGF0ZVRpbWUuZ2V0TW9udGgoKSksIDIpO1xuXHRcdGNvbnN0IGRheSA9IGFkZExlYWRpbmdaZXJvZXMoU3RyaW5nKGRhdGVUaW1lLmdldERhdGUoKSksIDIpO1xuXHRcdGNvbnN0IGhvdXIgPSBhZGRMZWFkaW5nWmVyb2VzKFN0cmluZyhkYXRlVGltZS5nZXRIb3VycygpKSwgMik7XG5cdFx0Y29uc3QgbWludXRlID0gYWRkTGVhZGluZ1plcm9lcyhTdHJpbmcoZGF0ZVRpbWUuZ2V0TWludXRlcygpKSwgMik7XG5cdFx0XG5cdFx0cmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fS0ke2hvdXJ9OiR7bWludXRlfWA7XG5cdH1cbn1cbiIsIlxuLy8gUGFkcyBzdHJpbmdzIHdpdGggbGVhZGluZyB6ZXJvZXMgdG8gb2J0YWluIGEgY2VydGFpbiBsZW5ndGguIFByaW1hcmlseSB1c2VkIGZvciBmb3JtYXR0aW5nIHRoZSBEYXRlIHN0cmluZ3MgaW4gQXBpIGNhbGxzLlxuZXhwb3J0IGZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvZXMoc3RyOiBzdHJpbmcsIHRhcmdldExlbjogbnVtYmVyKTogc3RyaW5nIHtcblx0d2hpbGUgKHN0ci5sZW5ndGggPCB0YXJnZXRMZW4pIHtcblx0XHRzdHIgPSAnMCcgKyBzdHI7XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cbiIsImltcG9ydCB7IEJpZywgQmlnRGVjaW1hbCwgTWF0aENvbnRleHQsIE1DLCBSb3VuZGluZ01vZGUgfSBmcm9tIFwiYmlnZGVjaW1hbC5qc1wiO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gXCJnbC1tYXRyaXhcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpOiBCaWdEZWNpbWFsW10ge1xuXHRsZXQgb3V0OiBCaWdEZWNpbWFsW10gPSBbQmlnKFwiMFwiKSwgQmlnKFwiMFwiKSwgQmlnKFwiMFwiKV07XG5cdHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhOiBCaWdEZWNpbWFsW10pOiBCaWdEZWNpbWFsW10ge1xuXHRsZXQgb3V0OiBCaWdEZWNpbWFsW10gPSBbYVswXSwgYVsxXSwgIGFbMl1dO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGE6IEJpZ0RlY2ltYWxbXSk6IEJpZ0RlY2ltYWwge1xuXHRjb25zdCBtYyA9IG5ldyBNQygyMCwgUm91bmRpbmdNb2RlLkNFSUxJTkcpO1xuXHRjb25zdCB4OiBCaWdEZWNpbWFsID0gYVswXTtcblx0Y29uc3QgeTogQmlnRGVjaW1hbCA9IGFbMV07XG5cdGNvbnN0IHo6IEJpZ0RlY2ltYWwgPSBhWzJdO1xuXHRjb25zdCBzdW1TcXVhcmVzID0gKCgoeC5tdWx0aXBseSh4KSkuYWRkKHkubXVsdGlwbHkoeSkpKS5hZGQoei5tdWx0aXBseSh6KSkpO1xuXHRyZXR1cm4gc3VtU3F1YXJlcy5zcXJ0KG1jKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeDogc3RyaW5nLCB5OiBzdHJpbmcsIHo6IHN0cmluZyk6IEJpZ0RlY2ltYWxbXSB7XG5cdGxldCBvdXQ6IEJpZ0RlY2ltYWxbXSA9IFtCaWcoeCksIEJpZyh5KSwgQmlnKHopXTtcblx0cmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0OiBCaWdEZWNpbWFsW10sIGE6IEJpZ0RlY2ltYWxbXSk6IEJpZ0RlY2ltYWxbXSB7XG5cdG91dFswXSA9IGFbMF07XG5cdG91dFsxXSA9IGFbMV07XG5cdG91dFsyXSA9IGFbMl07XG5cdHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0OiBCaWdEZWNpbWFsW10sIHg6IEJpZ0RlY2ltYWwsIHk6IEJpZ0RlY2ltYWwsIHo6IEJpZ0RlY2ltYWwpOiBCaWdEZWNpbWFsW10ge1xuXHRvdXRbMF0gPSB4O1xuXHRvdXRbMV0gPSB5O1xuXHRvdXRbMl0gPSB6O1xuXHRyZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dDogQmlnRGVjaW1hbFtdLCBhOiBCaWdEZWNpbWFsW10sIGI6IEJpZ0RlY2ltYWxbXSk6IEJpZ0RlY2ltYWxbXSB7XG5cdGNvbnN0IG1jID0gbmV3IE1DKDIwKTtcblx0b3V0WzBdID0gYVswXS5hZGQoYlswXSwgbWMpO1xuXHRvdXRbMV0gPSBhWzFdLmFkZChiWzFdLCBtYyk7XG5cdG91dFsyXSA9IGFbMl0uYWRkKGJbMl0sIG1jKTtcblx0cmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dDogQmlnRGVjaW1hbFtdLCBhOiBCaWdEZWNpbWFsW10sIGI6IEJpZ0RlY2ltYWxbXSk6IEJpZ0RlY2ltYWxbXSB7XG5cdG91dFswXSA9IGFbMF0uc3VidHJhY3QoYlswXSk7XG5cdG91dFsxXSA9IGFbMV0uc3VidHJhY3QoYlsxXSk7XG5cdG91dFsyXSA9IGFbMl0uc3VidHJhY3QoYlsyXSk7XG5cdHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQ6IEJpZ0RlY2ltYWxbXSwgYTogQmlnRGVjaW1hbFtdLCBiOiBCaWdEZWNpbWFsW10pOiBCaWdEZWNpbWFsW10ge1xuXHRvdXRbMF0gPSBhWzBdLm11bHRpcGx5KGJbMF0pO1xuXHRvdXRbMV0gPSBhWzFdLm11bHRpcGx5KGJbMV0pO1xuXHRvdXRbMl0gPSBhWzJdLm11bHRpcGx5KGJbMl0pO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0OiBCaWdEZWNpbWFsW10sIGE6IEJpZ0RlY2ltYWxbXSwgYjogQmlnRGVjaW1hbFtdKTogQmlnRGVjaW1hbFtdIHtcblx0b3V0WzBdID0gYVswXS5kaXZpZGUoYlswXSwgMjAsIFJvdW5kaW5nTW9kZS5DRUlMSU5HKTtcblx0b3V0WzFdID0gYVsxXS5kaXZpZGUoYlsxXSwgMjAsIFJvdW5kaW5nTW9kZS5DRUlMSU5HKTtcblx0b3V0WzJdID0gYVsyXS5kaXZpZGUoYlsyXSwgMjAsIFJvdW5kaW5nTW9kZS5DRUlMSU5HKTtcblx0cmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2VpbE1DKG51bTogQmlnRGVjaW1hbCk6IE1hdGhDb250ZXh0IHtcblx0aWYobnVtLnByZWNpc2lvbigpID09IG51bS5zY2FsZSgpKSB7XG5cdFx0cmV0dXJuIG5ldyBNQygxLCBSb3VuZGluZ01vZGUuQ0VJTElORyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBNQyhudW0ucHJlY2lzaW9uKCktbnVtLnNjYWxlKCksIFJvdW5kaW5nTW9kZS5DRUlMSU5HKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQ6IEJpZ0RlY2ltYWxbXSwgYTogQmlnRGVjaW1hbFtdKTogQmlnRGVjaW1hbFtdIHtcblx0b3V0WzBdID0gYVswXS5yb3VuZChnZXRDZWlsTUMoYVswXSkpO1xuXHRcblx0b3V0WzFdID0gYVsxXS5yb3VuZChnZXRDZWlsTUMoYVsxXSkpO1xuXHRvdXRbMl0gPSBhWzJdLnJvdW5kKGdldENlaWxNQyhhWzJdKSk7XG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGdldEZsb29yTUMobnVtOiBCaWdEZWNpbWFsKTogTWF0aENvbnRleHQge1xuXHRpZihudW0ucHJlY2lzaW9uKCkgPT0gbnVtLnNjYWxlKCkpIHtcblx0XHRyZXR1cm4gbmV3IE1DKDEsIFJvdW5kaW5nTW9kZS5GTE9PUik7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBNQyhudW0ucHJlY2lzaW9uKCktbnVtLnNjYWxlKCksIFJvdW5kaW5nTW9kZS5GTE9PUik7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dDogQmlnRGVjaW1hbFtdLCBhOiBCaWdEZWNpbWFsW10pOiBCaWdEZWNpbWFsW10ge1xuXHRvdXRbMF0gPSBhWzBdLnJvdW5kKGdldEZsb29yTUMoYVswXSkpO1xuXHRcblx0b3V0WzFdID0gYVsxXS5yb3VuZChnZXRGbG9vck1DKGFbMV0pKTtcblx0b3V0WzJdID0gYVsyXS5yb3VuZChnZXRGbG9vck1DKGFbMl0pKTtcblx0cmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQ6IEJpZ0RlY2ltYWxbXSwgYTogQmlnRGVjaW1hbFtdLCBiOiBCaWdEZWNpbWFsW10pOiBCaWdEZWNpbWFsW10ge1xuXHRvdXRbMF0gPSBhWzBdLm1pbihiWzBdKTtcblx0b3V0WzFdID0gYVsxXS5taW4oYlsxXSk7XG5cdG91dFsyXSA9IGFbMl0ubWluKGJbMl0pO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQ6IEJpZ0RlY2ltYWxbXSwgYTogQmlnRGVjaW1hbFtdLCBiOiBCaWdEZWNpbWFsW10pOiBCaWdEZWNpbWFsW10ge1xuXHRvdXRbMF0gPSBhWzBdLm1heChiWzBdKTtcblx0b3V0WzFdID0gYVsxXS5tYXgoYlsxXSk7XG5cdG91dFsyXSA9IGFbMl0ubWF4KGJbMl0pO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5cbmZ1bmN0aW9uIGdldFJvdW5kTUMobnVtOiBCaWdEZWNpbWFsKTogTWF0aENvbnRleHQge1xuXHRpZihudW0uZ3JlYXRlclRoYW4oXCIwXCIpKSB7XG5cdFx0aWYobnVtLnByZWNpc2lvbigpID09IG51bS5zY2FsZSgpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IE1DKDEsIFJvdW5kaW5nTW9kZS5IQUxGX1VQKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBNQyhudW0ucHJlY2lzaW9uKCktbnVtLnNjYWxlKCksIFJvdW5kaW5nTW9kZS5IQUxGX1VQKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYobnVtLnByZWNpc2lvbigpID09IG51bS5zY2FsZSgpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IE1DKDEsIFJvdW5kaW5nTW9kZS5IQUxGX0RPV04pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IE1DKG51bS5wcmVjaXNpb24oKS1udW0uc2NhbGUoKSwgUm91bmRpbmdNb2RlLkhBTEZfRE9XTik7XG5cdFx0fVxuXHR9XHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dDogQmlnRGVjaW1hbFtdLCBhOiBCaWdEZWNpbWFsW10pOiBCaWdEZWNpbWFsW10ge1xuXHRvdXRbMF0gPSBhWzBdLnJvdW5kKGdldFJvdW5kTUMoYVswXSkpO1x0XG5cdG91dFsxXSA9IGFbMV0ucm91bmQoZ2V0Um91bmRNQyhhWzFdKSk7XG5cdG91dFsyXSA9IGFbMl0ucm91bmQoZ2V0Um91bmRNQyhhWzJdKSk7XG5cdHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQ6IEJpZ0RlY2ltYWxbXSwgYTogQmlnRGVjaW1hbFtdLCBiOiBCaWdEZWNpbWFsKTogQmlnRGVjaW1hbFtdIHtcblx0b3V0WzBdID0gYVswXS5tdWx0aXBseShiKTtcblx0b3V0WzFdID0gYVsxXS5tdWx0aXBseShiKTtcblx0b3V0WzJdID0gYVsyXS5tdWx0aXBseShiKTtcblx0cmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dDogQmlnRGVjaW1hbFtdLCBhOiBCaWdEZWNpbWFsW10sIGI6IEJpZ0RlY2ltYWxbXSwgc2NhbGU6IEJpZ0RlY2ltYWwpOiBCaWdEZWNpbWFsW10ge1xuXHRvdXRbMF0gPSAoYVswXS5hZGQoYlswXSkpLm11bHRpcGx5KHNjYWxlKTtcblx0b3V0WzFdID0gKGFbMV0uYWRkKGJbMV0pKS5tdWx0aXBseShzY2FsZSk7XG5cdG91dFsyXSA9IChhWzJdLmFkZChiWzJdKSkubXVsdGlwbHkoc2NhbGUpO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYTogQmlnRGVjaW1hbFtdLCBiOiBCaWdEZWNpbWFsW10pOiBCaWdEZWNpbWFsIHtcblx0Y29uc3QgbWMgPSBuZXcgTUMoMjAsIFJvdW5kaW5nTW9kZS5DRUlMSU5HKTtcblx0Y29uc3QgeCA9IGJbMF0uc3VidHJhY3QoYVswXSk7XG5cdGNvbnN0IHkgPSBiWzFdLnN1YnRyYWN0KGFbMV0pO1xuXHRjb25zdCB6ID0gYlsyXS5zdWJ0cmFjdChhWzJdKTtcblx0Y29uc3Qgc3VtU3F1YXJlcyA9ICgoKHgubXVsdGlwbHkoeCkpLmFkZCh5Lm11bHRpcGx5KHkpKSkuYWRkKHoubXVsdGlwbHkoeikpKTtcblx0cmV0dXJuIHN1bVNxdWFyZXMuc3FydChtYyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYTogQmlnRGVjaW1hbFtdLCBiOiBCaWdEZWNpbWFsW10pOiBCaWdEZWNpbWFsIHtcblx0Y29uc3QgeCA9IGJbMF0uc3VidHJhY3QoYVswXSk7XG5cdGNvbnN0IHkgPSBiWzFdLnN1YnRyYWN0KGFbMV0pO1xuXHRjb25zdCB6ID0gYlsyXS5zdWJ0cmFjdChhWzJdKTtcblx0Y29uc3Qgc3VtU3F1YXJlcyA9ICgoKHgubXVsdGlwbHkoeCkpLmFkZCh5Lm11bHRpcGx5KHkpKSkuYWRkKHoubXVsdGlwbHkoeikpKTtcblx0cmV0dXJuIHN1bVNxdWFyZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGE6IEJpZ0RlY2ltYWxbXSk6IEJpZ0RlY2ltYWwge1xuXHRjb25zdCB4OiBCaWdEZWNpbWFsID0gYVswXTtcblx0Y29uc3QgeTogQmlnRGVjaW1hbCA9IGFbMV07XG5cdGNvbnN0IHo6IEJpZ0RlY2ltYWwgPSBhWzJdO1xuXHRjb25zdCBzdW1TcXVhcmVzID0gKCgoeC5tdWx0aXBseSh4KSkuYWRkKHkubXVsdGlwbHkoeSkpKS5hZGQoei5tdWx0aXBseSh6KSkpO1xuXHRyZXR1cm4gc3VtU3F1YXJlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQ6IEJpZ0RlY2ltYWxbXSwgYTogQmlnRGVjaW1hbFtdKTogQmlnRGVjaW1hbFtdIHtcblx0b3V0WzBdID0gYVswXS5uZWdhdGUoKTtcblx0b3V0WzFdID0gYVsxXS5uZWdhdGUoKTtcblx0b3V0WzJdID0gYVsyXS5uZWdhdGUoKTtcblx0cmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0OiBCaWdEZWNpbWFsW10sIGE6IEJpZ0RlY2ltYWxbXSk6IEJpZ0RlY2ltYWxbXSB7XG5cdG91dFswXSA9IEJpZyhcIjFcIikuZGl2aWRlKGFbMF0pO1xuXHRvdXRbMV0gPSBCaWcoXCIxXCIpLmRpdmlkZShhWzFdKTtcblx0b3V0WzJdID0gQmlnKFwiMVwiKS5kaXZpZGUoYVsyXSk7XG5cdHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0OiBCaWdEZWNpbWFsW10sIGE6IEJpZ0RlY2ltYWxbXSk6IEJpZ0RlY2ltYWxbXSB7XG5cdGxldCBsZW4gPSBzcXVhcmVkTGVuZ3RoKGEpO1xuXHRpZihsZW4uZ3JlYXRlclRoYW4oQmlnKFwiMFwiKSkpIHtcblx0XHRsZW4gPSBCaWcoXCIxXCIpLmRpdmlkZShsZW5ndGgoYSksIDIwLCBSb3VuZGluZ01vZGUuQ0VJTElORyk7XG5cdH1cblxuXHRvdXRbMF0gPSBhWzBdLm11bHRpcGx5KGxlbik7XG5cdG91dFsxXSA9IGFbMV0ubXVsdGlwbHkobGVuKTtcblx0b3V0WzJdID0gYVsyXS5tdWx0aXBseShsZW4pO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQ6IEJpZ0RlY2ltYWxbXSk6IEJpZ0RlY2ltYWxbXSB7XG5cdG91dFswXSA9IEJpZygwKTtcblx0b3V0WzFdID0gQmlnKDApO1xuXHRvdXRbMl0gPSBCaWcoMCk7XG5cdHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZWRWZWMzKGJWZWM6IEJpZ0RlY2ltYWxbXSwgbnVtOiBudW1iZXIsIHBvd2VyOiBudW1iZXIpOiB2ZWMzIHtcblx0bGV0IHNWID0gY3JlYXRlKCk7XG5cdHNjYWxlKHNWLCBiVmVjLCBCaWcobnVtLnRvU3RyaW5nKCkpLnBvdyhwb3dlciwgbmV3IE1DKDIwKSkpO1xuXHRsZXQgb3V0ID0gdmVjMy5jcmVhdGUoKTtcblx0b3V0WzBdID0gTnVtYmVyKHNWWzBdLnRvRW5naW5lZXJpbmdTdHJpbmcoKSk7XG5cdG91dFsxXSA9IE51bWJlcihzVlsxXS50b0VuZ2luZWVyaW5nU3RyaW5nKCkpO1xuXHRvdXRbMl0gPSBOdW1iZXIoc1ZbMl0udG9FbmdpbmVlcmluZ1N0cmluZygpKTtcblx0cmV0dXJuIG91dDtcbn1cblxuXG5cblxuXG4iLCJleHBvcnQgZnVuY3Rpb24gc2hvd0Vycm9yKGVycm9yVGV4dDogc3RyaW5nKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGVycm9yVGV4dClcclxuICAgIGNvbnN0IGVycm9yQm94RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yLWJveCcpO1xyXG4gICAgaWYgKGVycm9yQm94RGl2ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXJyb3JFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xyXG4gICAgZXJyb3JFbGVtZW50LmlubmVyVGV4dCA9IGVycm9yVGV4dDtcclxuICAgIGVycm9yQm94RGl2LmFwcGVuZENoaWxkKGVycm9yRWxlbWVudCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21JblJhbmdlKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xyXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgZGF0YTogQXJyYXlCdWZmZXIpIHtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgaWYgKCFidWZmZXIpIHtcclxuICAgICAgICBzaG93RXJyb3IoJ0ZhaWxlZCB0byBhbGxvY2F0ZWQgYnVmZmVyJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG5cclxuICAgIHJldHVybiBidWZmZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcihnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgZGF0YTogQXJyYXlCdWZmZXIpIHtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgaWYgKCFidWZmZXIpIHtcclxuICAgICAgICBzaG93RXJyb3IoJ0ZhaWxlZCB0byBhbGxvY2F0ZWQgYnVmZmVyJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG5cclxuICAgIHJldHVybiBidWZmZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKFxyXG4gICAgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsXHJcbiAgICB2ZXJ0ZXhTaGFkZXJTb3VyY2U6IHN0cmluZyxcclxuICAgIGZyYWdtZW50U2hhZGVyU291cmNlOiBzdHJpbmcpIHtcclxuXHJcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICBpZiAoIXZlcnRleFNoYWRlciB8fCAhZnJhZ21lbnRTaGFkZXIgfHwgIXByb2dyYW0pIHtcclxuICAgICAgICBzaG93RXJyb3IoYEZhaWxlZCB0byBhbGxvY2F0ZSBHTCBvYmplY3RzIChgXHJcbiAgICAgICAgICAgICsgYHZzPSR7ISF2ZXJ0ZXhTaGFkZXJ9LCBgXHJcbiAgICAgICAgICAgICsgYGZzPSR7ISFmcmFnbWVudFNoYWRlcn0sIGBcclxuICAgICAgICAgICAgKyBgcHJvZ3JhbT0keyEhcHJvZ3JhbX0pYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSk7XHJcbiAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XHJcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKTtcclxuICAgICAgICBzaG93RXJyb3IoYEZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXI6ICR7ZXJyb3JNZXNzYWdlfWApO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICAgIHNob3dFcnJvcihgRmFpbGVkIHRvIGNvbXBpbGUgZnJhZ21lbnQgc2hhZGVyOiAke2Vycm9yTWVzc2FnZX1gKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcclxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcclxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcclxuICAgICAgICBzaG93RXJyb3IoYEZhaWxlZCB0byBsaW5rIEdQVSBwcm9ncmFtOiAke2Vycm9yTWVzc2FnZX1gKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHByb2dyYW07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xyXG4gICAgaWYgKCFnbCkge1xyXG4gICAgICAgIGNvbnN0IGlzV2ViR2wxU3VwcG9ydGVkID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpLmdldENvbnRleHQoJ3dlYmdsJyk7XHJcbiAgICAgICAgaWYgKGlzV2ViR2wxU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgMSBpcyBzdXBwb3J0ZWQsIGJ1dCBub3QgdjIgLSB0cnkgdXNpbmcgYSBkaWZmZXJlbnQgZGV2aWNlIG9yIGJyb3dzZXInKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UgLSB0cnkgdXNpbmcgYSBkaWZmZXJlbnQgZGV2aWNlIG9yIGJyb3dzZXInKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2xcclxufVxyXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2FwcC50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==